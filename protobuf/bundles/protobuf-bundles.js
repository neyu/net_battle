var $protobuf = window.protobuf;
$protobuf.roots.default=window;
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.msgProto = (function() {

    /**
     * Namespace msgProto.
     * @exports msgProto
     * @namespace
     */
    var msgProto = {};

    msgProto.ChatReq = (function() {

        /**
         * Properties of a ChatReq.
         * @memberof msgProto
         * @interface IChatReq
         * @property {string|null} [Content] ChatReq Content
         */

        /**
         * Constructs a new ChatReq.
         * @memberof msgProto
         * @classdesc Represents a ChatReq.
         * @implements IChatReq
         * @constructor
         * @param {msgProto.IChatReq=} [properties] Properties to set
         */
        function ChatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatReq Content.
         * @member {string} Content
         * @memberof msgProto.ChatReq
         * @instance
         */
        ChatReq.prototype.Content = "";

        /**
         * Encodes the specified ChatReq message. Does not implicitly {@link msgProto.ChatReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatReq
         * @static
         * @param {msgProto.IChatReq} message ChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Content);
            return writer;
        };

        /**
         * Decodes a ChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatReq} ChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChatReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChatReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChatReq} ChatReq
         */
        ChatReq.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChatReq)
                return object;
            var message = new $root.msgProto.ChatReq();
            if (object.Content != null)
                message.Content = String(object.Content);
            return message;
        };

        /**
         * Creates a plain object from a ChatReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChatReq
         * @static
         * @param {msgProto.ChatReq} message ChatReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Content = "";
            if (message.Content != null && message.hasOwnProperty("Content"))
                object.Content = message.Content;
            return object;
        };

        /**
         * Converts this ChatReq to JSON.
         * @function toJSON
         * @memberof msgProto.ChatReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatReq;
    })();

    msgProto.ChatAck = (function() {

        /**
         * Properties of a ChatAck.
         * @memberof msgProto
         * @interface IChatAck
         * @property {string|null} [Content] ChatAck Content
         */

        /**
         * Constructs a new ChatAck.
         * @memberof msgProto
         * @classdesc Represents a ChatAck.
         * @implements IChatAck
         * @constructor
         * @param {msgProto.IChatAck=} [properties] Properties to set
         */
        function ChatAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatAck Content.
         * @member {string} Content
         * @memberof msgProto.ChatAck
         * @instance
         */
        ChatAck.prototype.Content = "";

        /**
         * Encodes the specified ChatAck message. Does not implicitly {@link msgProto.ChatAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatAck
         * @static
         * @param {msgProto.IChatAck} message ChatAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Content);
            return writer;
        };

        /**
         * Decodes a ChatAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatAck} ChatAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChatAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChatAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChatAck} ChatAck
         */
        ChatAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChatAck)
                return object;
            var message = new $root.msgProto.ChatAck();
            if (object.Content != null)
                message.Content = String(object.Content);
            return message;
        };

        /**
         * Creates a plain object from a ChatAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChatAck
         * @static
         * @param {msgProto.ChatAck} message ChatAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Content = "";
            if (message.Content != null && message.hasOwnProperty("Content"))
                object.Content = message.Content;
            return object;
        };

        /**
         * Converts this ChatAck to JSON.
         * @function toJSON
         * @memberof msgProto.ChatAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatAck;
    })();

    msgProto.TestAck = (function() {

        /**
         * Properties of a TestAck.
         * @memberof msgProto
         * @interface ITestAck
         * @property {string|null} [Dummy] TestAck Dummy
         */

        /**
         * Constructs a new TestAck.
         * @memberof msgProto
         * @classdesc Represents a TestAck.
         * @implements ITestAck
         * @constructor
         * @param {msgProto.ITestAck=} [properties] Properties to set
         */
        function TestAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestAck Dummy.
         * @member {string} Dummy
         * @memberof msgProto.TestAck
         * @instance
         */
        TestAck.prototype.Dummy = "";

        /**
         * Encodes the specified TestAck message. Does not implicitly {@link msgProto.TestAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TestAck
         * @static
         * @param {msgProto.ITestAck} message TestAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Dummy != null && message.hasOwnProperty("Dummy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Dummy);
            return writer;
        };

        /**
         * Decodes a TestAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TestAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TestAck} TestAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TestAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Dummy = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TestAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TestAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TestAck} TestAck
         */
        TestAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TestAck)
                return object;
            var message = new $root.msgProto.TestAck();
            if (object.Dummy != null)
                message.Dummy = String(object.Dummy);
            return message;
        };

        /**
         * Creates a plain object from a TestAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TestAck
         * @static
         * @param {msgProto.TestAck} message TestAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Dummy = "";
            if (message.Dummy != null && message.hasOwnProperty("Dummy"))
                object.Dummy = message.Dummy;
            return object;
        };

        /**
         * Converts this TestAck to JSON.
         * @function toJSON
         * @memberof msgProto.TestAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestAck;
    })();

    msgProto.ContentReq = (function() {

        /**
         * Properties of a ContentReq.
         * @memberof msgProto
         * @interface IContentReq
         * @property {string|null} [Msg] ContentReq Msg
         * @property {number|null} [Value] ContentReq Value
         */

        /**
         * Constructs a new ContentReq.
         * @memberof msgProto
         * @classdesc Represents a ContentReq.
         * @implements IContentReq
         * @constructor
         * @param {msgProto.IContentReq=} [properties] Properties to set
         */
        function ContentReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentReq Msg.
         * @member {string} Msg
         * @memberof msgProto.ContentReq
         * @instance
         */
        ContentReq.prototype.Msg = "";

        /**
         * ContentReq Value.
         * @member {number} Value
         * @memberof msgProto.ContentReq
         * @instance
         */
        ContentReq.prototype.Value = 0;

        /**
         * Encodes the specified ContentReq message. Does not implicitly {@link msgProto.ContentReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ContentReq
         * @static
         * @param {msgProto.IContentReq} message ContentReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Value);
            return writer;
        };

        /**
         * Decodes a ContentReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ContentReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ContentReq} ContentReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ContentReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = reader.string();
                    break;
                case 2:
                    message.Value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ContentReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ContentReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ContentReq} ContentReq
         */
        ContentReq.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ContentReq)
                return object;
            var message = new $root.msgProto.ContentReq();
            if (object.Msg != null)
                message.Msg = String(object.Msg);
            if (object.Value != null)
                message.Value = object.Value | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContentReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ContentReq
         * @static
         * @param {msgProto.ContentReq} message ContentReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContentReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Msg = "";
                object.Value = 0;
            }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                object.Msg = message.Msg;
            if (message.Value != null && message.hasOwnProperty("Value"))
                object.Value = message.Value;
            return object;
        };

        /**
         * Converts this ContentReq to JSON.
         * @function toJSON
         * @memberof msgProto.ContentReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContentReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContentReq;
    })();

    msgProto.ContentAck = (function() {

        /**
         * Properties of a ContentAck.
         * @memberof msgProto
         * @interface IContentAck
         * @property {string|null} [Msg] ContentAck Msg
         * @property {number|null} [Value] ContentAck Value
         */

        /**
         * Constructs a new ContentAck.
         * @memberof msgProto
         * @classdesc Represents a ContentAck.
         * @implements IContentAck
         * @constructor
         * @param {msgProto.IContentAck=} [properties] Properties to set
         */
        function ContentAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentAck Msg.
         * @member {string} Msg
         * @memberof msgProto.ContentAck
         * @instance
         */
        ContentAck.prototype.Msg = "";

        /**
         * ContentAck Value.
         * @member {number} Value
         * @memberof msgProto.ContentAck
         * @instance
         */
        ContentAck.prototype.Value = 0;

        /**
         * Encodes the specified ContentAck message. Does not implicitly {@link msgProto.ContentAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ContentAck
         * @static
         * @param {msgProto.IContentAck} message ContentAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Value);
            return writer;
        };

        /**
         * Decodes a ContentAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ContentAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ContentAck} ContentAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ContentAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = reader.string();
                    break;
                case 2:
                    message.Value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ContentAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ContentAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ContentAck} ContentAck
         */
        ContentAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ContentAck)
                return object;
            var message = new $root.msgProto.ContentAck();
            if (object.Msg != null)
                message.Msg = String(object.Msg);
            if (object.Value != null)
                message.Value = object.Value | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContentAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ContentAck
         * @static
         * @param {msgProto.ContentAck} message ContentAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContentAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Msg = "";
                object.Value = 0;
            }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                object.Msg = message.Msg;
            if (message.Value != null && message.hasOwnProperty("Value"))
                object.Value = message.Value;
            return object;
        };

        /**
         * Converts this ContentAck to JSON.
         * @function toJSON
         * @memberof msgProto.ContentAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContentAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContentAck;
    })();

    msgProto.ActivityBuyMysterShop = (function() {

        /**
         * Properties of an ActivityBuyMysterShop.
         * @memberof msgProto
         * @interface IActivityBuyMysterShop
         * @property {number|null} [activityId] ActivityBuyMysterShop activityId
         * @property {number|null} [index] ActivityBuyMysterShop index
         */

        /**
         * Constructs a new ActivityBuyMysterShop.
         * @memberof msgProto
         * @classdesc Represents an ActivityBuyMysterShop.
         * @implements IActivityBuyMysterShop
         * @constructor
         * @param {msgProto.IActivityBuyMysterShop=} [properties] Properties to set
         */
        function ActivityBuyMysterShop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityBuyMysterShop activityId.
         * @member {number} activityId
         * @memberof msgProto.ActivityBuyMysterShop
         * @instance
         */
        ActivityBuyMysterShop.prototype.activityId = 0;

        /**
         * ActivityBuyMysterShop index.
         * @member {number} index
         * @memberof msgProto.ActivityBuyMysterShop
         * @instance
         */
        ActivityBuyMysterShop.prototype.index = 0;

        /**
         * Encodes the specified ActivityBuyMysterShop message. Does not implicitly {@link msgProto.ActivityBuyMysterShop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {msgProto.IActivityBuyMysterShop} message ActivityBuyMysterShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityBuyMysterShop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes an ActivityBuyMysterShop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityBuyMysterShop} ActivityBuyMysterShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityBuyMysterShop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityBuyMysterShop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ActivityBuyMysterShop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ActivityBuyMysterShop} ActivityBuyMysterShop
         */
        ActivityBuyMysterShop.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ActivityBuyMysterShop)
                return object;
            var message = new $root.msgProto.ActivityBuyMysterShop();
            if (object.activityId != null)
                message.activityId = object.activityId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from an ActivityBuyMysterShop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {msgProto.ActivityBuyMysterShop} message ActivityBuyMysterShop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActivityBuyMysterShop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.activityId = 0;
                object.index = 0;
            }
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                object.activityId = message.activityId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this ActivityBuyMysterShop to JSON.
         * @function toJSON
         * @memberof msgProto.ActivityBuyMysterShop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActivityBuyMysterShop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActivityBuyMysterShop;
    })();

    msgProto.ActivityGetList = (function() {

        /**
         * Properties of an ActivityGetList.
         * @memberof msgProto
         * @interface IActivityGetList
         */

        /**
         * Constructs a new ActivityGetList.
         * @memberof msgProto
         * @classdesc Represents an ActivityGetList.
         * @implements IActivityGetList
         * @constructor
         * @param {msgProto.IActivityGetList=} [properties] Properties to set
         */
        function ActivityGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ActivityGetList message. Does not implicitly {@link msgProto.ActivityGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {msgProto.IActivityGetList} message ActivityGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ActivityGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityGetList} ActivityGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ActivityGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ActivityGetList} ActivityGetList
         */
        ActivityGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ActivityGetList)
                return object;
            return new $root.msgProto.ActivityGetList();
        };

        /**
         * Creates a plain object from an ActivityGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {msgProto.ActivityGetList} message ActivityGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActivityGetList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ActivityGetList to JSON.
         * @function toJSON
         * @memberof msgProto.ActivityGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActivityGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActivityGetList;
    })();

    msgProto.ActivityReceive = (function() {

        /**
         * Properties of an ActivityReceive.
         * @memberof msgProto
         * @interface IActivityReceive
         * @property {number|null} [activityId] ActivityReceive activityId
         * @property {number|null} [index] ActivityReceive index
         */

        /**
         * Constructs a new ActivityReceive.
         * @memberof msgProto
         * @classdesc Represents an ActivityReceive.
         * @implements IActivityReceive
         * @constructor
         * @param {msgProto.IActivityReceive=} [properties] Properties to set
         */
        function ActivityReceive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityReceive activityId.
         * @member {number} activityId
         * @memberof msgProto.ActivityReceive
         * @instance
         */
        ActivityReceive.prototype.activityId = 0;

        /**
         * ActivityReceive index.
         * @member {number} index
         * @memberof msgProto.ActivityReceive
         * @instance
         */
        ActivityReceive.prototype.index = 0;

        /**
         * Encodes the specified ActivityReceive message. Does not implicitly {@link msgProto.ActivityReceive.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {msgProto.IActivityReceive} message ActivityReceive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReceive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes an ActivityReceive message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityReceive} ActivityReceive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReceive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityReceive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ActivityReceive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ActivityReceive} ActivityReceive
         */
        ActivityReceive.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ActivityReceive)
                return object;
            var message = new $root.msgProto.ActivityReceive();
            if (object.activityId != null)
                message.activityId = object.activityId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from an ActivityReceive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {msgProto.ActivityReceive} message ActivityReceive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActivityReceive.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.activityId = 0;
                object.index = 0;
            }
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                object.activityId = message.activityId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this ActivityReceive to JSON.
         * @function toJSON
         * @memberof msgProto.ActivityReceive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActivityReceive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActivityReceive;
    })();

    msgProto.ActivityGetIsNeedOperate = (function() {

        /**
         * Properties of an ActivityGetIsNeedOperate.
         * @memberof msgProto
         * @interface IActivityGetIsNeedOperate
         */

        /**
         * Constructs a new ActivityGetIsNeedOperate.
         * @memberof msgProto
         * @classdesc Represents an ActivityGetIsNeedOperate.
         * @implements IActivityGetIsNeedOperate
         * @constructor
         * @param {msgProto.IActivityGetIsNeedOperate=} [properties] Properties to set
         */
        function ActivityGetIsNeedOperate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ActivityGetIsNeedOperate message. Does not implicitly {@link msgProto.ActivityGetIsNeedOperate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {msgProto.IActivityGetIsNeedOperate} message ActivityGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetIsNeedOperate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ActivityGetIsNeedOperate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityGetIsNeedOperate} ActivityGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetIsNeedOperate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityGetIsNeedOperate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ActivityGetIsNeedOperate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ActivityGetIsNeedOperate} ActivityGetIsNeedOperate
         */
        ActivityGetIsNeedOperate.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ActivityGetIsNeedOperate)
                return object;
            return new $root.msgProto.ActivityGetIsNeedOperate();
        };

        /**
         * Creates a plain object from an ActivityGetIsNeedOperate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {msgProto.ActivityGetIsNeedOperate} message ActivityGetIsNeedOperate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActivityGetIsNeedOperate.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ActivityGetIsNeedOperate to JSON.
         * @function toJSON
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActivityGetIsNeedOperate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActivityGetIsNeedOperate;
    })();

    msgProto.activity_patchSign = (function() {

        /**
         * Properties of an activity_patchSign.
         * @memberof msgProto
         * @interface Iactivity_patchSign
         * @property {number|null} [activityId] activity_patchSign activityId
         */

        /**
         * Constructs a new activity_patchSign.
         * @memberof msgProto
         * @classdesc Represents an activity_patchSign.
         * @implements Iactivity_patchSign
         * @constructor
         * @param {msgProto.Iactivity_patchSign=} [properties] Properties to set
         */
        function activity_patchSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * activity_patchSign activityId.
         * @member {number} activityId
         * @memberof msgProto.activity_patchSign
         * @instance
         */
        activity_patchSign.prototype.activityId = 0;

        /**
         * Encodes the specified activity_patchSign message. Does not implicitly {@link msgProto.activity_patchSign.verify|verify} messages.
         * @function encode
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {msgProto.Iactivity_patchSign} message activity_patchSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        activity_patchSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            return writer;
        };

        /**
         * Decodes an activity_patchSign message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.activity_patchSign} activity_patchSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        activity_patchSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.activity_patchSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an activity_patchSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.activity_patchSign} activity_patchSign
         */
        activity_patchSign.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.activity_patchSign)
                return object;
            var message = new $root.msgProto.activity_patchSign();
            if (object.activityId != null)
                message.activityId = object.activityId | 0;
            return message;
        };

        /**
         * Creates a plain object from an activity_patchSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {msgProto.activity_patchSign} message activity_patchSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        activity_patchSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.activityId = 0;
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                object.activityId = message.activityId;
            return object;
        };

        /**
         * Converts this activity_patchSign to JSON.
         * @function toJSON
         * @memberof msgProto.activity_patchSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        activity_patchSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return activity_patchSign;
    })();

    msgProto.ActivityReport = (function() {

        /**
         * Properties of an ActivityReport.
         * @memberof msgProto
         * @interface IActivityReport
         * @property {number|null} [ActivityId] ActivityReport ActivityId
         * @property {string|null} [report] ActivityReport report
         */

        /**
         * Constructs a new ActivityReport.
         * @memberof msgProto
         * @classdesc Represents an ActivityReport.
         * @implements IActivityReport
         * @constructor
         * @param {msgProto.IActivityReport=} [properties] Properties to set
         */
        function ActivityReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityReport ActivityId.
         * @member {number} ActivityId
         * @memberof msgProto.ActivityReport
         * @instance
         */
        ActivityReport.prototype.ActivityId = 0;

        /**
         * ActivityReport report.
         * @member {string} report
         * @memberof msgProto.ActivityReport
         * @instance
         */
        ActivityReport.prototype.report = "";

        /**
         * Encodes the specified ActivityReport message. Does not implicitly {@link msgProto.ActivityReport.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityReport
         * @static
         * @param {msgProto.IActivityReport} message ActivityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ActivityId != null && message.hasOwnProperty("ActivityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ActivityId);
            if (message.report != null && message.hasOwnProperty("report"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.report);
            return writer;
        };

        /**
         * Decodes an ActivityReport message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityReport} ActivityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ActivityId = reader.int32();
                    break;
                case 2:
                    message.report = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ActivityReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ActivityReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ActivityReport} ActivityReport
         */
        ActivityReport.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ActivityReport)
                return object;
            var message = new $root.msgProto.ActivityReport();
            if (object.ActivityId != null)
                message.ActivityId = object.ActivityId | 0;
            if (object.report != null)
                message.report = String(object.report);
            return message;
        };

        /**
         * Creates a plain object from an ActivityReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ActivityReport
         * @static
         * @param {msgProto.ActivityReport} message ActivityReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActivityReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ActivityId = 0;
                object.report = "";
            }
            if (message.ActivityId != null && message.hasOwnProperty("ActivityId"))
                object.ActivityId = message.ActivityId;
            if (message.report != null && message.hasOwnProperty("report"))
                object.report = message.report;
            return object;
        };

        /**
         * Converts this ActivityReport to JSON.
         * @function toJSON
         * @memberof msgProto.ActivityReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActivityReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActivityReport;
    })();

    msgProto.ArenaGetInfo = (function() {

        /**
         * Properties of an ArenaGetInfo.
         * @memberof msgProto
         * @interface IArenaGetInfo
         */

        /**
         * Constructs a new ArenaGetInfo.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetInfo.
         * @implements IArenaGetInfo
         * @constructor
         * @param {msgProto.IArenaGetInfo=} [properties] Properties to set
         */
        function ArenaGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaGetInfo message. Does not implicitly {@link msgProto.ArenaGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {msgProto.IArenaGetInfo} message ArenaGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetInfo} ArenaGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaGetInfo} ArenaGetInfo
         */
        ArenaGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaGetInfo)
                return object;
            return new $root.msgProto.ArenaGetInfo();
        };

        /**
         * Creates a plain object from an ArenaGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {msgProto.ArenaGetInfo} message ArenaGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaGetInfo;
    })();

    msgProto.ArenaResetFightRanks = (function() {

        /**
         * Properties of an ArenaResetFightRanks.
         * @memberof msgProto
         * @interface IArenaResetFightRanks
         */

        /**
         * Constructs a new ArenaResetFightRanks.
         * @memberof msgProto
         * @classdesc Represents an ArenaResetFightRanks.
         * @implements IArenaResetFightRanks
         * @constructor
         * @param {msgProto.IArenaResetFightRanks=} [properties] Properties to set
         */
        function ArenaResetFightRanks(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaResetFightRanks message. Does not implicitly {@link msgProto.ArenaResetFightRanks.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {msgProto.IArenaResetFightRanks} message ArenaResetFightRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaResetFightRanks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaResetFightRanks message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaResetFightRanks} ArenaResetFightRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaResetFightRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaResetFightRanks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaResetFightRanks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaResetFightRanks} ArenaResetFightRanks
         */
        ArenaResetFightRanks.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaResetFightRanks)
                return object;
            return new $root.msgProto.ArenaResetFightRanks();
        };

        /**
         * Creates a plain object from an ArenaResetFightRanks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {msgProto.ArenaResetFightRanks} message ArenaResetFightRanks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaResetFightRanks.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaResetFightRanks to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaResetFightRanks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaResetFightRanks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaResetFightRanks;
    })();

    msgProto.ArenaFightStart = (function() {

        /**
         * Properties of an ArenaFightStart.
         * @memberof msgProto
         * @interface IArenaFightStart
         * @property {string|null} [rank] ArenaFightStart rank
         */

        /**
         * Constructs a new ArenaFightStart.
         * @memberof msgProto
         * @classdesc Represents an ArenaFightStart.
         * @implements IArenaFightStart
         * @constructor
         * @param {msgProto.IArenaFightStart=} [properties] Properties to set
         */
        function ArenaFightStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaFightStart rank.
         * @member {string} rank
         * @memberof msgProto.ArenaFightStart
         * @instance
         */
        ArenaFightStart.prototype.rank = "";

        /**
         * Encodes the specified ArenaFightStart message. Does not implicitly {@link msgProto.ArenaFightStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {msgProto.IArenaFightStart} message ArenaFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rank != null && message.hasOwnProperty("rank"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rank);
            return writer;
        };

        /**
         * Decodes an ArenaFightStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaFightStart} ArenaFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaFightStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaFightStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaFightStart} ArenaFightStart
         */
        ArenaFightStart.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaFightStart)
                return object;
            var message = new $root.msgProto.ArenaFightStart();
            if (object.rank != null)
                message.rank = String(object.rank);
            return message;
        };

        /**
         * Creates a plain object from an ArenaFightStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {msgProto.ArenaFightStart} message ArenaFightStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaFightStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rank = "";
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            return object;
        };

        /**
         * Converts this ArenaFightStart to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaFightStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaFightStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaFightStart;
    })();

    msgProto.ArenaFightEnd = (function() {

        /**
         * Properties of an ArenaFightEnd.
         * @memberof msgProto
         * @interface IArenaFightEnd
         * @property {string|null} [rank] ArenaFightEnd rank
         * @property {number|null} [isWin] ArenaFightEnd isWin
         * @property {string|null} [fightData] ArenaFightEnd fightData
         */

        /**
         * Constructs a new ArenaFightEnd.
         * @memberof msgProto
         * @classdesc Represents an ArenaFightEnd.
         * @implements IArenaFightEnd
         * @constructor
         * @param {msgProto.IArenaFightEnd=} [properties] Properties to set
         */
        function ArenaFightEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaFightEnd rank.
         * @member {string} rank
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.rank = "";

        /**
         * ArenaFightEnd isWin.
         * @member {number} isWin
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.isWin = 0;

        /**
         * ArenaFightEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.fightData = "";

        /**
         * Encodes the specified ArenaFightEnd message. Does not implicitly {@link msgProto.ArenaFightEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {msgProto.IArenaFightEnd} message ArenaFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rank != null && message.hasOwnProperty("rank"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rank);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isWin);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Decodes an ArenaFightEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaFightEnd} ArenaFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaFightEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.string();
                    break;
                case 2:
                    message.isWin = reader.int32();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaFightEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaFightEnd} ArenaFightEnd
         */
        ArenaFightEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaFightEnd)
                return object;
            var message = new $root.msgProto.ArenaFightEnd();
            if (object.rank != null)
                message.rank = String(object.rank);
            if (object.isWin != null)
                message.isWin = object.isWin | 0;
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            return message;
        };

        /**
         * Creates a plain object from an ArenaFightEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {msgProto.ArenaFightEnd} message ArenaFightEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaFightEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rank = "";
                object.isWin = 0;
                object.fightData = "";
            }
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            return object;
        };

        /**
         * Converts this ArenaFightEnd to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaFightEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaFightEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaFightEnd;
    })();

    msgProto.ArenaGetFightUserList = (function() {

        /**
         * Properties of an ArenaGetFightUserList.
         * @memberof msgProto
         * @interface IArenaGetFightUserList
         */

        /**
         * Constructs a new ArenaGetFightUserList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetFightUserList.
         * @implements IArenaGetFightUserList
         * @constructor
         * @param {msgProto.IArenaGetFightUserList=} [properties] Properties to set
         */
        function ArenaGetFightUserList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaGetFightUserList message. Does not implicitly {@link msgProto.ArenaGetFightUserList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {msgProto.IArenaGetFightUserList} message ArenaGetFightUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetFightUserList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaGetFightUserList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetFightUserList} ArenaGetFightUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetFightUserList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetFightUserList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaGetFightUserList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaGetFightUserList} ArenaGetFightUserList
         */
        ArenaGetFightUserList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaGetFightUserList)
                return object;
            return new $root.msgProto.ArenaGetFightUserList();
        };

        /**
         * Creates a plain object from an ArenaGetFightUserList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {msgProto.ArenaGetFightUserList} message ArenaGetFightUserList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaGetFightUserList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaGetFightUserList to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaGetFightUserList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaGetFightUserList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaGetFightUserList;
    })();

    msgProto.ArenaBuyPKNum = (function() {

        /**
         * Properties of an ArenaBuyPKNum.
         * @memberof msgProto
         * @interface IArenaBuyPKNum
         */

        /**
         * Constructs a new ArenaBuyPKNum.
         * @memberof msgProto
         * @classdesc Represents an ArenaBuyPKNum.
         * @implements IArenaBuyPKNum
         * @constructor
         * @param {msgProto.IArenaBuyPKNum=} [properties] Properties to set
         */
        function ArenaBuyPKNum(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaBuyPKNum message. Does not implicitly {@link msgProto.ArenaBuyPKNum.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {msgProto.IArenaBuyPKNum} message ArenaBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaBuyPKNum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaBuyPKNum message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaBuyPKNum} ArenaBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaBuyPKNum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaBuyPKNum();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaBuyPKNum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaBuyPKNum} ArenaBuyPKNum
         */
        ArenaBuyPKNum.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaBuyPKNum)
                return object;
            return new $root.msgProto.ArenaBuyPKNum();
        };

        /**
         * Creates a plain object from an ArenaBuyPKNum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {msgProto.ArenaBuyPKNum} message ArenaBuyPKNum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaBuyPKNum.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaBuyPKNum to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaBuyPKNum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaBuyPKNum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaBuyPKNum;
    })();

    msgProto.ArenaGetRecordList = (function() {

        /**
         * Properties of an ArenaGetRecordList.
         * @memberof msgProto
         * @interface IArenaGetRecordList
         * @property {number|null} [index] ArenaGetRecordList index
         * @property {number|null} [coun] ArenaGetRecordList coun
         */

        /**
         * Constructs a new ArenaGetRecordList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRecordList.
         * @implements IArenaGetRecordList
         * @constructor
         * @param {msgProto.IArenaGetRecordList=} [properties] Properties to set
         */
        function ArenaGetRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaGetRecordList index.
         * @member {number} index
         * @memberof msgProto.ArenaGetRecordList
         * @instance
         */
        ArenaGetRecordList.prototype.index = 0;

        /**
         * ArenaGetRecordList coun.
         * @member {number} coun
         * @memberof msgProto.ArenaGetRecordList
         * @instance
         */
        ArenaGetRecordList.prototype.coun = 0;

        /**
         * Encodes the specified ArenaGetRecordList message. Does not implicitly {@link msgProto.ArenaGetRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {msgProto.IArenaGetRecordList} message ArenaGetRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.coun != null && message.hasOwnProperty("coun"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.coun);
            return writer;
        };

        /**
         * Decodes an ArenaGetRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRecordList} ArenaGetRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.coun = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaGetRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaGetRecordList} ArenaGetRecordList
         */
        ArenaGetRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaGetRecordList)
                return object;
            var message = new $root.msgProto.ArenaGetRecordList();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.coun != null)
                message.coun = object.coun | 0;
            return message;
        };

        /**
         * Creates a plain object from an ArenaGetRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {msgProto.ArenaGetRecordList} message ArenaGetRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaGetRecordList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.coun = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.coun != null && message.hasOwnProperty("coun"))
                object.coun = message.coun;
            return object;
        };

        /**
         * Converts this ArenaGetRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaGetRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaGetRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaGetRecordList;
    })();

    msgProto.ArenaSetRead = (function() {

        /**
         * Properties of an ArenaSetRead.
         * @memberof msgProto
         * @interface IArenaSetRead
         */

        /**
         * Constructs a new ArenaSetRead.
         * @memberof msgProto
         * @classdesc Represents an ArenaSetRead.
         * @implements IArenaSetRead
         * @constructor
         * @param {msgProto.IArenaSetRead=} [properties] Properties to set
         */
        function ArenaSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaSetRead message. Does not implicitly {@link msgProto.ArenaSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {msgProto.IArenaSetRead} message ArenaSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaSetRead} ArenaSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaSetRead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaSetRead} ArenaSetRead
         */
        ArenaSetRead.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaSetRead)
                return object;
            return new $root.msgProto.ArenaSetRead();
        };

        /**
         * Creates a plain object from an ArenaSetRead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {msgProto.ArenaSetRead} message ArenaSetRead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaSetRead.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaSetRead to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaSetRead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaSetRead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaSetRead;
    })();

    msgProto.ArenaPickRankAward = (function() {

        /**
         * Properties of an ArenaPickRankAward.
         * @memberof msgProto
         * @interface IArenaPickRankAward
         */

        /**
         * Constructs a new ArenaPickRankAward.
         * @memberof msgProto
         * @classdesc Represents an ArenaPickRankAward.
         * @implements IArenaPickRankAward
         * @constructor
         * @param {msgProto.IArenaPickRankAward=} [properties] Properties to set
         */
        function ArenaPickRankAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaPickRankAward message. Does not implicitly {@link msgProto.ArenaPickRankAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {msgProto.IArenaPickRankAward} message ArenaPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaPickRankAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaPickRankAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaPickRankAward} ArenaPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaPickRankAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaPickRankAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaPickRankAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaPickRankAward} ArenaPickRankAward
         */
        ArenaPickRankAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaPickRankAward)
                return object;
            return new $root.msgProto.ArenaPickRankAward();
        };

        /**
         * Creates a plain object from an ArenaPickRankAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {msgProto.ArenaPickRankAward} message ArenaPickRankAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaPickRankAward.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaPickRankAward to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaPickRankAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaPickRankAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaPickRankAward;
    })();

    msgProto.ArenaRefreshCD = (function() {

        /**
         * Properties of an ArenaRefreshCD.
         * @memberof msgProto
         * @interface IArenaRefreshCD
         */

        /**
         * Constructs a new ArenaRefreshCD.
         * @memberof msgProto
         * @classdesc Represents an ArenaRefreshCD.
         * @implements IArenaRefreshCD
         * @constructor
         * @param {msgProto.IArenaRefreshCD=} [properties] Properties to set
         */
        function ArenaRefreshCD(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaRefreshCD message. Does not implicitly {@link msgProto.ArenaRefreshCD.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {msgProto.IArenaRefreshCD} message ArenaRefreshCD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaRefreshCD.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaRefreshCD message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaRefreshCD} ArenaRefreshCD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaRefreshCD.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaRefreshCD();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaRefreshCD message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaRefreshCD} ArenaRefreshCD
         */
        ArenaRefreshCD.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaRefreshCD)
                return object;
            return new $root.msgProto.ArenaRefreshCD();
        };

        /**
         * Creates a plain object from an ArenaRefreshCD message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {msgProto.ArenaRefreshCD} message ArenaRefreshCD
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaRefreshCD.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaRefreshCD to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaRefreshCD
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaRefreshCD.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaRefreshCD;
    })();

    msgProto.ArenaGetRankList = (function() {

        /**
         * Properties of an ArenaGetRankList.
         * @memberof msgProto
         * @interface IArenaGetRankList
         */

        /**
         * Constructs a new ArenaGetRankList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRankList.
         * @implements IArenaGetRankList
         * @constructor
         * @param {msgProto.IArenaGetRankList=} [properties] Properties to set
         */
        function ArenaGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaGetRankList message. Does not implicitly {@link msgProto.ArenaGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {msgProto.IArenaGetRankList} message ArenaGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRankList} ArenaGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaGetRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaGetRankList} ArenaGetRankList
         */
        ArenaGetRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaGetRankList)
                return object;
            return new $root.msgProto.ArenaGetRankList();
        };

        /**
         * Creates a plain object from an ArenaGetRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {msgProto.ArenaGetRankList} message ArenaGetRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaGetRankList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaGetRankList to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaGetRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaGetRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaGetRankList;
    })();

    msgProto.ArenaGetRefreshRemainTime = (function() {

        /**
         * Properties of an ArenaGetRefreshRemainTime.
         * @memberof msgProto
         * @interface IArenaGetRefreshRemainTime
         */

        /**
         * Constructs a new ArenaGetRefreshRemainTime.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRefreshRemainTime.
         * @implements IArenaGetRefreshRemainTime
         * @constructor
         * @param {msgProto.IArenaGetRefreshRemainTime=} [properties] Properties to set
         */
        function ArenaGetRefreshRemainTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ArenaGetRefreshRemainTime message. Does not implicitly {@link msgProto.ArenaGetRefreshRemainTime.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {msgProto.IArenaGetRefreshRemainTime} message ArenaGetRefreshRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRefreshRemainTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ArenaGetRefreshRemainTime message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRefreshRemainTime} ArenaGetRefreshRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRefreshRemainTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRefreshRemainTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ArenaGetRefreshRemainTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ArenaGetRefreshRemainTime} ArenaGetRefreshRemainTime
         */
        ArenaGetRefreshRemainTime.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ArenaGetRefreshRemainTime)
                return object;
            return new $root.msgProto.ArenaGetRefreshRemainTime();
        };

        /**
         * Creates a plain object from an ArenaGetRefreshRemainTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {msgProto.ArenaGetRefreshRemainTime} message ArenaGetRefreshRemainTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArenaGetRefreshRemainTime.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ArenaGetRefreshRemainTime to JSON.
         * @function toJSON
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArenaGetRefreshRemainTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArenaGetRefreshRemainTime;
    })();

    msgProto.BonusGetInfo = (function() {

        /**
         * Properties of a BonusGetInfo.
         * @memberof msgProto
         * @interface IBonusGetInfo
         * @property {number|null} [lastId] BonusGetInfo lastId
         */

        /**
         * Constructs a new BonusGetInfo.
         * @memberof msgProto
         * @classdesc Represents a BonusGetInfo.
         * @implements IBonusGetInfo
         * @constructor
         * @param {msgProto.IBonusGetInfo=} [properties] Properties to set
         */
        function BonusGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusGetInfo lastId.
         * @member {number} lastId
         * @memberof msgProto.BonusGetInfo
         * @instance
         */
        BonusGetInfo.prototype.lastId = 0;

        /**
         * Encodes the specified BonusGetInfo message. Does not implicitly {@link msgProto.BonusGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {msgProto.IBonusGetInfo} message BonusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Decodes a BonusGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusGetInfo} BonusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BonusGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BonusGetInfo} BonusGetInfo
         */
        BonusGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BonusGetInfo)
                return object;
            var message = new $root.msgProto.BonusGetInfo();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BonusGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {msgProto.BonusGetInfo} message BonusGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BonusGetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.lastId = 0;
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            return object;
        };

        /**
         * Converts this BonusGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.BonusGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BonusGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BonusGetInfo;
    })();

    msgProto.BonusBreakRelation = (function() {

        /**
         * Properties of a BonusBreakRelation.
         * @memberof msgProto
         * @interface IBonusBreakRelation
         * @property {number|Long|null} [inviteeUserId] BonusBreakRelation inviteeUserId
         */

        /**
         * Constructs a new BonusBreakRelation.
         * @memberof msgProto
         * @classdesc Represents a BonusBreakRelation.
         * @implements IBonusBreakRelation
         * @constructor
         * @param {msgProto.IBonusBreakRelation=} [properties] Properties to set
         */
        function BonusBreakRelation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusBreakRelation inviteeUserId.
         * @member {number|Long} inviteeUserId
         * @memberof msgProto.BonusBreakRelation
         * @instance
         */
        BonusBreakRelation.prototype.inviteeUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified BonusBreakRelation message. Does not implicitly {@link msgProto.BonusBreakRelation.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {msgProto.IBonusBreakRelation} message BonusBreakRelation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusBreakRelation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inviteeUserId != null && message.hasOwnProperty("inviteeUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inviteeUserId);
            return writer;
        };

        /**
         * Decodes a BonusBreakRelation message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusBreakRelation} BonusBreakRelation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusBreakRelation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusBreakRelation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.inviteeUserId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BonusBreakRelation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BonusBreakRelation} BonusBreakRelation
         */
        BonusBreakRelation.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BonusBreakRelation)
                return object;
            var message = new $root.msgProto.BonusBreakRelation();
            if (object.inviteeUserId != null)
                if ($util.Long)
                    (message.inviteeUserId = $util.Long.fromValue(object.inviteeUserId)).unsigned = true;
                else if (typeof object.inviteeUserId === "string")
                    message.inviteeUserId = parseInt(object.inviteeUserId, 10);
                else if (typeof object.inviteeUserId === "number")
                    message.inviteeUserId = object.inviteeUserId;
                else if (typeof object.inviteeUserId === "object")
                    message.inviteeUserId = new $util.LongBits(object.inviteeUserId.low >>> 0, object.inviteeUserId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a BonusBreakRelation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {msgProto.BonusBreakRelation} message BonusBreakRelation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BonusBreakRelation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.inviteeUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.inviteeUserId = options.longs === String ? "0" : 0;
            if (message.inviteeUserId != null && message.hasOwnProperty("inviteeUserId"))
                if (typeof message.inviteeUserId === "number")
                    object.inviteeUserId = options.longs === String ? String(message.inviteeUserId) : message.inviteeUserId;
                else
                    object.inviteeUserId = options.longs === String ? $util.Long.prototype.toString.call(message.inviteeUserId) : options.longs === Number ? new $util.LongBits(message.inviteeUserId.low >>> 0, message.inviteeUserId.high >>> 0).toNumber(true) : message.inviteeUserId;
            return object;
        };

        /**
         * Converts this BonusBreakRelation to JSON.
         * @function toJSON
         * @memberof msgProto.BonusBreakRelation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BonusBreakRelation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BonusBreakRelation;
    })();

    msgProto.BonusShare = (function() {

        /**
         * Properties of a BonusShare.
         * @memberof msgProto
         * @interface IBonusShare
         * @property {number|null} [serverIndexId] BonusShare serverIndexId
         */

        /**
         * Constructs a new BonusShare.
         * @memberof msgProto
         * @classdesc Represents a BonusShare.
         * @implements IBonusShare
         * @constructor
         * @param {msgProto.IBonusShare=} [properties] Properties to set
         */
        function BonusShare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusShare serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.BonusShare
         * @instance
         */
        BonusShare.prototype.serverIndexId = 0;

        /**
         * Encodes the specified BonusShare message. Does not implicitly {@link msgProto.BonusShare.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusShare
         * @static
         * @param {msgProto.IBonusShare} message BonusShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusShare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverIndexId);
            return writer;
        };

        /**
         * Decodes a BonusShare message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusShare} BonusShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusShare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusShare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverIndexId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BonusShare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BonusShare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BonusShare} BonusShare
         */
        BonusShare.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BonusShare)
                return object;
            var message = new $root.msgProto.BonusShare();
            if (object.serverIndexId != null)
                message.serverIndexId = object.serverIndexId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BonusShare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BonusShare
         * @static
         * @param {msgProto.BonusShare} message BonusShare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BonusShare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverIndexId = 0;
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                object.serverIndexId = message.serverIndexId;
            return object;
        };

        /**
         * Converts this BonusShare to JSON.
         * @function toJSON
         * @memberof msgProto.BonusShare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BonusShare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BonusShare;
    })();

    msgProto.BonusDraw = (function() {

        /**
         * Properties of a BonusDraw.
         * @memberof msgProto
         * @interface IBonusDraw
         */

        /**
         * Constructs a new BonusDraw.
         * @memberof msgProto
         * @classdesc Represents a BonusDraw.
         * @implements IBonusDraw
         * @constructor
         * @param {msgProto.IBonusDraw=} [properties] Properties to set
         */
        function BonusDraw(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified BonusDraw message. Does not implicitly {@link msgProto.BonusDraw.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusDraw
         * @static
         * @param {msgProto.IBonusDraw} message BonusDraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusDraw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a BonusDraw message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusDraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusDraw} BonusDraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusDraw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusDraw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BonusDraw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BonusDraw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BonusDraw} BonusDraw
         */
        BonusDraw.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BonusDraw)
                return object;
            return new $root.msgProto.BonusDraw();
        };

        /**
         * Creates a plain object from a BonusDraw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BonusDraw
         * @static
         * @param {msgProto.BonusDraw} message BonusDraw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BonusDraw.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BonusDraw to JSON.
         * @function toJSON
         * @memberof msgProto.BonusDraw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BonusDraw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BonusDraw;
    })();

    msgProto.BonusSendShareGift = (function() {

        /**
         * Properties of a BonusSendShareGift.
         * @memberof msgProto
         * @interface IBonusSendShareGift
         */

        /**
         * Constructs a new BonusSendShareGift.
         * @memberof msgProto
         * @classdesc Represents a BonusSendShareGift.
         * @implements IBonusSendShareGift
         * @constructor
         * @param {msgProto.IBonusSendShareGift=} [properties] Properties to set
         */
        function BonusSendShareGift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified BonusSendShareGift message. Does not implicitly {@link msgProto.BonusSendShareGift.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {msgProto.IBonusSendShareGift} message BonusSendShareGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusSendShareGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a BonusSendShareGift message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusSendShareGift} BonusSendShareGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusSendShareGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusSendShareGift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BonusSendShareGift message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BonusSendShareGift} BonusSendShareGift
         */
        BonusSendShareGift.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BonusSendShareGift)
                return object;
            return new $root.msgProto.BonusSendShareGift();
        };

        /**
         * Creates a plain object from a BonusSendShareGift message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {msgProto.BonusSendShareGift} message BonusSendShareGift
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BonusSendShareGift.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BonusSendShareGift to JSON.
         * @function toJSON
         * @memberof msgProto.BonusSendShareGift
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BonusSendShareGift.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BonusSendShareGift;
    })();

    msgProto.BossGetGuildBossList = (function() {

        /**
         * Properties of a BossGetGuildBossList.
         * @memberof msgProto
         * @interface IBossGetGuildBossList
         */

        /**
         * Constructs a new BossGetGuildBossList.
         * @memberof msgProto
         * @classdesc Represents a BossGetGuildBossList.
         * @implements IBossGetGuildBossList
         * @constructor
         * @param {msgProto.IBossGetGuildBossList=} [properties] Properties to set
         */
        function BossGetGuildBossList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified BossGetGuildBossList message. Does not implicitly {@link msgProto.BossGetGuildBossList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {msgProto.IBossGetGuildBossList} message BossGetGuildBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetGuildBossList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a BossGetGuildBossList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetGuildBossList} BossGetGuildBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetGuildBossList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetGuildBossList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetGuildBossList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetGuildBossList} BossGetGuildBossList
         */
        BossGetGuildBossList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetGuildBossList)
                return object;
            return new $root.msgProto.BossGetGuildBossList();
        };

        /**
         * Creates a plain object from a BossGetGuildBossList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {msgProto.BossGetGuildBossList} message BossGetGuildBossList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetGuildBossList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BossGetGuildBossList to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetGuildBossList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetGuildBossList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetGuildBossList;
    })();

    msgProto.BossGetWorldBossList = (function() {

        /**
         * Properties of a BossGetWorldBossList.
         * @memberof msgProto
         * @interface IBossGetWorldBossList
         */

        /**
         * Constructs a new BossGetWorldBossList.
         * @memberof msgProto
         * @classdesc Represents a BossGetWorldBossList.
         * @implements IBossGetWorldBossList
         * @constructor
         * @param {msgProto.IBossGetWorldBossList=} [properties] Properties to set
         */
        function BossGetWorldBossList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified BossGetWorldBossList message. Does not implicitly {@link msgProto.BossGetWorldBossList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {msgProto.IBossGetWorldBossList} message BossGetWorldBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetWorldBossList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a BossGetWorldBossList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetWorldBossList} BossGetWorldBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetWorldBossList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetWorldBossList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetWorldBossList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetWorldBossList} BossGetWorldBossList
         */
        BossGetWorldBossList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetWorldBossList)
                return object;
            return new $root.msgProto.BossGetWorldBossList();
        };

        /**
         * Creates a plain object from a BossGetWorldBossList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {msgProto.BossGetWorldBossList} message BossGetWorldBossList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetWorldBossList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BossGetWorldBossList to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetWorldBossList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetWorldBossList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetWorldBossList;
    })();

    msgProto.BossOpenBoss = (function() {

        /**
         * Properties of a BossOpenBoss.
         * @memberof msgProto
         * @interface IBossOpenBoss
         * @property {number|null} [bossId] BossOpenBoss bossId
         * @property {number|null} [isLock] BossOpenBoss isLock
         */

        /**
         * Constructs a new BossOpenBoss.
         * @memberof msgProto
         * @classdesc Represents a BossOpenBoss.
         * @implements IBossOpenBoss
         * @constructor
         * @param {msgProto.IBossOpenBoss=} [properties] Properties to set
         */
        function BossOpenBoss(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossOpenBoss bossId.
         * @member {number} bossId
         * @memberof msgProto.BossOpenBoss
         * @instance
         */
        BossOpenBoss.prototype.bossId = 0;

        /**
         * BossOpenBoss isLock.
         * @member {number} isLock
         * @memberof msgProto.BossOpenBoss
         * @instance
         */
        BossOpenBoss.prototype.isLock = 0;

        /**
         * Encodes the specified BossOpenBoss message. Does not implicitly {@link msgProto.BossOpenBoss.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {msgProto.IBossOpenBoss} message BossOpenBoss message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossOpenBoss.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.isLock != null && message.hasOwnProperty("isLock"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isLock);
            return writer;
        };

        /**
         * Decodes a BossOpenBoss message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossOpenBoss} BossOpenBoss
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossOpenBoss.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossOpenBoss();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.isLock = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossOpenBoss message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossOpenBoss} BossOpenBoss
         */
        BossOpenBoss.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossOpenBoss)
                return object;
            var message = new $root.msgProto.BossOpenBoss();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            if (object.isLock != null)
                message.isLock = object.isLock | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossOpenBoss message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {msgProto.BossOpenBoss} message BossOpenBoss
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossOpenBoss.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bossId = 0;
                object.isLock = 0;
            }
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            if (message.isLock != null && message.hasOwnProperty("isLock"))
                object.isLock = message.isLock;
            return object;
        };

        /**
         * Converts this BossOpenBoss to JSON.
         * @function toJSON
         * @memberof msgProto.BossOpenBoss
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossOpenBoss.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossOpenBoss;
    })();

    msgProto.BossEnter = (function() {

        /**
         * Properties of a BossEnter.
         * @memberof msgProto
         * @interface IBossEnter
         * @property {number|null} [bossId] BossEnter bossId
         */

        /**
         * Constructs a new BossEnter.
         * @memberof msgProto
         * @classdesc Represents a BossEnter.
         * @implements IBossEnter
         * @constructor
         * @param {msgProto.IBossEnter=} [properties] Properties to set
         */
        function BossEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossEnter bossId.
         * @member {number} bossId
         * @memberof msgProto.BossEnter
         * @instance
         */
        BossEnter.prototype.bossId = 0;

        /**
         * Encodes the specified BossEnter message. Does not implicitly {@link msgProto.BossEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossEnter
         * @static
         * @param {msgProto.IBossEnter} message BossEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossEnter} BossEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossEnter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossEnter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossEnter} BossEnter
         */
        BossEnter.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossEnter)
                return object;
            var message = new $root.msgProto.BossEnter();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossEnter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossEnter
         * @static
         * @param {msgProto.BossEnter} message BossEnter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossEnter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossEnter to JSON.
         * @function toJSON
         * @memberof msgProto.BossEnter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossEnter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossEnter;
    })();

    msgProto.BossStartFight = (function() {

        /**
         * Properties of a BossStartFight.
         * @memberof msgProto
         * @interface IBossStartFight
         * @property {number|null} [bossId] BossStartFight bossId
         */

        /**
         * Constructs a new BossStartFight.
         * @memberof msgProto
         * @classdesc Represents a BossStartFight.
         * @implements IBossStartFight
         * @constructor
         * @param {msgProto.IBossStartFight=} [properties] Properties to set
         */
        function BossStartFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossStartFight bossId.
         * @member {number} bossId
         * @memberof msgProto.BossStartFight
         * @instance
         */
        BossStartFight.prototype.bossId = 0;

        /**
         * Encodes the specified BossStartFight message. Does not implicitly {@link msgProto.BossStartFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossStartFight
         * @static
         * @param {msgProto.IBossStartFight} message BossStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossStartFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossStartFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossStartFight} BossStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossStartFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossStartFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossStartFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossStartFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossStartFight} BossStartFight
         */
        BossStartFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossStartFight)
                return object;
            var message = new $root.msgProto.BossStartFight();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossStartFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossStartFight
         * @static
         * @param {msgProto.BossStartFight} message BossStartFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossStartFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossStartFight to JSON.
         * @function toJSON
         * @memberof msgProto.BossStartFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossStartFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossStartFight;
    })();

    msgProto.BossHurt = (function() {

        /**
         * Properties of a BossHurt.
         * @memberof msgProto
         * @interface IBossHurt
         * @property {number|null} [bossId] BossHurt bossId
         * @property {string|null} [hurtDic] BossHurt hurtDic
         * @property {number|null} [isEnd] BossHurt isEnd
         * @property {string|null} [mData] BossHurt mData
         * @property {string|null} [hurtArr] BossHurt hurtArr
         */

        /**
         * Constructs a new BossHurt.
         * @memberof msgProto
         * @classdesc Represents a BossHurt.
         * @implements IBossHurt
         * @constructor
         * @param {msgProto.IBossHurt=} [properties] Properties to set
         */
        function BossHurt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossHurt bossId.
         * @member {number} bossId
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.bossId = 0;

        /**
         * BossHurt hurtDic.
         * @member {string} hurtDic
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.hurtDic = "";

        /**
         * BossHurt isEnd.
         * @member {number} isEnd
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.isEnd = 0;

        /**
         * BossHurt mData.
         * @member {string} mData
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.mData = "";

        /**
         * BossHurt hurtArr.
         * @member {string} hurtArr
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.hurtArr = "";

        /**
         * Encodes the specified BossHurt message. Does not implicitly {@link msgProto.BossHurt.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossHurt
         * @static
         * @param {msgProto.IBossHurt} message BossHurt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossHurt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.hurtDic != null && message.hasOwnProperty("hurtDic"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hurtDic);
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isEnd);
            if (message.mData != null && message.hasOwnProperty("mData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.mData);
            if (message.hurtArr != null && message.hasOwnProperty("hurtArr"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hurtArr);
            return writer;
        };

        /**
         * Decodes a BossHurt message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossHurt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossHurt} BossHurt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossHurt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossHurt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.hurtDic = reader.string();
                    break;
                case 3:
                    message.isEnd = reader.int32();
                    break;
                case 4:
                    message.mData = reader.string();
                    break;
                case 5:
                    message.hurtArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossHurt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossHurt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossHurt} BossHurt
         */
        BossHurt.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossHurt)
                return object;
            var message = new $root.msgProto.BossHurt();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            if (object.hurtDic != null)
                message.hurtDic = String(object.hurtDic);
            if (object.isEnd != null)
                message.isEnd = object.isEnd | 0;
            if (object.mData != null)
                message.mData = String(object.mData);
            if (object.hurtArr != null)
                message.hurtArr = String(object.hurtArr);
            return message;
        };

        /**
         * Creates a plain object from a BossHurt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossHurt
         * @static
         * @param {msgProto.BossHurt} message BossHurt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossHurt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bossId = 0;
                object.hurtDic = "";
                object.isEnd = 0;
                object.mData = "";
                object.hurtArr = "";
            }
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            if (message.hurtDic != null && message.hasOwnProperty("hurtDic"))
                object.hurtDic = message.hurtDic;
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                object.isEnd = message.isEnd;
            if (message.mData != null && message.hasOwnProperty("mData"))
                object.mData = message.mData;
            if (message.hurtArr != null && message.hasOwnProperty("hurtArr"))
                object.hurtArr = message.hurtArr;
            return object;
        };

        /**
         * Converts this BossHurt to JSON.
         * @function toJSON
         * @memberof msgProto.BossHurt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossHurt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossHurt;
    })();

    msgProto.BossExitFight = (function() {

        /**
         * Properties of a BossExitFight.
         * @memberof msgProto
         * @interface IBossExitFight
         * @property {number|null} [bossId] BossExitFight bossId
         */

        /**
         * Constructs a new BossExitFight.
         * @memberof msgProto
         * @classdesc Represents a BossExitFight.
         * @implements IBossExitFight
         * @constructor
         * @param {msgProto.IBossExitFight=} [properties] Properties to set
         */
        function BossExitFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossExitFight bossId.
         * @member {number} bossId
         * @memberof msgProto.BossExitFight
         * @instance
         */
        BossExitFight.prototype.bossId = 0;

        /**
         * Encodes the specified BossExitFight message. Does not implicitly {@link msgProto.BossExitFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossExitFight
         * @static
         * @param {msgProto.IBossExitFight} message BossExitFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossExitFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossExitFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossExitFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossExitFight} BossExitFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossExitFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossExitFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossExitFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossExitFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossExitFight} BossExitFight
         */
        BossExitFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossExitFight)
                return object;
            var message = new $root.msgProto.BossExitFight();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossExitFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossExitFight
         * @static
         * @param {msgProto.BossExitFight} message BossExitFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossExitFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossExitFight to JSON.
         * @function toJSON
         * @memberof msgProto.BossExitFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossExitFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossExitFight;
    })();

    msgProto.BossClearFightCd = (function() {

        /**
         * Properties of a BossClearFightCd.
         * @memberof msgProto
         * @interface IBossClearFightCd
         */

        /**
         * Constructs a new BossClearFightCd.
         * @memberof msgProto
         * @classdesc Represents a BossClearFightCd.
         * @implements IBossClearFightCd
         * @constructor
         * @param {msgProto.IBossClearFightCd=} [properties] Properties to set
         */
        function BossClearFightCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified BossClearFightCd message. Does not implicitly {@link msgProto.BossClearFightCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {msgProto.IBossClearFightCd} message BossClearFightCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossClearFightCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a BossClearFightCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossClearFightCd} BossClearFightCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossClearFightCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossClearFightCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossClearFightCd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossClearFightCd} BossClearFightCd
         */
        BossClearFightCd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossClearFightCd)
                return object;
            return new $root.msgProto.BossClearFightCd();
        };

        /**
         * Creates a plain object from a BossClearFightCd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {msgProto.BossClearFightCd} message BossClearFightCd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossClearFightCd.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BossClearFightCd to JSON.
         * @function toJSON
         * @memberof msgProto.BossClearFightCd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossClearFightCd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossClearFightCd;
    })();

    msgProto.BossInspire = (function() {

        /**
         * Properties of a BossInspire.
         * @memberof msgProto
         * @interface IBossInspire
         * @property {number|null} [bossId] BossInspire bossId
         */

        /**
         * Constructs a new BossInspire.
         * @memberof msgProto
         * @classdesc Represents a BossInspire.
         * @implements IBossInspire
         * @constructor
         * @param {msgProto.IBossInspire=} [properties] Properties to set
         */
        function BossInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossInspire bossId.
         * @member {number} bossId
         * @memberof msgProto.BossInspire
         * @instance
         */
        BossInspire.prototype.bossId = 0;

        /**
         * Encodes the specified BossInspire message. Does not implicitly {@link msgProto.BossInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossInspire
         * @static
         * @param {msgProto.IBossInspire} message BossInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossInspire} BossInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossInspire message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossInspire
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossInspire} BossInspire
         */
        BossInspire.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossInspire)
                return object;
            var message = new $root.msgProto.BossInspire();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossInspire message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossInspire
         * @static
         * @param {msgProto.BossInspire} message BossInspire
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossInspire.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossInspire to JSON.
         * @function toJSON
         * @memberof msgProto.BossInspire
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossInspire.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossInspire;
    })();

    msgProto.BossGetInspireRecordArr = (function() {

        /**
         * Properties of a BossGetInspireRecordArr.
         * @memberof msgProto
         * @interface IBossGetInspireRecordArr
         * @property {number|null} [bossId] BossGetInspireRecordArr bossId
         */

        /**
         * Constructs a new BossGetInspireRecordArr.
         * @memberof msgProto
         * @classdesc Represents a BossGetInspireRecordArr.
         * @implements IBossGetInspireRecordArr
         * @constructor
         * @param {msgProto.IBossGetInspireRecordArr=} [properties] Properties to set
         */
        function BossGetInspireRecordArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetInspireRecordArr bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetInspireRecordArr
         * @instance
         */
        BossGetInspireRecordArr.prototype.bossId = 0;

        /**
         * Encodes the specified BossGetInspireRecordArr message. Does not implicitly {@link msgProto.BossGetInspireRecordArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {msgProto.IBossGetInspireRecordArr} message BossGetInspireRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetInspireRecordArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossGetInspireRecordArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetInspireRecordArr} BossGetInspireRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetInspireRecordArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetInspireRecordArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetInspireRecordArr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetInspireRecordArr} BossGetInspireRecordArr
         */
        BossGetInspireRecordArr.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetInspireRecordArr)
                return object;
            var message = new $root.msgProto.BossGetInspireRecordArr();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossGetInspireRecordArr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {msgProto.BossGetInspireRecordArr} message BossGetInspireRecordArr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetInspireRecordArr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossGetInspireRecordArr to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetInspireRecordArr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetInspireRecordArr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetInspireRecordArr;
    })();

    msgProto.BossSyncInspire = (function() {

        /**
         * Properties of a BossSyncInspire.
         * @memberof msgProto
         * @interface IBossSyncInspire
         * @property {number|null} [bossId] BossSyncInspire bossId
         */

        /**
         * Constructs a new BossSyncInspire.
         * @memberof msgProto
         * @classdesc Represents a BossSyncInspire.
         * @implements IBossSyncInspire
         * @constructor
         * @param {msgProto.IBossSyncInspire=} [properties] Properties to set
         */
        function BossSyncInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossSyncInspire bossId.
         * @member {number} bossId
         * @memberof msgProto.BossSyncInspire
         * @instance
         */
        BossSyncInspire.prototype.bossId = 0;

        /**
         * Encodes the specified BossSyncInspire message. Does not implicitly {@link msgProto.BossSyncInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {msgProto.IBossSyncInspire} message BossSyncInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossSyncInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossSyncInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossSyncInspire} BossSyncInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossSyncInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossSyncInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossSyncInspire message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossSyncInspire} BossSyncInspire
         */
        BossSyncInspire.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossSyncInspire)
                return object;
            var message = new $root.msgProto.BossSyncInspire();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossSyncInspire message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {msgProto.BossSyncInspire} message BossSyncInspire
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossSyncInspire.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossSyncInspire to JSON.
         * @function toJSON
         * @memberof msgProto.BossSyncInspire
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossSyncInspire.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossSyncInspire;
    })();

    msgProto.BossGetHurtRankList = (function() {

        /**
         * Properties of a BossGetHurtRankList.
         * @memberof msgProto
         * @interface IBossGetHurtRankList
         * @property {number|null} [bossId] BossGetHurtRankList bossId
         */

        /**
         * Constructs a new BossGetHurtRankList.
         * @memberof msgProto
         * @classdesc Represents a BossGetHurtRankList.
         * @implements IBossGetHurtRankList
         * @constructor
         * @param {msgProto.IBossGetHurtRankList=} [properties] Properties to set
         */
        function BossGetHurtRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetHurtRankList bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetHurtRankList
         * @instance
         */
        BossGetHurtRankList.prototype.bossId = 0;

        /**
         * Encodes the specified BossGetHurtRankList message. Does not implicitly {@link msgProto.BossGetHurtRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {msgProto.IBossGetHurtRankList} message BossGetHurtRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetHurtRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossGetHurtRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetHurtRankList} BossGetHurtRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetHurtRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetHurtRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetHurtRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetHurtRankList} BossGetHurtRankList
         */
        BossGetHurtRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetHurtRankList)
                return object;
            var message = new $root.msgProto.BossGetHurtRankList();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossGetHurtRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {msgProto.BossGetHurtRankList} message BossGetHurtRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetHurtRankList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossGetHurtRankList to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetHurtRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetHurtRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetHurtRankList;
    })();

    msgProto.BossGetFirstHurtRank = (function() {

        /**
         * Properties of a BossGetFirstHurtRank.
         * @memberof msgProto
         * @interface IBossGetFirstHurtRank
         * @property {number|null} [bossId] BossGetFirstHurtRank bossId
         */

        /**
         * Constructs a new BossGetFirstHurtRank.
         * @memberof msgProto
         * @classdesc Represents a BossGetFirstHurtRank.
         * @implements IBossGetFirstHurtRank
         * @constructor
         * @param {msgProto.IBossGetFirstHurtRank=} [properties] Properties to set
         */
        function BossGetFirstHurtRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetFirstHurtRank bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetFirstHurtRank
         * @instance
         */
        BossGetFirstHurtRank.prototype.bossId = 0;

        /**
         * Encodes the specified BossGetFirstHurtRank message. Does not implicitly {@link msgProto.BossGetFirstHurtRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {msgProto.IBossGetFirstHurtRank} message BossGetFirstHurtRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetFirstHurtRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a BossGetFirstHurtRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetFirstHurtRank} BossGetFirstHurtRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetFirstHurtRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetFirstHurtRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetFirstHurtRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetFirstHurtRank} BossGetFirstHurtRank
         */
        BossGetFirstHurtRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetFirstHurtRank)
                return object;
            var message = new $root.msgProto.BossGetFirstHurtRank();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossGetFirstHurtRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {msgProto.BossGetFirstHurtRank} message BossGetFirstHurtRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetFirstHurtRank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this BossGetFirstHurtRank to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetFirstHurtRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetFirstHurtRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetFirstHurtRank;
    })();

    msgProto.BossGetBossResult = (function() {

        /**
         * Properties of a BossGetBossResult.
         * @memberof msgProto
         * @interface IBossGetBossResult
         * @property {number|null} [bossId] BossGetBossResult bossId
         * @property {number|null} [originBossId] BossGetBossResult originBossId
         */

        /**
         * Constructs a new BossGetBossResult.
         * @memberof msgProto
         * @classdesc Represents a BossGetBossResult.
         * @implements IBossGetBossResult
         * @constructor
         * @param {msgProto.IBossGetBossResult=} [properties] Properties to set
         */
        function BossGetBossResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetBossResult bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetBossResult
         * @instance
         */
        BossGetBossResult.prototype.bossId = 0;

        /**
         * BossGetBossResult originBossId.
         * @member {number} originBossId
         * @memberof msgProto.BossGetBossResult
         * @instance
         */
        BossGetBossResult.prototype.originBossId = 0;

        /**
         * Encodes the specified BossGetBossResult message. Does not implicitly {@link msgProto.BossGetBossResult.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {msgProto.IBossGetBossResult} message BossGetBossResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetBossResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.originBossId);
            return writer;
        };

        /**
         * Decodes a BossGetBossResult message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetBossResult} BossGetBossResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetBossResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetBossResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.originBossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetBossResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetBossResult} BossGetBossResult
         */
        BossGetBossResult.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetBossResult)
                return object;
            var message = new $root.msgProto.BossGetBossResult();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            if (object.originBossId != null)
                message.originBossId = object.originBossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossGetBossResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {msgProto.BossGetBossResult} message BossGetBossResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetBossResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bossId = 0;
                object.originBossId = 0;
            }
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                object.originBossId = message.originBossId;
            return object;
        };

        /**
         * Converts this BossGetBossResult to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetBossResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetBossResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetBossResult;
    })();

    msgProto.BossGetResultData = (function() {

        /**
         * Properties of a BossGetResultData.
         * @memberof msgProto
         * @interface IBossGetResultData
         * @property {number|null} [originBossId] BossGetResultData originBossId
         */

        /**
         * Constructs a new BossGetResultData.
         * @memberof msgProto
         * @classdesc Represents a BossGetResultData.
         * @implements IBossGetResultData
         * @constructor
         * @param {msgProto.IBossGetResultData=} [properties] Properties to set
         */
        function BossGetResultData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetResultData originBossId.
         * @member {number} originBossId
         * @memberof msgProto.BossGetResultData
         * @instance
         */
        BossGetResultData.prototype.originBossId = 0;

        /**
         * Encodes the specified BossGetResultData message. Does not implicitly {@link msgProto.BossGetResultData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {msgProto.IBossGetResultData} message BossGetResultData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetResultData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.originBossId);
            return writer;
        };

        /**
         * Decodes a BossGetResultData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetResultData} BossGetResultData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetResultData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetResultData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.originBossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a BossGetResultData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.BossGetResultData} BossGetResultData
         */
        BossGetResultData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.BossGetResultData)
                return object;
            var message = new $root.msgProto.BossGetResultData();
            if (object.originBossId != null)
                message.originBossId = object.originBossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a BossGetResultData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {msgProto.BossGetResultData} message BossGetResultData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BossGetResultData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.originBossId = 0;
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                object.originBossId = message.originBossId;
            return object;
        };

        /**
         * Converts this BossGetResultData to JSON.
         * @function toJSON
         * @memberof msgProto.BossGetResultData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BossGetResultData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BossGetResultData;
    })();

    msgProto.DemonLotusGetInfo = (function() {

        /**
         * Properties of a DemonLotusGetInfo.
         * @memberof msgProto
         * @interface IDemonLotusGetInfo
         */

        /**
         * Constructs a new DemonLotusGetInfo.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusGetInfo.
         * @implements IDemonLotusGetInfo
         * @constructor
         * @param {msgProto.IDemonLotusGetInfo=} [properties] Properties to set
         */
        function DemonLotusGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusGetInfo message. Does not implicitly {@link msgProto.DemonLotusGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {msgProto.IDemonLotusGetInfo} message DemonLotusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusGetInfo} DemonLotusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusGetInfo} DemonLotusGetInfo
         */
        DemonLotusGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusGetInfo)
                return object;
            return new $root.msgProto.DemonLotusGetInfo();
        };

        /**
         * Creates a plain object from a DemonLotusGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {msgProto.DemonLotusGetInfo} message DemonLotusGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusGetInfo;
    })();

    msgProto.DemonLotusUpLotus = (function() {

        /**
         * Properties of a DemonLotusUpLotus.
         * @memberof msgProto
         * @interface IDemonLotusUpLotus
         */

        /**
         * Constructs a new DemonLotusUpLotus.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusUpLotus.
         * @implements IDemonLotusUpLotus
         * @constructor
         * @param {msgProto.IDemonLotusUpLotus=} [properties] Properties to set
         */
        function DemonLotusUpLotus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusUpLotus message. Does not implicitly {@link msgProto.DemonLotusUpLotus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {msgProto.IDemonLotusUpLotus} message DemonLotusUpLotus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusUpLotus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusUpLotus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusUpLotus} DemonLotusUpLotus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusUpLotus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusUpLotus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusUpLotus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusUpLotus} DemonLotusUpLotus
         */
        DemonLotusUpLotus.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusUpLotus)
                return object;
            return new $root.msgProto.DemonLotusUpLotus();
        };

        /**
         * Creates a plain object from a DemonLotusUpLotus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {msgProto.DemonLotusUpLotus} message DemonLotusUpLotus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusUpLotus.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusUpLotus to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusUpLotus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusUpLotus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusUpLotus;
    })();

    msgProto.DemonLotusGetRevenue = (function() {

        /**
         * Properties of a DemonLotusGetRevenue.
         * @memberof msgProto
         * @interface IDemonLotusGetRevenue
         */

        /**
         * Constructs a new DemonLotusGetRevenue.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusGetRevenue.
         * @implements IDemonLotusGetRevenue
         * @constructor
         * @param {msgProto.IDemonLotusGetRevenue=} [properties] Properties to set
         */
        function DemonLotusGetRevenue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusGetRevenue message. Does not implicitly {@link msgProto.DemonLotusGetRevenue.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {msgProto.IDemonLotusGetRevenue} message DemonLotusGetRevenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetRevenue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusGetRevenue message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusGetRevenue} DemonLotusGetRevenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetRevenue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusGetRevenue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusGetRevenue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusGetRevenue} DemonLotusGetRevenue
         */
        DemonLotusGetRevenue.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusGetRevenue)
                return object;
            return new $root.msgProto.DemonLotusGetRevenue();
        };

        /**
         * Creates a plain object from a DemonLotusGetRevenue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {msgProto.DemonLotusGetRevenue} message DemonLotusGetRevenue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusGetRevenue.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusGetRevenue to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusGetRevenue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusGetRevenue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusGetRevenue;
    })();

    msgProto.DemonLotusOpening = (function() {

        /**
         * Properties of a DemonLotusOpening.
         * @memberof msgProto
         * @interface IDemonLotusOpening
         */

        /**
         * Constructs a new DemonLotusOpening.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusOpening.
         * @implements IDemonLotusOpening
         * @constructor
         * @param {msgProto.IDemonLotusOpening=} [properties] Properties to set
         */
        function DemonLotusOpening(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusOpening message. Does not implicitly {@link msgProto.DemonLotusOpening.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {msgProto.IDemonLotusOpening} message DemonLotusOpening message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusOpening.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusOpening message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusOpening} DemonLotusOpening
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusOpening.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusOpening();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusOpening message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusOpening} DemonLotusOpening
         */
        DemonLotusOpening.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusOpening)
                return object;
            return new $root.msgProto.DemonLotusOpening();
        };

        /**
         * Creates a plain object from a DemonLotusOpening message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {msgProto.DemonLotusOpening} message DemonLotusOpening
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusOpening.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusOpening to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusOpening
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusOpening.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusOpening;
    })();

    msgProto.DemonLotusLotusAdvance = (function() {

        /**
         * Properties of a DemonLotusLotusAdvance.
         * @memberof msgProto
         * @interface IDemonLotusLotusAdvance
         */

        /**
         * Constructs a new DemonLotusLotusAdvance.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusLotusAdvance.
         * @implements IDemonLotusLotusAdvance
         * @constructor
         * @param {msgProto.IDemonLotusLotusAdvance=} [properties] Properties to set
         */
        function DemonLotusLotusAdvance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusLotusAdvance message. Does not implicitly {@link msgProto.DemonLotusLotusAdvance.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {msgProto.IDemonLotusLotusAdvance} message DemonLotusLotusAdvance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusLotusAdvance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusLotusAdvance message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusLotusAdvance} DemonLotusLotusAdvance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusLotusAdvance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusLotusAdvance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusLotusAdvance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusLotusAdvance} DemonLotusLotusAdvance
         */
        DemonLotusLotusAdvance.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusLotusAdvance)
                return object;
            return new $root.msgProto.DemonLotusLotusAdvance();
        };

        /**
         * Creates a plain object from a DemonLotusLotusAdvance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {msgProto.DemonLotusLotusAdvance} message DemonLotusLotusAdvance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusLotusAdvance.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusLotusAdvance to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusLotusAdvance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusLotusAdvance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusLotusAdvance;
    })();

    msgProto.DemonLotusTreasureTrain = (function() {

        /**
         * Properties of a DemonLotusTreasureTrain.
         * @memberof msgProto
         * @interface IDemonLotusTreasureTrain
         */

        /**
         * Constructs a new DemonLotusTreasureTrain.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusTreasureTrain.
         * @implements IDemonLotusTreasureTrain
         * @constructor
         * @param {msgProto.IDemonLotusTreasureTrain=} [properties] Properties to set
         */
        function DemonLotusTreasureTrain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified DemonLotusTreasureTrain message. Does not implicitly {@link msgProto.DemonLotusTreasureTrain.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {msgProto.IDemonLotusTreasureTrain} message DemonLotusTreasureTrain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusTreasureTrain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a DemonLotusTreasureTrain message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusTreasureTrain} DemonLotusTreasureTrain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusTreasureTrain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusTreasureTrain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a DemonLotusTreasureTrain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.DemonLotusTreasureTrain} DemonLotusTreasureTrain
         */
        DemonLotusTreasureTrain.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.DemonLotusTreasureTrain)
                return object;
            return new $root.msgProto.DemonLotusTreasureTrain();
        };

        /**
         * Creates a plain object from a DemonLotusTreasureTrain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {msgProto.DemonLotusTreasureTrain} message DemonLotusTreasureTrain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemonLotusTreasureTrain.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemonLotusTreasureTrain to JSON.
         * @function toJSON
         * @memberof msgProto.DemonLotusTreasureTrain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemonLotusTreasureTrain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemonLotusTreasureTrain;
    })();

    msgProto.MailGetList = (function() {

        /**
         * Properties of a MailGetList.
         * @memberof msgProto
         * @interface IMailGetList
         */

        /**
         * Constructs a new MailGetList.
         * @memberof msgProto
         * @classdesc Represents a MailGetList.
         * @implements IMailGetList
         * @constructor
         * @param {msgProto.IMailGetList=} [properties] Properties to set
         */
        function MailGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MailGetList message. Does not implicitly {@link msgProto.MailGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailGetList
         * @static
         * @param {msgProto.IMailGetList} message MailGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a MailGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailGetList} MailGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a MailGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.MailGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.MailGetList} MailGetList
         */
        MailGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.MailGetList)
                return object;
            return new $root.msgProto.MailGetList();
        };

        /**
         * Creates a plain object from a MailGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.MailGetList
         * @static
         * @param {msgProto.MailGetList} message MailGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailGetList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MailGetList to JSON.
         * @function toJSON
         * @memberof msgProto.MailGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailGetList;
    })();

    msgProto.mailPickItems = (function() {

        /**
         * Properties of a mailPickItems.
         * @memberof msgProto
         * @interface ImailPickItems
         * @property {number|null} [mailId] mailPickItems mailId
         */

        /**
         * Constructs a new mailPickItems.
         * @memberof msgProto
         * @classdesc Represents a mailPickItems.
         * @implements ImailPickItems
         * @constructor
         * @param {msgProto.ImailPickItems=} [properties] Properties to set
         */
        function mailPickItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * mailPickItems mailId.
         * @member {number} mailId
         * @memberof msgProto.mailPickItems
         * @instance
         */
        mailPickItems.prototype.mailId = 0;

        /**
         * Encodes the specified mailPickItems message. Does not implicitly {@link msgProto.mailPickItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.mailPickItems
         * @static
         * @param {msgProto.ImailPickItems} message mailPickItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        mailPickItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Decodes a mailPickItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.mailPickItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.mailPickItems} mailPickItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        mailPickItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.mailPickItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a mailPickItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.mailPickItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.mailPickItems} mailPickItems
         */
        mailPickItems.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.mailPickItems)
                return object;
            var message = new $root.msgProto.mailPickItems();
            if (object.mailId != null)
                message.mailId = object.mailId | 0;
            return message;
        };

        /**
         * Creates a plain object from a mailPickItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.mailPickItems
         * @static
         * @param {msgProto.mailPickItems} message mailPickItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        mailPickItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailId = 0;
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                object.mailId = message.mailId;
            return object;
        };

        /**
         * Converts this mailPickItems to JSON.
         * @function toJSON
         * @memberof msgProto.mailPickItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        mailPickItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return mailPickItems;
    })();

    msgProto.MailPickAllItems = (function() {

        /**
         * Properties of a MailPickAllItems.
         * @memberof msgProto
         * @interface IMailPickAllItems
         */

        /**
         * Constructs a new MailPickAllItems.
         * @memberof msgProto
         * @classdesc Represents a MailPickAllItems.
         * @implements IMailPickAllItems
         * @constructor
         * @param {msgProto.IMailPickAllItems=} [properties] Properties to set
         */
        function MailPickAllItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified MailPickAllItems message. Does not implicitly {@link msgProto.MailPickAllItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {msgProto.IMailPickAllItems} message MailPickAllItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailPickAllItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a MailPickAllItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailPickAllItems} MailPickAllItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailPickAllItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailPickAllItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a MailPickAllItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.MailPickAllItems} MailPickAllItems
         */
        MailPickAllItems.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.MailPickAllItems)
                return object;
            return new $root.msgProto.MailPickAllItems();
        };

        /**
         * Creates a plain object from a MailPickAllItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {msgProto.MailPickAllItems} message MailPickAllItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailPickAllItems.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MailPickAllItems to JSON.
         * @function toJSON
         * @memberof msgProto.MailPickAllItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailPickAllItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailPickAllItems;
    })();

    msgProto.MailSetRead = (function() {

        /**
         * Properties of a MailSetRead.
         * @memberof msgProto
         * @interface IMailSetRead
         * @property {number|null} [mailId] MailSetRead mailId
         */

        /**
         * Constructs a new MailSetRead.
         * @memberof msgProto
         * @classdesc Represents a MailSetRead.
         * @implements IMailSetRead
         * @constructor
         * @param {msgProto.IMailSetRead=} [properties] Properties to set
         */
        function MailSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailSetRead mailId.
         * @member {number} mailId
         * @memberof msgProto.MailSetRead
         * @instance
         */
        MailSetRead.prototype.mailId = 0;

        /**
         * Encodes the specified MailSetRead message. Does not implicitly {@link msgProto.MailSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailSetRead
         * @static
         * @param {msgProto.IMailSetRead} message MailSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Decodes a MailSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailSetRead} MailSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a MailSetRead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.MailSetRead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.MailSetRead} MailSetRead
         */
        MailSetRead.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.MailSetRead)
                return object;
            var message = new $root.msgProto.MailSetRead();
            if (object.mailId != null)
                message.mailId = object.mailId | 0;
            return message;
        };

        /**
         * Creates a plain object from a MailSetRead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.MailSetRead
         * @static
         * @param {msgProto.MailSetRead} message MailSetRead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailSetRead.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailId = 0;
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                object.mailId = message.mailId;
            return object;
        };

        /**
         * Converts this MailSetRead to JSON.
         * @function toJSON
         * @memberof msgProto.MailSetRead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailSetRead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailSetRead;
    })();

    msgProto.MailGetIsNeedOperate = (function() {

        /**
         * Properties of a MailGetIsNeedOperate.
         * @memberof msgProto
         * @interface IMailGetIsNeedOperate
         * @property {number|null} [mailId] MailGetIsNeedOperate mailId
         */

        /**
         * Constructs a new MailGetIsNeedOperate.
         * @memberof msgProto
         * @classdesc Represents a MailGetIsNeedOperate.
         * @implements IMailGetIsNeedOperate
         * @constructor
         * @param {msgProto.IMailGetIsNeedOperate=} [properties] Properties to set
         */
        function MailGetIsNeedOperate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailGetIsNeedOperate mailId.
         * @member {number} mailId
         * @memberof msgProto.MailGetIsNeedOperate
         * @instance
         */
        MailGetIsNeedOperate.prototype.mailId = 0;

        /**
         * Encodes the specified MailGetIsNeedOperate message. Does not implicitly {@link msgProto.MailGetIsNeedOperate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {msgProto.IMailGetIsNeedOperate} message MailGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetIsNeedOperate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Decodes a MailGetIsNeedOperate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailGetIsNeedOperate} MailGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetIsNeedOperate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailGetIsNeedOperate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a MailGetIsNeedOperate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.MailGetIsNeedOperate} MailGetIsNeedOperate
         */
        MailGetIsNeedOperate.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.MailGetIsNeedOperate)
                return object;
            var message = new $root.msgProto.MailGetIsNeedOperate();
            if (object.mailId != null)
                message.mailId = object.mailId | 0;
            return message;
        };

        /**
         * Creates a plain object from a MailGetIsNeedOperate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {msgProto.MailGetIsNeedOperate} message MailGetIsNeedOperate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailGetIsNeedOperate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mailId = 0;
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                object.mailId = message.mailId;
            return object;
        };

        /**
         * Converts this MailGetIsNeedOperate to JSON.
         * @function toJSON
         * @memberof msgProto.MailGetIsNeedOperate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailGetIsNeedOperate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MailGetIsNeedOperate;
    })();

    msgProto.EventEventBuy = (function() {

        /**
         * Properties of an EventEventBuy.
         * @memberof msgProto
         * @interface IEventEventBuy
         * @property {number|null} [eventId] EventEventBuy eventId
         */

        /**
         * Constructs a new EventEventBuy.
         * @memberof msgProto
         * @classdesc Represents an EventEventBuy.
         * @implements IEventEventBuy
         * @constructor
         * @param {msgProto.IEventEventBuy=} [properties] Properties to set
         */
        function EventEventBuy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventEventBuy eventId.
         * @member {number} eventId
         * @memberof msgProto.EventEventBuy
         * @instance
         */
        EventEventBuy.prototype.eventId = 0;

        /**
         * Encodes the specified EventEventBuy message. Does not implicitly {@link msgProto.EventEventBuy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {msgProto.IEventEventBuy} message EventEventBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventEventBuy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventId);
            return writer;
        };

        /**
         * Decodes an EventEventBuy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EventEventBuy} EventEventBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventEventBuy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EventEventBuy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EventEventBuy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EventEventBuy} EventEventBuy
         */
        EventEventBuy.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EventEventBuy)
                return object;
            var message = new $root.msgProto.EventEventBuy();
            if (object.eventId != null)
                message.eventId = object.eventId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EventEventBuy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {msgProto.EventEventBuy} message EventEventBuy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventEventBuy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eventId = 0;
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                object.eventId = message.eventId;
            return object;
        };

        /**
         * Converts this EventEventBuy to JSON.
         * @function toJSON
         * @memberof msgProto.EventEventBuy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventEventBuy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventEventBuy;
    })();

    msgProto.EquipChangeEquip = (function() {

        /**
         * Properties of an EquipChangeEquip.
         * @memberof msgProto
         * @interface IEquipChangeEquip
         * @property {number|null} [tempId] EquipChangeEquip tempId
         * @property {number|null} [index] EquipChangeEquip index
         * @property {number|null} [equipId] EquipChangeEquip equipId
         */

        /**
         * Constructs a new EquipChangeEquip.
         * @memberof msgProto
         * @classdesc Represents an EquipChangeEquip.
         * @implements IEquipChangeEquip
         * @constructor
         * @param {msgProto.IEquipChangeEquip=} [properties] Properties to set
         */
        function EquipChangeEquip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipChangeEquip tempId.
         * @member {number} tempId
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.tempId = 0;

        /**
         * EquipChangeEquip index.
         * @member {number} index
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.index = 0;

        /**
         * EquipChangeEquip equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.equipId = 0;

        /**
         * Encodes the specified EquipChangeEquip message. Does not implicitly {@link msgProto.EquipChangeEquip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {msgProto.IEquipChangeEquip} message EquipChangeEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipChangeEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equipId);
            return writer;
        };

        /**
         * Decodes an EquipChangeEquip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipChangeEquip} EquipChangeEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipChangeEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipChangeEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.equipId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipChangeEquip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipChangeEquip} EquipChangeEquip
         */
        EquipChangeEquip.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipChangeEquip)
                return object;
            var message = new $root.msgProto.EquipChangeEquip();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            if (object.equipId != null)
                message.equipId = object.equipId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EquipChangeEquip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {msgProto.EquipChangeEquip} message EquipChangeEquip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipChangeEquip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
                object.equipId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                object.equipId = message.equipId;
            return object;
        };

        /**
         * Converts this EquipChangeEquip to JSON.
         * @function toJSON
         * @memberof msgProto.EquipChangeEquip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipChangeEquip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipChangeEquip;
    })();

    msgProto.EquipInheritedEquip = (function() {

        /**
         * Properties of an EquipInheritedEquip.
         * @memberof msgProto
         * @interface IEquipInheritedEquip
         * @property {number|null} [equipId] EquipInheritedEquip equipId
         * @property {number|null} [tempId] EquipInheritedEquip tempId
         */

        /**
         * Constructs a new EquipInheritedEquip.
         * @memberof msgProto
         * @classdesc Represents an EquipInheritedEquip.
         * @implements IEquipInheritedEquip
         * @constructor
         * @param {msgProto.IEquipInheritedEquip=} [properties] Properties to set
         */
        function EquipInheritedEquip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipInheritedEquip equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipInheritedEquip
         * @instance
         */
        EquipInheritedEquip.prototype.equipId = 0;

        /**
         * EquipInheritedEquip tempId.
         * @member {number} tempId
         * @memberof msgProto.EquipInheritedEquip
         * @instance
         */
        EquipInheritedEquip.prototype.tempId = 0;

        /**
         * Encodes the specified EquipInheritedEquip message. Does not implicitly {@link msgProto.EquipInheritedEquip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {msgProto.IEquipInheritedEquip} message EquipInheritedEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipInheritedEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes an EquipInheritedEquip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipInheritedEquip} EquipInheritedEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipInheritedEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipInheritedEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                case 2:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipInheritedEquip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipInheritedEquip} EquipInheritedEquip
         */
        EquipInheritedEquip.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipInheritedEquip)
                return object;
            var message = new $root.msgProto.EquipInheritedEquip();
            if (object.equipId != null)
                message.equipId = object.equipId | 0;
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EquipInheritedEquip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {msgProto.EquipInheritedEquip} message EquipInheritedEquip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipInheritedEquip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.equipId = 0;
                object.tempId = 0;
            }
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                object.equipId = message.equipId;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this EquipInheritedEquip to JSON.
         * @function toJSON
         * @memberof msgProto.EquipInheritedEquip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipInheritedEquip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipInheritedEquip;
    })();

    msgProto.EquipCustomization = (function() {

        /**
         * Properties of an EquipCustomization.
         * @memberof msgProto
         * @interface IEquipCustomization
         * @property {number|null} [certificate] EquipCustomization certificate
         * @property {number|null} [job] EquipCustomization job
         * @property {string|null} [name] EquipCustomization name
         * @property {number|null} [lvl] EquipCustomization lvl
         * @property {string|null} [abilityIndex] EquipCustomization abilityIndex
         * @property {number|null} [equipType] EquipCustomization equipType
         */

        /**
         * Constructs a new EquipCustomization.
         * @memberof msgProto
         * @classdesc Represents an EquipCustomization.
         * @implements IEquipCustomization
         * @constructor
         * @param {msgProto.IEquipCustomization=} [properties] Properties to set
         */
        function EquipCustomization(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipCustomization certificate.
         * @member {number} certificate
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.certificate = 0;

        /**
         * EquipCustomization job.
         * @member {number} job
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.job = 0;

        /**
         * EquipCustomization name.
         * @member {string} name
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.name = "";

        /**
         * EquipCustomization lvl.
         * @member {number} lvl
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.lvl = 0;

        /**
         * EquipCustomization abilityIndex.
         * @member {string} abilityIndex
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.abilityIndex = "";

        /**
         * EquipCustomization equipType.
         * @member {number} equipType
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.equipType = 0;

        /**
         * Encodes the specified EquipCustomization message. Does not implicitly {@link msgProto.EquipCustomization.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {msgProto.IEquipCustomization} message EquipCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipCustomization.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.certificate);
            if (message.job != null && message.hasOwnProperty("job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lvl);
            if (message.abilityIndex != null && message.hasOwnProperty("abilityIndex"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.abilityIndex);
            if (message.equipType != null && message.hasOwnProperty("equipType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.equipType);
            return writer;
        };

        /**
         * Decodes an EquipCustomization message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipCustomization} EquipCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipCustomization.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipCustomization();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.int32();
                    break;
                case 2:
                    message.job = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.lvl = reader.int32();
                    break;
                case 5:
                    message.abilityIndex = reader.string();
                    break;
                case 6:
                    message.equipType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipCustomization message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipCustomization} EquipCustomization
         */
        EquipCustomization.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipCustomization)
                return object;
            var message = new $root.msgProto.EquipCustomization();
            if (object.certificate != null)
                message.certificate = object.certificate | 0;
            if (object.job != null)
                message.job = object.job | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.lvl != null)
                message.lvl = object.lvl | 0;
            if (object.abilityIndex != null)
                message.abilityIndex = String(object.abilityIndex);
            if (object.equipType != null)
                message.equipType = object.equipType | 0;
            return message;
        };

        /**
         * Creates a plain object from an EquipCustomization message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {msgProto.EquipCustomization} message EquipCustomization
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipCustomization.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.certificate = 0;
                object.job = 0;
                object.name = "";
                object.lvl = 0;
                object.abilityIndex = "";
                object.equipType = 0;
            }
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = message.certificate;
            if (message.job != null && message.hasOwnProperty("job"))
                object.job = message.job;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                object.lvl = message.lvl;
            if (message.abilityIndex != null && message.hasOwnProperty("abilityIndex"))
                object.abilityIndex = message.abilityIndex;
            if (message.equipType != null && message.hasOwnProperty("equipType"))
                object.equipType = message.equipType;
            return object;
        };

        /**
         * Converts this EquipCustomization to JSON.
         * @function toJSON
         * @memberof msgProto.EquipCustomization
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipCustomization.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipCustomization;
    })();

    msgProto.EquipUpCustomization = (function() {

        /**
         * Properties of an EquipUpCustomization.
         * @memberof msgProto
         * @interface IEquipUpCustomization
         * @property {number|null} [equipId] EquipUpCustomization equipId
         */

        /**
         * Constructs a new EquipUpCustomization.
         * @memberof msgProto
         * @classdesc Represents an EquipUpCustomization.
         * @implements IEquipUpCustomization
         * @constructor
         * @param {msgProto.IEquipUpCustomization=} [properties] Properties to set
         */
        function EquipUpCustomization(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipUpCustomization equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipUpCustomization
         * @instance
         */
        EquipUpCustomization.prototype.equipId = 0;

        /**
         * Encodes the specified EquipUpCustomization message. Does not implicitly {@link msgProto.EquipUpCustomization.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {msgProto.IEquipUpCustomization} message EquipUpCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpCustomization.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            return writer;
        };

        /**
         * Decodes an EquipUpCustomization message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipUpCustomization} EquipUpCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpCustomization.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipUpCustomization();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipUpCustomization message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipUpCustomization} EquipUpCustomization
         */
        EquipUpCustomization.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipUpCustomization)
                return object;
            var message = new $root.msgProto.EquipUpCustomization();
            if (object.equipId != null)
                message.equipId = object.equipId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EquipUpCustomization message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {msgProto.EquipUpCustomization} message EquipUpCustomization
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipUpCustomization.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.equipId = 0;
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                object.equipId = message.equipId;
            return object;
        };

        /**
         * Converts this EquipUpCustomization to JSON.
         * @function toJSON
         * @memberof msgProto.EquipUpCustomization
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipUpCustomization.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipUpCustomization;
    })();

    msgProto.EquipUpdateEquipItemLockStatus = (function() {

        /**
         * Properties of an EquipUpdateEquipItemLockStatus.
         * @memberof msgProto
         * @interface IEquipUpdateEquipItemLockStatus
         * @property {number|null} [equipId] EquipUpdateEquipItemLockStatus equipId
         * @property {number|null} [isLocked] EquipUpdateEquipItemLockStatus isLocked
         */

        /**
         * Constructs a new EquipUpdateEquipItemLockStatus.
         * @memberof msgProto
         * @classdesc Represents an EquipUpdateEquipItemLockStatus.
         * @implements IEquipUpdateEquipItemLockStatus
         * @constructor
         * @param {msgProto.IEquipUpdateEquipItemLockStatus=} [properties] Properties to set
         */
        function EquipUpdateEquipItemLockStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipUpdateEquipItemLockStatus equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @instance
         */
        EquipUpdateEquipItemLockStatus.prototype.equipId = 0;

        /**
         * EquipUpdateEquipItemLockStatus isLocked.
         * @member {number} isLocked
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @instance
         */
        EquipUpdateEquipItemLockStatus.prototype.isLocked = 0;

        /**
         * Encodes the specified EquipUpdateEquipItemLockStatus message. Does not implicitly {@link msgProto.EquipUpdateEquipItemLockStatus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {msgProto.IEquipUpdateEquipItemLockStatus} message EquipUpdateEquipItemLockStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpdateEquipItemLockStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isLocked);
            return writer;
        };

        /**
         * Decodes an EquipUpdateEquipItemLockStatus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipUpdateEquipItemLockStatus} EquipUpdateEquipItemLockStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpdateEquipItemLockStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipUpdateEquipItemLockStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                case 2:
                    message.isLocked = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipUpdateEquipItemLockStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipUpdateEquipItemLockStatus} EquipUpdateEquipItemLockStatus
         */
        EquipUpdateEquipItemLockStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipUpdateEquipItemLockStatus)
                return object;
            var message = new $root.msgProto.EquipUpdateEquipItemLockStatus();
            if (object.equipId != null)
                message.equipId = object.equipId | 0;
            if (object.isLocked != null)
                message.isLocked = object.isLocked | 0;
            return message;
        };

        /**
         * Creates a plain object from an EquipUpdateEquipItemLockStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {msgProto.EquipUpdateEquipItemLockStatus} message EquipUpdateEquipItemLockStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipUpdateEquipItemLockStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.equipId = 0;
                object.isLocked = 0;
            }
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                object.equipId = message.equipId;
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                object.isLocked = message.isLocked;
            return object;
        };

        /**
         * Converts this EquipUpdateEquipItemLockStatus to JSON.
         * @function toJSON
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipUpdateEquipItemLockStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipUpdateEquipItemLockStatus;
    })();

    msgProto.EquipSellEquipItems = (function() {

        /**
         * Properties of an EquipSellEquipItems.
         * @memberof msgProto
         * @interface IEquipSellEquipItems
         * @property {string|null} [equipIdArr] EquipSellEquipItems equipIdArr
         */

        /**
         * Constructs a new EquipSellEquipItems.
         * @memberof msgProto
         * @classdesc Represents an EquipSellEquipItems.
         * @implements IEquipSellEquipItems
         * @constructor
         * @param {msgProto.IEquipSellEquipItems=} [properties] Properties to set
         */
        function EquipSellEquipItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipSellEquipItems equipIdArr.
         * @member {string} equipIdArr
         * @memberof msgProto.EquipSellEquipItems
         * @instance
         */
        EquipSellEquipItems.prototype.equipIdArr = "";

        /**
         * Encodes the specified EquipSellEquipItems message. Does not implicitly {@link msgProto.EquipSellEquipItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {msgProto.IEquipSellEquipItems} message EquipSellEquipItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipSellEquipItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipIdArr != null && message.hasOwnProperty("equipIdArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.equipIdArr);
            return writer;
        };

        /**
         * Decodes an EquipSellEquipItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipSellEquipItems} EquipSellEquipItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipSellEquipItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipSellEquipItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipIdArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an EquipSellEquipItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.EquipSellEquipItems} EquipSellEquipItems
         */
        EquipSellEquipItems.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.EquipSellEquipItems)
                return object;
            var message = new $root.msgProto.EquipSellEquipItems();
            if (object.equipIdArr != null)
                message.equipIdArr = String(object.equipIdArr);
            return message;
        };

        /**
         * Creates a plain object from an EquipSellEquipItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {msgProto.EquipSellEquipItems} message EquipSellEquipItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipSellEquipItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.equipIdArr = "";
            if (message.equipIdArr != null && message.hasOwnProperty("equipIdArr"))
                object.equipIdArr = message.equipIdArr;
            return object;
        };

        /**
         * Converts this EquipSellEquipItems to JSON.
         * @function toJSON
         * @memberof msgProto.EquipSellEquipItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipSellEquipItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquipSellEquipItems;
    })();

    msgProto.UserGetInfo = (function() {

        /**
         * Properties of a UserGetInfo.
         * @memberof msgProto
         * @interface IUserGetInfo
         */

        /**
         * Constructs a new UserGetInfo.
         * @memberof msgProto
         * @classdesc Represents a UserGetInfo.
         * @implements IUserGetInfo
         * @constructor
         * @param {msgProto.IUserGetInfo=} [properties] Properties to set
         */
        function UserGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetInfo message. Does not implicitly {@link msgProto.UserGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {msgProto.IUserGetInfo} message UserGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetInfo} UserGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetInfo} UserGetInfo
         */
        UserGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetInfo)
                return object;
            return new $root.msgProto.UserGetInfo();
        };

        /**
         * Creates a plain object from a UserGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {msgProto.UserGetInfo} message UserGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetInfo;
    })();

    msgProto.UserChangeName = (function() {

        /**
         * Properties of a UserChangeName.
         * @memberof msgProto
         * @interface IUserChangeName
         * @property {string|null} [name] UserChangeName name
         * @property {number|null} [heroTempId] UserChangeName heroTempId
         */

        /**
         * Constructs a new UserChangeName.
         * @memberof msgProto
         * @classdesc Represents a UserChangeName.
         * @implements IUserChangeName
         * @constructor
         * @param {msgProto.IUserChangeName=} [properties] Properties to set
         */
        function UserChangeName(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserChangeName name.
         * @member {string} name
         * @memberof msgProto.UserChangeName
         * @instance
         */
        UserChangeName.prototype.name = "";

        /**
         * UserChangeName heroTempId.
         * @member {number} heroTempId
         * @memberof msgProto.UserChangeName
         * @instance
         */
        UserChangeName.prototype.heroTempId = 0;

        /**
         * Encodes the specified UserChangeName message. Does not implicitly {@link msgProto.UserChangeName.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserChangeName
         * @static
         * @param {msgProto.IUserChangeName} message UserChangeName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserChangeName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroTempId);
            return writer;
        };

        /**
         * Decodes a UserChangeName message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserChangeName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserChangeName} UserChangeName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserChangeName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserChangeName();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.heroTempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserChangeName message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserChangeName
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserChangeName} UserChangeName
         */
        UserChangeName.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserChangeName)
                return object;
            var message = new $root.msgProto.UserChangeName();
            if (object.name != null)
                message.name = String(object.name);
            if (object.heroTempId != null)
                message.heroTempId = object.heroTempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserChangeName message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserChangeName
         * @static
         * @param {msgProto.UserChangeName} message UserChangeName
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserChangeName.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.heroTempId = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                object.heroTempId = message.heroTempId;
            return object;
        };

        /**
         * Converts this UserChangeName to JSON.
         * @function toJSON
         * @memberof msgProto.UserChangeName
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserChangeName.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserChangeName;
    })();

    msgProto.UserUpLvl = (function() {

        /**
         * Properties of a UserUpLvl.
         * @memberof msgProto
         * @interface IUserUpLvl
         */

        /**
         * Constructs a new UserUpLvl.
         * @memberof msgProto
         * @classdesc Represents a UserUpLvl.
         * @implements IUserUpLvl
         * @constructor
         * @param {msgProto.IUserUpLvl=} [properties] Properties to set
         */
        function UserUpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserUpLvl message. Does not implicitly {@link msgProto.UserUpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {msgProto.IUserUpLvl} message UserUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserUpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpLvl} UserUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserUpLvl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserUpLvl} UserUpLvl
         */
        UserUpLvl.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserUpLvl)
                return object;
            return new $root.msgProto.UserUpLvl();
        };

        /**
         * Creates a plain object from a UserUpLvl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {msgProto.UserUpLvl} message UserUpLvl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUpLvl.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserUpLvl to JSON.
         * @function toJSON
         * @memberof msgProto.UserUpLvl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUpLvl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserUpLvl;
    })();

    msgProto.UserSyncData = (function() {

        /**
         * Properties of a UserSyncData.
         * @memberof msgProto
         * @interface IUserSyncData
         * @property {string|null} [sendData] UserSyncData sendData
         */

        /**
         * Constructs a new UserSyncData.
         * @memberof msgProto
         * @classdesc Represents a UserSyncData.
         * @implements IUserSyncData
         * @constructor
         * @param {msgProto.IUserSyncData=} [properties] Properties to set
         */
        function UserSyncData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSyncData sendData.
         * @member {string} sendData
         * @memberof msgProto.UserSyncData
         * @instance
         */
        UserSyncData.prototype.sendData = "";

        /**
         * Encodes the specified UserSyncData message. Does not implicitly {@link msgProto.UserSyncData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSyncData
         * @static
         * @param {msgProto.IUserSyncData} message UserSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendData != null && message.hasOwnProperty("sendData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sendData);
            return writer;
        };

        /**
         * Decodes a UserSyncData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSyncData} UserSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSyncData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSyncData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSyncData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSyncData} UserSyncData
         */
        UserSyncData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSyncData)
                return object;
            var message = new $root.msgProto.UserSyncData();
            if (object.sendData != null)
                message.sendData = String(object.sendData);
            return message;
        };

        /**
         * Creates a plain object from a UserSyncData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSyncData
         * @static
         * @param {msgProto.UserSyncData} message UserSyncData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSyncData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sendData = "";
            if (message.sendData != null && message.hasOwnProperty("sendData"))
                object.sendData = message.sendData;
            return object;
        };

        /**
         * Converts this UserSyncData to JSON.
         * @function toJSON
         * @memberof msgProto.UserSyncData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSyncData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSyncData;
    })();

    msgProto.UserSyncData2 = (function() {

        /**
         * Properties of a UserSyncData2.
         * @memberof msgProto
         * @interface IUserSyncData2
         */

        /**
         * Constructs a new UserSyncData2.
         * @memberof msgProto
         * @classdesc Represents a UserSyncData2.
         * @implements IUserSyncData2
         * @constructor
         * @param {msgProto.IUserSyncData2=} [properties] Properties to set
         */
        function UserSyncData2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserSyncData2 message. Does not implicitly {@link msgProto.UserSyncData2.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {msgProto.IUserSyncData2} message UserSyncData2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserSyncData2 message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSyncData2} UserSyncData2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSyncData2();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSyncData2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSyncData2} UserSyncData2
         */
        UserSyncData2.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSyncData2)
                return object;
            return new $root.msgProto.UserSyncData2();
        };

        /**
         * Creates a plain object from a UserSyncData2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {msgProto.UserSyncData2} message UserSyncData2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSyncData2.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserSyncData2 to JSON.
         * @function toJSON
         * @memberof msgProto.UserSyncData2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSyncData2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSyncData2;
    })();

    msgProto.UserGetBagChest = (function() {

        /**
         * Properties of a UserGetBagChest.
         * @memberof msgProto
         * @interface IUserGetBagChest
         * @property {number|null} [chestId] UserGetBagChest chestId
         * @property {number|null} [count] UserGetBagChest count
         */

        /**
         * Constructs a new UserGetBagChest.
         * @memberof msgProto
         * @classdesc Represents a UserGetBagChest.
         * @implements IUserGetBagChest
         * @constructor
         * @param {msgProto.IUserGetBagChest=} [properties] Properties to set
         */
        function UserGetBagChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserGetBagChest chestId.
         * @member {number} chestId
         * @memberof msgProto.UserGetBagChest
         * @instance
         */
        UserGetBagChest.prototype.chestId = 0;

        /**
         * UserGetBagChest count.
         * @member {number} count
         * @memberof msgProto.UserGetBagChest
         * @instance
         */
        UserGetBagChest.prototype.count = 0;

        /**
         * Encodes the specified UserGetBagChest message. Does not implicitly {@link msgProto.UserGetBagChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {msgProto.IUserGetBagChest} message UserGetBagChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBagChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chestId != null && message.hasOwnProperty("chestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.chestId);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Decodes a UserGetBagChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetBagChest} UserGetBagChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBagChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetBagChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chestId = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetBagChest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetBagChest} UserGetBagChest
         */
        UserGetBagChest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetBagChest)
                return object;
            var message = new $root.msgProto.UserGetBagChest();
            if (object.chestId != null)
                message.chestId = object.chestId | 0;
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserGetBagChest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {msgProto.UserGetBagChest} message UserGetBagChest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetBagChest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chestId = 0;
                object.count = 0;
            }
            if (message.chestId != null && message.hasOwnProperty("chestId"))
                object.chestId = message.chestId;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this UserGetBagChest to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetBagChest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetBagChest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetBagChest;
    })();

    msgProto.UserBuyGold = (function() {

        /**
         * Properties of a UserBuyGold.
         * @memberof msgProto
         * @interface IUserBuyGold
         */

        /**
         * Constructs a new UserBuyGold.
         * @memberof msgProto
         * @classdesc Represents a UserBuyGold.
         * @implements IUserBuyGold
         * @constructor
         * @param {msgProto.IUserBuyGold=} [properties] Properties to set
         */
        function UserBuyGold(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserBuyGold message. Does not implicitly {@link msgProto.UserBuyGold.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {msgProto.IUserBuyGold} message UserBuyGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserBuyGold message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyGold} UserBuyGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyGold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserBuyGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserBuyGold} UserBuyGold
         */
        UserBuyGold.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserBuyGold)
                return object;
            return new $root.msgProto.UserBuyGold();
        };

        /**
         * Creates a plain object from a UserBuyGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {msgProto.UserBuyGold} message UserBuyGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserBuyGold.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserBuyGold to JSON.
         * @function toJSON
         * @memberof msgProto.UserBuyGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserBuyGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserBuyGold;
    })();

    msgProto.UserBuyLingyun = (function() {

        /**
         * Properties of a UserBuyLingyun.
         * @memberof msgProto
         * @interface IUserBuyLingyun
         */

        /**
         * Constructs a new UserBuyLingyun.
         * @memberof msgProto
         * @classdesc Represents a UserBuyLingyun.
         * @implements IUserBuyLingyun
         * @constructor
         * @param {msgProto.IUserBuyLingyun=} [properties] Properties to set
         */
        function UserBuyLingyun(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserBuyLingyun message. Does not implicitly {@link msgProto.UserBuyLingyun.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {msgProto.IUserBuyLingyun} message UserBuyLingyun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyLingyun.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserBuyLingyun message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyLingyun} UserBuyLingyun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyLingyun.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyLingyun();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserBuyLingyun message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserBuyLingyun} UserBuyLingyun
         */
        UserBuyLingyun.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserBuyLingyun)
                return object;
            return new $root.msgProto.UserBuyLingyun();
        };

        /**
         * Creates a plain object from a UserBuyLingyun message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {msgProto.UserBuyLingyun} message UserBuyLingyun
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserBuyLingyun.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserBuyLingyun to JSON.
         * @function toJSON
         * @memberof msgProto.UserBuyLingyun
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserBuyLingyun.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserBuyLingyun;
    })();

    msgProto.UserGetRedPoint = (function() {

        /**
         * Properties of a UserGetRedPoint.
         * @memberof msgProto
         * @interface IUserGetRedPoint
         */

        /**
         * Constructs a new UserGetRedPoint.
         * @memberof msgProto
         * @classdesc Represents a UserGetRedPoint.
         * @implements IUserGetRedPoint
         * @constructor
         * @param {msgProto.IUserGetRedPoint=} [properties] Properties to set
         */
        function UserGetRedPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetRedPoint message. Does not implicitly {@link msgProto.UserGetRedPoint.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {msgProto.IUserGetRedPoint} message UserGetRedPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetRedPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetRedPoint message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetRedPoint} UserGetRedPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetRedPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetRedPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetRedPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetRedPoint} UserGetRedPoint
         */
        UserGetRedPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetRedPoint)
                return object;
            return new $root.msgProto.UserGetRedPoint();
        };

        /**
         * Creates a plain object from a UserGetRedPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {msgProto.UserGetRedPoint} message UserGetRedPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetRedPoint.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetRedPoint to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetRedPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetRedPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetRedPoint;
    })();

    msgProto.UserUpdateGuide = (function() {

        /**
         * Properties of a UserUpdateGuide.
         * @memberof msgProto
         * @interface IUserUpdateGuide
         * @property {number|null} [guideId] UserUpdateGuide guideId
         */

        /**
         * Constructs a new UserUpdateGuide.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateGuide.
         * @implements IUserUpdateGuide
         * @constructor
         * @param {msgProto.IUserUpdateGuide=} [properties] Properties to set
         */
        function UserUpdateGuide(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateGuide guideId.
         * @member {number} guideId
         * @memberof msgProto.UserUpdateGuide
         * @instance
         */
        UserUpdateGuide.prototype.guideId = 0;

        /**
         * Encodes the specified UserUpdateGuide message. Does not implicitly {@link msgProto.UserUpdateGuide.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {msgProto.IUserUpdateGuide} message UserUpdateGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateGuide.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guideId);
            return writer;
        };

        /**
         * Decodes a UserUpdateGuide message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateGuide} UserUpdateGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateGuide.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateGuide();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guideId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserUpdateGuide message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserUpdateGuide} UserUpdateGuide
         */
        UserUpdateGuide.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserUpdateGuide)
                return object;
            var message = new $root.msgProto.UserUpdateGuide();
            if (object.guideId != null)
                message.guideId = object.guideId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserUpdateGuide message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {msgProto.UserUpdateGuide} message UserUpdateGuide
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUpdateGuide.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guideId = 0;
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                object.guideId = message.guideId;
            return object;
        };

        /**
         * Converts this UserUpdateGuide to JSON.
         * @function toJSON
         * @memberof msgProto.UserUpdateGuide
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUpdateGuide.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserUpdateGuide;
    })();

    msgProto.UserGetWinRecord = (function() {

        /**
         * Properties of a UserGetWinRecord.
         * @memberof msgProto
         * @interface IUserGetWinRecord
         */

        /**
         * Constructs a new UserGetWinRecord.
         * @memberof msgProto
         * @classdesc Represents a UserGetWinRecord.
         * @implements IUserGetWinRecord
         * @constructor
         * @param {msgProto.IUserGetWinRecord=} [properties] Properties to set
         */
        function UserGetWinRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetWinRecord message. Does not implicitly {@link msgProto.UserGetWinRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {msgProto.IUserGetWinRecord} message UserGetWinRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWinRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetWinRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWinRecord} UserGetWinRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWinRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWinRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetWinRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetWinRecord} UserGetWinRecord
         */
        UserGetWinRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetWinRecord)
                return object;
            return new $root.msgProto.UserGetWinRecord();
        };

        /**
         * Creates a plain object from a UserGetWinRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {msgProto.UserGetWinRecord} message UserGetWinRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetWinRecord.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetWinRecord to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetWinRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetWinRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetWinRecord;
    })();

    msgProto.UserGetLoseRecord = (function() {

        /**
         * Properties of a UserGetLoseRecord.
         * @memberof msgProto
         * @interface IUserGetLoseRecord
         */

        /**
         * Constructs a new UserGetLoseRecord.
         * @memberof msgProto
         * @classdesc Represents a UserGetLoseRecord.
         * @implements IUserGetLoseRecord
         * @constructor
         * @param {msgProto.IUserGetLoseRecord=} [properties] Properties to set
         */
        function UserGetLoseRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetLoseRecord message. Does not implicitly {@link msgProto.UserGetLoseRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {msgProto.IUserGetLoseRecord} message UserGetLoseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetLoseRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetLoseRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetLoseRecord} UserGetLoseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetLoseRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetLoseRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetLoseRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetLoseRecord} UserGetLoseRecord
         */
        UserGetLoseRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetLoseRecord)
                return object;
            return new $root.msgProto.UserGetLoseRecord();
        };

        /**
         * Creates a plain object from a UserGetLoseRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {msgProto.UserGetLoseRecord} message UserGetLoseRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetLoseRecord.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetLoseRecord to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetLoseRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetLoseRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetLoseRecord;
    })();

    msgProto.UserBuyToUpLvl = (function() {

        /**
         * Properties of a UserBuyToUpLvl.
         * @memberof msgProto
         * @interface IUserBuyToUpLvl
         */

        /**
         * Constructs a new UserBuyToUpLvl.
         * @memberof msgProto
         * @classdesc Represents a UserBuyToUpLvl.
         * @implements IUserBuyToUpLvl
         * @constructor
         * @param {msgProto.IUserBuyToUpLvl=} [properties] Properties to set
         */
        function UserBuyToUpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserBuyToUpLvl message. Does not implicitly {@link msgProto.UserBuyToUpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {msgProto.IUserBuyToUpLvl} message UserBuyToUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyToUpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserBuyToUpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyToUpLvl} UserBuyToUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyToUpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyToUpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserBuyToUpLvl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserBuyToUpLvl} UserBuyToUpLvl
         */
        UserBuyToUpLvl.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserBuyToUpLvl)
                return object;
            return new $root.msgProto.UserBuyToUpLvl();
        };

        /**
         * Creates a plain object from a UserBuyToUpLvl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {msgProto.UserBuyToUpLvl} message UserBuyToUpLvl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserBuyToUpLvl.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserBuyToUpLvl to JSON.
         * @function toJSON
         * @memberof msgProto.UserBuyToUpLvl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserBuyToUpLvl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserBuyToUpLvl;
    })();

    msgProto.UserSaveDeskSuccess = (function() {

        /**
         * Properties of a UserSaveDeskSuccess.
         * @memberof msgProto
         * @interface IUserSaveDeskSuccess
         * @property {number|null} [type] UserSaveDeskSuccess type
         */

        /**
         * Constructs a new UserSaveDeskSuccess.
         * @memberof msgProto
         * @classdesc Represents a UserSaveDeskSuccess.
         * @implements IUserSaveDeskSuccess
         * @constructor
         * @param {msgProto.IUserSaveDeskSuccess=} [properties] Properties to set
         */
        function UserSaveDeskSuccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSaveDeskSuccess type.
         * @member {number} type
         * @memberof msgProto.UserSaveDeskSuccess
         * @instance
         */
        UserSaveDeskSuccess.prototype.type = 0;

        /**
         * Encodes the specified UserSaveDeskSuccess message. Does not implicitly {@link msgProto.UserSaveDeskSuccess.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {msgProto.IUserSaveDeskSuccess} message UserSaveDeskSuccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSaveDeskSuccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Decodes a UserSaveDeskSuccess message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSaveDeskSuccess} UserSaveDeskSuccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSaveDeskSuccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSaveDeskSuccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSaveDeskSuccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSaveDeskSuccess} UserSaveDeskSuccess
         */
        UserSaveDeskSuccess.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSaveDeskSuccess)
                return object;
            var message = new $root.msgProto.UserSaveDeskSuccess();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserSaveDeskSuccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {msgProto.UserSaveDeskSuccess} message UserSaveDeskSuccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSaveDeskSuccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this UserSaveDeskSuccess to JSON.
         * @function toJSON
         * @memberof msgProto.UserSaveDeskSuccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSaveDeskSuccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSaveDeskSuccess;
    })();

    msgProto.UserSetHeroEmbattle = (function() {

        /**
         * Properties of a UserSetHeroEmbattle.
         * @memberof msgProto
         * @interface IUserSetHeroEmbattle
         * @property {string|null} [heroEmbattle] UserSetHeroEmbattle heroEmbattle
         */

        /**
         * Constructs a new UserSetHeroEmbattle.
         * @memberof msgProto
         * @classdesc Represents a UserSetHeroEmbattle.
         * @implements IUserSetHeroEmbattle
         * @constructor
         * @param {msgProto.IUserSetHeroEmbattle=} [properties] Properties to set
         */
        function UserSetHeroEmbattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetHeroEmbattle heroEmbattle.
         * @member {string} heroEmbattle
         * @memberof msgProto.UserSetHeroEmbattle
         * @instance
         */
        UserSetHeroEmbattle.prototype.heroEmbattle = "";

        /**
         * Encodes the specified UserSetHeroEmbattle message. Does not implicitly {@link msgProto.UserSetHeroEmbattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {msgProto.IUserSetHeroEmbattle} message UserSetHeroEmbattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetHeroEmbattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroEmbattle != null && message.hasOwnProperty("heroEmbattle"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heroEmbattle);
            return writer;
        };

        /**
         * Decodes a UserSetHeroEmbattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetHeroEmbattle} UserSetHeroEmbattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetHeroEmbattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetHeroEmbattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroEmbattle = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSetHeroEmbattle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSetHeroEmbattle} UserSetHeroEmbattle
         */
        UserSetHeroEmbattle.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSetHeroEmbattle)
                return object;
            var message = new $root.msgProto.UserSetHeroEmbattle();
            if (object.heroEmbattle != null)
                message.heroEmbattle = String(object.heroEmbattle);
            return message;
        };

        /**
         * Creates a plain object from a UserSetHeroEmbattle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {msgProto.UserSetHeroEmbattle} message UserSetHeroEmbattle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetHeroEmbattle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.heroEmbattle = "";
            if (message.heroEmbattle != null && message.hasOwnProperty("heroEmbattle"))
                object.heroEmbattle = message.heroEmbattle;
            return object;
        };

        /**
         * Converts this UserSetHeroEmbattle to JSON.
         * @function toJSON
         * @memberof msgProto.UserSetHeroEmbattle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetHeroEmbattle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetHeroEmbattle;
    })();

    msgProto.UserBuyBagGrid = (function() {

        /**
         * Properties of a UserBuyBagGrid.
         * @memberof msgProto
         * @interface IUserBuyBagGrid
         */

        /**
         * Constructs a new UserBuyBagGrid.
         * @memberof msgProto
         * @classdesc Represents a UserBuyBagGrid.
         * @implements IUserBuyBagGrid
         * @constructor
         * @param {msgProto.IUserBuyBagGrid=} [properties] Properties to set
         */
        function UserBuyBagGrid(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserBuyBagGrid message. Does not implicitly {@link msgProto.UserBuyBagGrid.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {msgProto.IUserBuyBagGrid} message UserBuyBagGrid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyBagGrid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserBuyBagGrid message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyBagGrid} UserBuyBagGrid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyBagGrid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyBagGrid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserBuyBagGrid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserBuyBagGrid} UserBuyBagGrid
         */
        UserBuyBagGrid.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserBuyBagGrid)
                return object;
            return new $root.msgProto.UserBuyBagGrid();
        };

        /**
         * Creates a plain object from a UserBuyBagGrid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {msgProto.UserBuyBagGrid} message UserBuyBagGrid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserBuyBagGrid.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserBuyBagGrid to JSON.
         * @function toJSON
         * @memberof msgProto.UserBuyBagGrid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserBuyBagGrid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserBuyBagGrid;
    })();

    msgProto.UserUpdateCombat = (function() {

        /**
         * Properties of a UserUpdateCombat.
         * @memberof msgProto
         * @interface IUserUpdateCombat
         */

        /**
         * Constructs a new UserUpdateCombat.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateCombat.
         * @implements IUserUpdateCombat
         * @constructor
         * @param {msgProto.IUserUpdateCombat=} [properties] Properties to set
         */
        function UserUpdateCombat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserUpdateCombat message. Does not implicitly {@link msgProto.UserUpdateCombat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {msgProto.IUserUpdateCombat} message UserUpdateCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateCombat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserUpdateCombat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateCombat} UserUpdateCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateCombat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateCombat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserUpdateCombat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserUpdateCombat} UserUpdateCombat
         */
        UserUpdateCombat.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserUpdateCombat)
                return object;
            return new $root.msgProto.UserUpdateCombat();
        };

        /**
         * Creates a plain object from a UserUpdateCombat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {msgProto.UserUpdateCombat} message UserUpdateCombat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUpdateCombat.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserUpdateCombat to JSON.
         * @function toJSON
         * @memberof msgProto.UserUpdateCombat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUpdateCombat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserUpdateCombat;
    })();

    msgProto.UserSetAutoFight = (function() {

        /**
         * Properties of a UserSetAutoFight.
         * @memberof msgProto
         * @interface IUserSetAutoFight
         * @property {number|null} [isAuto] UserSetAutoFight isAuto
         */

        /**
         * Constructs a new UserSetAutoFight.
         * @memberof msgProto
         * @classdesc Represents a UserSetAutoFight.
         * @implements IUserSetAutoFight
         * @constructor
         * @param {msgProto.IUserSetAutoFight=} [properties] Properties to set
         */
        function UserSetAutoFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetAutoFight isAuto.
         * @member {number} isAuto
         * @memberof msgProto.UserSetAutoFight
         * @instance
         */
        UserSetAutoFight.prototype.isAuto = 0;

        /**
         * Encodes the specified UserSetAutoFight message. Does not implicitly {@link msgProto.UserSetAutoFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {msgProto.IUserSetAutoFight} message UserSetAutoFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetAutoFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isAuto != null && message.hasOwnProperty("isAuto"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isAuto);
            return writer;
        };

        /**
         * Decodes a UserSetAutoFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetAutoFight} UserSetAutoFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetAutoFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetAutoFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isAuto = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSetAutoFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSetAutoFight} UserSetAutoFight
         */
        UserSetAutoFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSetAutoFight)
                return object;
            var message = new $root.msgProto.UserSetAutoFight();
            if (object.isAuto != null)
                message.isAuto = object.isAuto | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserSetAutoFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {msgProto.UserSetAutoFight} message UserSetAutoFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetAutoFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isAuto = 0;
            if (message.isAuto != null && message.hasOwnProperty("isAuto"))
                object.isAuto = message.isAuto;
            return object;
        };

        /**
         * Converts this UserSetAutoFight to JSON.
         * @function toJSON
         * @memberof msgProto.UserSetAutoFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetAutoFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetAutoFight;
    })();

    msgProto.UserSetTimeError = (function() {

        /**
         * Properties of a UserSetTimeError.
         * @memberof msgProto
         * @interface IUserSetTimeError
         * @property {number|null} [errorNum] UserSetTimeError errorNum
         */

        /**
         * Constructs a new UserSetTimeError.
         * @memberof msgProto
         * @classdesc Represents a UserSetTimeError.
         * @implements IUserSetTimeError
         * @constructor
         * @param {msgProto.IUserSetTimeError=} [properties] Properties to set
         */
        function UserSetTimeError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetTimeError errorNum.
         * @member {number} errorNum
         * @memberof msgProto.UserSetTimeError
         * @instance
         */
        UserSetTimeError.prototype.errorNum = 0;

        /**
         * Encodes the specified UserSetTimeError message. Does not implicitly {@link msgProto.UserSetTimeError.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {msgProto.IUserSetTimeError} message UserSetTimeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTimeError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errorNum != null && message.hasOwnProperty("errorNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorNum);
            return writer;
        };

        /**
         * Decodes a UserSetTimeError message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetTimeError} UserSetTimeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTimeError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetTimeError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errorNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSetTimeError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSetTimeError} UserSetTimeError
         */
        UserSetTimeError.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSetTimeError)
                return object;
            var message = new $root.msgProto.UserSetTimeError();
            if (object.errorNum != null)
                message.errorNum = object.errorNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserSetTimeError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {msgProto.UserSetTimeError} message UserSetTimeError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetTimeError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errorNum = 0;
            if (message.errorNum != null && message.hasOwnProperty("errorNum"))
                object.errorNum = message.errorNum;
            return object;
        };

        /**
         * Converts this UserSetTimeError to JSON.
         * @function toJSON
         * @memberof msgProto.UserSetTimeError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetTimeError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetTimeError;
    })();

    msgProto.UserSetTodayRankWin = (function() {

        /**
         * Properties of a UserSetTodayRankWin.
         * @memberof msgProto
         * @interface IUserSetTodayRankWin
         * @property {number|Long|null} [eid] UserSetTodayRankWin eid
         */

        /**
         * Constructs a new UserSetTodayRankWin.
         * @memberof msgProto
         * @classdesc Represents a UserSetTodayRankWin.
         * @implements IUserSetTodayRankWin
         * @constructor
         * @param {msgProto.IUserSetTodayRankWin=} [properties] Properties to set
         */
        function UserSetTodayRankWin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetTodayRankWin eid.
         * @member {number|Long} eid
         * @memberof msgProto.UserSetTodayRankWin
         * @instance
         */
        UserSetTodayRankWin.prototype.eid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified UserSetTodayRankWin message. Does not implicitly {@link msgProto.UserSetTodayRankWin.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {msgProto.IUserSetTodayRankWin} message UserSetTodayRankWin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTodayRankWin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && message.hasOwnProperty("eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eid);
            return writer;
        };

        /**
         * Decodes a UserSetTodayRankWin message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetTodayRankWin} UserSetTodayRankWin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTodayRankWin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetTodayRankWin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSetTodayRankWin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSetTodayRankWin} UserSetTodayRankWin
         */
        UserSetTodayRankWin.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSetTodayRankWin)
                return object;
            var message = new $root.msgProto.UserSetTodayRankWin();
            if (object.eid != null)
                if ($util.Long)
                    (message.eid = $util.Long.fromValue(object.eid)).unsigned = true;
                else if (typeof object.eid === "string")
                    message.eid = parseInt(object.eid, 10);
                else if (typeof object.eid === "number")
                    message.eid = object.eid;
                else if (typeof object.eid === "object")
                    message.eid = new $util.LongBits(object.eid.low >>> 0, object.eid.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a UserSetTodayRankWin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {msgProto.UserSetTodayRankWin} message UserSetTodayRankWin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetTodayRankWin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.eid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.eid = options.longs === String ? "0" : 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (typeof message.eid === "number")
                    object.eid = options.longs === String ? String(message.eid) : message.eid;
                else
                    object.eid = options.longs === String ? $util.Long.prototype.toString.call(message.eid) : options.longs === Number ? new $util.LongBits(message.eid.low >>> 0, message.eid.high >>> 0).toNumber(true) : message.eid;
            return object;
        };

        /**
         * Converts this UserSetTodayRankWin to JSON.
         * @function toJSON
         * @memberof msgProto.UserSetTodayRankWin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetTodayRankWin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetTodayRankWin;
    })();

    msgProto.UserGetWarPrintedList = (function() {

        /**
         * Properties of a UserGetWarPrintedList.
         * @memberof msgProto
         * @interface IUserGetWarPrintedList
         */

        /**
         * Constructs a new UserGetWarPrintedList.
         * @memberof msgProto
         * @classdesc Represents a UserGetWarPrintedList.
         * @implements IUserGetWarPrintedList
         * @constructor
         * @param {msgProto.IUserGetWarPrintedList=} [properties] Properties to set
         */
        function UserGetWarPrintedList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetWarPrintedList message. Does not implicitly {@link msgProto.UserGetWarPrintedList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {msgProto.IUserGetWarPrintedList} message UserGetWarPrintedList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWarPrintedList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetWarPrintedList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWarPrintedList} UserGetWarPrintedList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWarPrintedList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWarPrintedList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetWarPrintedList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetWarPrintedList} UserGetWarPrintedList
         */
        UserGetWarPrintedList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetWarPrintedList)
                return object;
            return new $root.msgProto.UserGetWarPrintedList();
        };

        /**
         * Creates a plain object from a UserGetWarPrintedList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {msgProto.UserGetWarPrintedList} message UserGetWarPrintedList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetWarPrintedList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetWarPrintedList to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetWarPrintedList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetWarPrintedList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetWarPrintedList;
    })();

    msgProto.UserWarPrintedStrength = (function() {

        /**
         * Properties of a UserWarPrintedStrength.
         * @memberof msgProto
         * @interface IUserWarPrintedStrength
         * @property {number|null} [warPrintedId] UserWarPrintedStrength warPrintedId
         */

        /**
         * Constructs a new UserWarPrintedStrength.
         * @memberof msgProto
         * @classdesc Represents a UserWarPrintedStrength.
         * @implements IUserWarPrintedStrength
         * @constructor
         * @param {msgProto.IUserWarPrintedStrength=} [properties] Properties to set
         */
        function UserWarPrintedStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserWarPrintedStrength warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserWarPrintedStrength
         * @instance
         */
        UserWarPrintedStrength.prototype.warPrintedId = 0;

        /**
         * Encodes the specified UserWarPrintedStrength message. Does not implicitly {@link msgProto.UserWarPrintedStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {msgProto.IUserWarPrintedStrength} message UserWarPrintedStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserWarPrintedStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Decodes a UserWarPrintedStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserWarPrintedStrength} UserWarPrintedStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserWarPrintedStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserWarPrintedStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserWarPrintedStrength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserWarPrintedStrength} UserWarPrintedStrength
         */
        UserWarPrintedStrength.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserWarPrintedStrength)
                return object;
            var message = new $root.msgProto.UserWarPrintedStrength();
            if (object.warPrintedId != null)
                message.warPrintedId = object.warPrintedId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserWarPrintedStrength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {msgProto.UserWarPrintedStrength} message UserWarPrintedStrength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserWarPrintedStrength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.warPrintedId = 0;
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                object.warPrintedId = message.warPrintedId;
            return object;
        };

        /**
         * Converts this UserWarPrintedStrength to JSON.
         * @function toJSON
         * @memberof msgProto.UserWarPrintedStrength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserWarPrintedStrength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserWarPrintedStrength;
    })();

    msgProto.UserSetMedalTitle = (function() {

        /**
         * Properties of a UserSetMedalTitle.
         * @memberof msgProto
         * @interface IUserSetMedalTitle
         * @property {number|null} [warPrintedId] UserSetMedalTitle warPrintedId
         */

        /**
         * Constructs a new UserSetMedalTitle.
         * @memberof msgProto
         * @classdesc Represents a UserSetMedalTitle.
         * @implements IUserSetMedalTitle
         * @constructor
         * @param {msgProto.IUserSetMedalTitle=} [properties] Properties to set
         */
        function UserSetMedalTitle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetMedalTitle warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserSetMedalTitle
         * @instance
         */
        UserSetMedalTitle.prototype.warPrintedId = 0;

        /**
         * Encodes the specified UserSetMedalTitle message. Does not implicitly {@link msgProto.UserSetMedalTitle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {msgProto.IUserSetMedalTitle} message UserSetMedalTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetMedalTitle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Decodes a UserSetMedalTitle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetMedalTitle} UserSetMedalTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetMedalTitle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetMedalTitle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSetMedalTitle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSetMedalTitle} UserSetMedalTitle
         */
        UserSetMedalTitle.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSetMedalTitle)
                return object;
            var message = new $root.msgProto.UserSetMedalTitle();
            if (object.warPrintedId != null)
                message.warPrintedId = object.warPrintedId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserSetMedalTitle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {msgProto.UserSetMedalTitle} message UserSetMedalTitle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetMedalTitle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.warPrintedId = 0;
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                object.warPrintedId = message.warPrintedId;
            return object;
        };

        /**
         * Converts this UserSetMedalTitle to JSON.
         * @function toJSON
         * @memberof msgProto.UserSetMedalTitle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetMedalTitle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetMedalTitle;
    })();

    msgProto.UserGetGenuineQi = (function() {

        /**
         * Properties of a UserGetGenuineQi.
         * @memberof msgProto
         * @interface IUserGetGenuineQi
         */

        /**
         * Constructs a new UserGetGenuineQi.
         * @memberof msgProto
         * @classdesc Represents a UserGetGenuineQi.
         * @implements IUserGetGenuineQi
         * @constructor
         * @param {msgProto.IUserGetGenuineQi=} [properties] Properties to set
         */
        function UserGetGenuineQi(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetGenuineQi message. Does not implicitly {@link msgProto.UserGetGenuineQi.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {msgProto.IUserGetGenuineQi} message UserGetGenuineQi message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetGenuineQi.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetGenuineQi message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetGenuineQi} UserGetGenuineQi
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetGenuineQi.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetGenuineQi();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetGenuineQi message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetGenuineQi} UserGetGenuineQi
         */
        UserGetGenuineQi.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetGenuineQi)
                return object;
            return new $root.msgProto.UserGetGenuineQi();
        };

        /**
         * Creates a plain object from a UserGetGenuineQi message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {msgProto.UserGetGenuineQi} message UserGetGenuineQi
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetGenuineQi.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetGenuineQi to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetGenuineQi
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetGenuineQi.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetGenuineQi;
    })();

    msgProto.UserActiveMedal = (function() {

        /**
         * Properties of a UserActiveMedal.
         * @memberof msgProto
         * @interface IUserActiveMedal
         * @property {number|null} [warPrintedId] UserActiveMedal warPrintedId
         */

        /**
         * Constructs a new UserActiveMedal.
         * @memberof msgProto
         * @classdesc Represents a UserActiveMedal.
         * @implements IUserActiveMedal
         * @constructor
         * @param {msgProto.IUserActiveMedal=} [properties] Properties to set
         */
        function UserActiveMedal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserActiveMedal warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserActiveMedal
         * @instance
         */
        UserActiveMedal.prototype.warPrintedId = 0;

        /**
         * Encodes the specified UserActiveMedal message. Does not implicitly {@link msgProto.UserActiveMedal.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {msgProto.IUserActiveMedal} message UserActiveMedal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserActiveMedal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Decodes a UserActiveMedal message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserActiveMedal} UserActiveMedal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserActiveMedal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserActiveMedal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserActiveMedal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserActiveMedal} UserActiveMedal
         */
        UserActiveMedal.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserActiveMedal)
                return object;
            var message = new $root.msgProto.UserActiveMedal();
            if (object.warPrintedId != null)
                message.warPrintedId = object.warPrintedId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserActiveMedal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {msgProto.UserActiveMedal} message UserActiveMedal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserActiveMedal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.warPrintedId = 0;
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                object.warPrintedId = message.warPrintedId;
            return object;
        };

        /**
         * Converts this UserActiveMedal to JSON.
         * @function toJSON
         * @memberof msgProto.UserActiveMedal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserActiveMedal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserActiveMedal;
    })();

    msgProto.UserGetBindPhoneUrl = (function() {

        /**
         * Properties of a UserGetBindPhoneUrl.
         * @memberof msgProto
         * @interface IUserGetBindPhoneUrl
         */

        /**
         * Constructs a new UserGetBindPhoneUrl.
         * @memberof msgProto
         * @classdesc Represents a UserGetBindPhoneUrl.
         * @implements IUserGetBindPhoneUrl
         * @constructor
         * @param {msgProto.IUserGetBindPhoneUrl=} [properties] Properties to set
         */
        function UserGetBindPhoneUrl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified UserGetBindPhoneUrl message. Does not implicitly {@link msgProto.UserGetBindPhoneUrl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {msgProto.IUserGetBindPhoneUrl} message UserGetBindPhoneUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBindPhoneUrl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a UserGetBindPhoneUrl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetBindPhoneUrl} UserGetBindPhoneUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBindPhoneUrl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetBindPhoneUrl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetBindPhoneUrl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetBindPhoneUrl} UserGetBindPhoneUrl
         */
        UserGetBindPhoneUrl.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetBindPhoneUrl)
                return object;
            return new $root.msgProto.UserGetBindPhoneUrl();
        };

        /**
         * Creates a plain object from a UserGetBindPhoneUrl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {msgProto.UserGetBindPhoneUrl} message UserGetBindPhoneUrl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetBindPhoneUrl.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UserGetBindPhoneUrl to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetBindPhoneUrl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetBindPhoneUrl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetBindPhoneUrl;
    })();

    msgProto.UserGetWanbagift = (function() {

        /**
         * Properties of a UserGetWanbagift.
         * @memberof msgProto
         * @interface IUserGetWanbagift
         * @property {string|null} [os] UserGetWanbagift os
         * @property {number|null} [giftId] UserGetWanbagift giftId
         */

        /**
         * Constructs a new UserGetWanbagift.
         * @memberof msgProto
         * @classdesc Represents a UserGetWanbagift.
         * @implements IUserGetWanbagift
         * @constructor
         * @param {msgProto.IUserGetWanbagift=} [properties] Properties to set
         */
        function UserGetWanbagift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserGetWanbagift os.
         * @member {string} os
         * @memberof msgProto.UserGetWanbagift
         * @instance
         */
        UserGetWanbagift.prototype.os = "";

        /**
         * UserGetWanbagift giftId.
         * @member {number} giftId
         * @memberof msgProto.UserGetWanbagift
         * @instance
         */
        UserGetWanbagift.prototype.giftId = 0;

        /**
         * Encodes the specified UserGetWanbagift message. Does not implicitly {@link msgProto.UserGetWanbagift.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {msgProto.IUserGetWanbagift} message UserGetWanbagift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWanbagift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.os != null && message.hasOwnProperty("os"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.os);
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.giftId);
            return writer;
        };

        /**
         * Decodes a UserGetWanbagift message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWanbagift} UserGetWanbagift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWanbagift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWanbagift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.os = reader.string();
                    break;
                case 2:
                    message.giftId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserGetWanbagift message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserGetWanbagift} UserGetWanbagift
         */
        UserGetWanbagift.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserGetWanbagift)
                return object;
            var message = new $root.msgProto.UserGetWanbagift();
            if (object.os != null)
                message.os = String(object.os);
            if (object.giftId != null)
                message.giftId = object.giftId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserGetWanbagift message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {msgProto.UserGetWanbagift} message UserGetWanbagift
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserGetWanbagift.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.os = "";
                object.giftId = 0;
            }
            if (message.os != null && message.hasOwnProperty("os"))
                object.os = message.os;
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                object.giftId = message.giftId;
            return object;
        };

        /**
         * Converts this UserGetWanbagift to JSON.
         * @function toJSON
         * @memberof msgProto.UserGetWanbagift
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserGetWanbagift.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserGetWanbagift;
    })();

    msgProto.UserUpdateSetting = (function() {

        /**
         * Properties of a UserUpdateSetting.
         * @memberof msgProto
         * @interface IUserUpdateSetting
         * @property {boolean|null} [catNoVipChat] UserUpdateSetting catNoVipChat
         * @property {boolean|null} [autoBuyLittleHorn] UserUpdateSetting autoBuyLittleHorn
         */

        /**
         * Constructs a new UserUpdateSetting.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateSetting.
         * @implements IUserUpdateSetting
         * @constructor
         * @param {msgProto.IUserUpdateSetting=} [properties] Properties to set
         */
        function UserUpdateSetting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateSetting catNoVipChat.
         * @member {boolean} catNoVipChat
         * @memberof msgProto.UserUpdateSetting
         * @instance
         */
        UserUpdateSetting.prototype.catNoVipChat = false;

        /**
         * UserUpdateSetting autoBuyLittleHorn.
         * @member {boolean} autoBuyLittleHorn
         * @memberof msgProto.UserUpdateSetting
         * @instance
         */
        UserUpdateSetting.prototype.autoBuyLittleHorn = false;

        /**
         * Encodes the specified UserUpdateSetting message. Does not implicitly {@link msgProto.UserUpdateSetting.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {msgProto.IUserUpdateSetting} message UserUpdateSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.catNoVipChat != null && message.hasOwnProperty("catNoVipChat"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.catNoVipChat);
            if (message.autoBuyLittleHorn != null && message.hasOwnProperty("autoBuyLittleHorn"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoBuyLittleHorn);
            return writer;
        };

        /**
         * Decodes a UserUpdateSetting message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateSetting} UserUpdateSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateSetting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.catNoVipChat = reader.bool();
                    break;
                case 2:
                    message.autoBuyLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserUpdateSetting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserUpdateSetting} UserUpdateSetting
         */
        UserUpdateSetting.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserUpdateSetting)
                return object;
            var message = new $root.msgProto.UserUpdateSetting();
            if (object.catNoVipChat != null)
                message.catNoVipChat = Boolean(object.catNoVipChat);
            if (object.autoBuyLittleHorn != null)
                message.autoBuyLittleHorn = Boolean(object.autoBuyLittleHorn);
            return message;
        };

        /**
         * Creates a plain object from a UserUpdateSetting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {msgProto.UserUpdateSetting} message UserUpdateSetting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUpdateSetting.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.catNoVipChat = false;
                object.autoBuyLittleHorn = false;
            }
            if (message.catNoVipChat != null && message.hasOwnProperty("catNoVipChat"))
                object.catNoVipChat = message.catNoVipChat;
            if (message.autoBuyLittleHorn != null && message.hasOwnProperty("autoBuyLittleHorn"))
                object.autoBuyLittleHorn = message.autoBuyLittleHorn;
            return object;
        };

        /**
         * Converts this UserUpdateSetting to JSON.
         * @function toJSON
         * @memberof msgProto.UserUpdateSetting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUpdateSetting.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserUpdateSetting;
    })();

    msgProto.UserUpdateItems4Bag = (function() {

        /**
         * Properties of a UserUpdateItems4Bag.
         * @memberof msgProto
         * @interface IUserUpdateItems4Bag
         * @property {number|null} [itemId] UserUpdateItems4Bag itemId
         */

        /**
         * Constructs a new UserUpdateItems4Bag.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateItems4Bag.
         * @implements IUserUpdateItems4Bag
         * @constructor
         * @param {msgProto.IUserUpdateItems4Bag=} [properties] Properties to set
         */
        function UserUpdateItems4Bag(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateItems4Bag itemId.
         * @member {number} itemId
         * @memberof msgProto.UserUpdateItems4Bag
         * @instance
         */
        UserUpdateItems4Bag.prototype.itemId = 0;

        /**
         * Encodes the specified UserUpdateItems4Bag message. Does not implicitly {@link msgProto.UserUpdateItems4Bag.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {msgProto.IUserUpdateItems4Bag} message UserUpdateItems4Bag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateItems4Bag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Decodes a UserUpdateItems4Bag message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateItems4Bag} UserUpdateItems4Bag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateItems4Bag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateItems4Bag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserUpdateItems4Bag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserUpdateItems4Bag} UserUpdateItems4Bag
         */
        UserUpdateItems4Bag.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserUpdateItems4Bag)
                return object;
            var message = new $root.msgProto.UserUpdateItems4Bag();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserUpdateItems4Bag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {msgProto.UserUpdateItems4Bag} message UserUpdateItems4Bag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserUpdateItems4Bag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemId = 0;
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            return object;
        };

        /**
         * Converts this UserUpdateItems4Bag to JSON.
         * @function toJSON
         * @memberof msgProto.UserUpdateItems4Bag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserUpdateItems4Bag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserUpdateItems4Bag;
    })();

    msgProto.FriendGetInfo = (function() {

        /**
         * Properties of a FriendGetInfo.
         * @memberof msgProto
         * @interface IFriendGetInfo
         */

        /**
         * Constructs a new FriendGetInfo.
         * @memberof msgProto
         * @classdesc Represents a FriendGetInfo.
         * @implements IFriendGetInfo
         * @constructor
         * @param {msgProto.IFriendGetInfo=} [properties] Properties to set
         */
        function FriendGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FriendGetInfo message. Does not implicitly {@link msgProto.FriendGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {msgProto.IFriendGetInfo} message FriendGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FriendGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendGetInfo} FriendGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FriendGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FriendGetInfo} FriendGetInfo
         */
        FriendGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FriendGetInfo)
                return object;
            return new $root.msgProto.FriendGetInfo();
        };

        /**
         * Creates a plain object from a FriendGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {msgProto.FriendGetInfo} message FriendGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FriendGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.FriendGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FriendGetInfo;
    })();

    msgProto.FriendRequestFriend = (function() {

        /**
         * Properties of a FriendRequestFriend.
         * @memberof msgProto
         * @interface IFriendRequestFriend
         * @property {number|Long|null} [requestedId] FriendRequestFriend requestedId
         */

        /**
         * Constructs a new FriendRequestFriend.
         * @memberof msgProto
         * @classdesc Represents a FriendRequestFriend.
         * @implements IFriendRequestFriend
         * @constructor
         * @param {msgProto.IFriendRequestFriend=} [properties] Properties to set
         */
        function FriendRequestFriend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendRequestFriend requestedId.
         * @member {number|Long} requestedId
         * @memberof msgProto.FriendRequestFriend
         * @instance
         */
        FriendRequestFriend.prototype.requestedId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified FriendRequestFriend message. Does not implicitly {@link msgProto.FriendRequestFriend.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {msgProto.IFriendRequestFriend} message FriendRequestFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendRequestFriend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestedId != null && message.hasOwnProperty("requestedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestedId);
            return writer;
        };

        /**
         * Decodes a FriendRequestFriend message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendRequestFriend} FriendRequestFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRequestFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendRequestFriend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestedId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FriendRequestFriend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FriendRequestFriend} FriendRequestFriend
         */
        FriendRequestFriend.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FriendRequestFriend)
                return object;
            var message = new $root.msgProto.FriendRequestFriend();
            if (object.requestedId != null)
                if ($util.Long)
                    (message.requestedId = $util.Long.fromValue(object.requestedId)).unsigned = true;
                else if (typeof object.requestedId === "string")
                    message.requestedId = parseInt(object.requestedId, 10);
                else if (typeof object.requestedId === "number")
                    message.requestedId = object.requestedId;
                else if (typeof object.requestedId === "object")
                    message.requestedId = new $util.LongBits(object.requestedId.low >>> 0, object.requestedId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a FriendRequestFriend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {msgProto.FriendRequestFriend} message FriendRequestFriend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendRequestFriend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.requestedId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestedId = options.longs === String ? "0" : 0;
            if (message.requestedId != null && message.hasOwnProperty("requestedId"))
                if (typeof message.requestedId === "number")
                    object.requestedId = options.longs === String ? String(message.requestedId) : message.requestedId;
                else
                    object.requestedId = options.longs === String ? $util.Long.prototype.toString.call(message.requestedId) : options.longs === Number ? new $util.LongBits(message.requestedId.low >>> 0, message.requestedId.high >>> 0).toNumber(true) : message.requestedId;
            return object;
        };

        /**
         * Converts this FriendRequestFriend to JSON.
         * @function toJSON
         * @memberof msgProto.FriendRequestFriend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendRequestFriend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FriendRequestFriend;
    })();

    msgProto.FriendDisposeFriendRequest = (function() {

        /**
         * Properties of a FriendDisposeFriendRequest.
         * @memberof msgProto
         * @interface IFriendDisposeFriendRequest
         * @property {number|Long|null} [requestId] FriendDisposeFriendRequest requestId
         * @property {boolean|null} [isTake] FriendDisposeFriendRequest isTake
         */

        /**
         * Constructs a new FriendDisposeFriendRequest.
         * @memberof msgProto
         * @classdesc Represents a FriendDisposeFriendRequest.
         * @implements IFriendDisposeFriendRequest
         * @constructor
         * @param {msgProto.IFriendDisposeFriendRequest=} [properties] Properties to set
         */
        function FriendDisposeFriendRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendDisposeFriendRequest requestId.
         * @member {number|Long} requestId
         * @memberof msgProto.FriendDisposeFriendRequest
         * @instance
         */
        FriendDisposeFriendRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FriendDisposeFriendRequest isTake.
         * @member {boolean} isTake
         * @memberof msgProto.FriendDisposeFriendRequest
         * @instance
         */
        FriendDisposeFriendRequest.prototype.isTake = false;

        /**
         * Encodes the specified FriendDisposeFriendRequest message. Does not implicitly {@link msgProto.FriendDisposeFriendRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {msgProto.IFriendDisposeFriendRequest} message FriendDisposeFriendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendDisposeFriendRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.isTake != null && message.hasOwnProperty("isTake"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isTake);
            return writer;
        };

        /**
         * Decodes a FriendDisposeFriendRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendDisposeFriendRequest} FriendDisposeFriendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendDisposeFriendRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendDisposeFriendRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.isTake = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FriendDisposeFriendRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FriendDisposeFriendRequest} FriendDisposeFriendRequest
         */
        FriendDisposeFriendRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FriendDisposeFriendRequest)
                return object;
            var message = new $root.msgProto.FriendDisposeFriendRequest();
            if (object.requestId != null)
                if ($util.Long)
                    (message.requestId = $util.Long.fromValue(object.requestId)).unsigned = true;
                else if (typeof object.requestId === "string")
                    message.requestId = parseInt(object.requestId, 10);
                else if (typeof object.requestId === "number")
                    message.requestId = object.requestId;
                else if (typeof object.requestId === "object")
                    message.requestId = new $util.LongBits(object.requestId.low >>> 0, object.requestId.high >>> 0).toNumber(true);
            if (object.isTake != null)
                message.isTake = Boolean(object.isTake);
            return message;
        };

        /**
         * Creates a plain object from a FriendDisposeFriendRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {msgProto.FriendDisposeFriendRequest} message FriendDisposeFriendRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendDisposeFriendRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.requestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestId = options.longs === String ? "0" : 0;
                object.isTake = false;
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (typeof message.requestId === "number")
                    object.requestId = options.longs === String ? String(message.requestId) : message.requestId;
                else
                    object.requestId = options.longs === String ? $util.Long.prototype.toString.call(message.requestId) : options.longs === Number ? new $util.LongBits(message.requestId.low >>> 0, message.requestId.high >>> 0).toNumber(true) : message.requestId;
            if (message.isTake != null && message.hasOwnProperty("isTake"))
                object.isTake = message.isTake;
            return object;
        };

        /**
         * Converts this FriendDisposeFriendRequest to JSON.
         * @function toJSON
         * @memberof msgProto.FriendDisposeFriendRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendDisposeFriendRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FriendDisposeFriendRequest;
    })();

    msgProto.FriendEventCheer = (function() {

        /**
         * Properties of a FriendEventCheer.
         * @memberof msgProto
         * @interface IFriendEventCheer
         */

        /**
         * Constructs a new FriendEventCheer.
         * @memberof msgProto
         * @classdesc Represents a FriendEventCheer.
         * @implements IFriendEventCheer
         * @constructor
         * @param {msgProto.IFriendEventCheer=} [properties] Properties to set
         */
        function FriendEventCheer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FriendEventCheer message. Does not implicitly {@link msgProto.FriendEventCheer.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {msgProto.IFriendEventCheer} message FriendEventCheer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendEventCheer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FriendEventCheer message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendEventCheer} FriendEventCheer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendEventCheer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendEventCheer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FriendEventCheer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FriendEventCheer} FriendEventCheer
         */
        FriendEventCheer.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FriendEventCheer)
                return object;
            return new $root.msgProto.FriendEventCheer();
        };

        /**
         * Creates a plain object from a FriendEventCheer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {msgProto.FriendEventCheer} message FriendEventCheer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendEventCheer.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FriendEventCheer to JSON.
         * @function toJSON
         * @memberof msgProto.FriendEventCheer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendEventCheer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FriendEventCheer;
    })();

    msgProto.FriendGetRequestInfo = (function() {

        /**
         * Properties of a FriendGetRequestInfo.
         * @memberof msgProto
         * @interface IFriendGetRequestInfo
         */

        /**
         * Constructs a new FriendGetRequestInfo.
         * @memberof msgProto
         * @classdesc Represents a FriendGetRequestInfo.
         * @implements IFriendGetRequestInfo
         * @constructor
         * @param {msgProto.IFriendGetRequestInfo=} [properties] Properties to set
         */
        function FriendGetRequestInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FriendGetRequestInfo message. Does not implicitly {@link msgProto.FriendGetRequestInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {msgProto.IFriendGetRequestInfo} message FriendGetRequestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetRequestInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FriendGetRequestInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendGetRequestInfo} FriendGetRequestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetRequestInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendGetRequestInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FriendGetRequestInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FriendGetRequestInfo} FriendGetRequestInfo
         */
        FriendGetRequestInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FriendGetRequestInfo)
                return object;
            return new $root.msgProto.FriendGetRequestInfo();
        };

        /**
         * Creates a plain object from a FriendGetRequestInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {msgProto.FriendGetRequestInfo} message FriendGetRequestInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FriendGetRequestInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FriendGetRequestInfo to JSON.
         * @function toJSON
         * @memberof msgProto.FriendGetRequestInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FriendGetRequestInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FriendGetRequestInfo;
    })();

    msgProto.FightPickLoot = (function() {

        /**
         * Properties of a FightPickLoot.
         * @memberof msgProto
         * @interface IFightPickLoot
         * @property {number|null} [copyId] FightPickLoot copyId
         * @property {string|null} [uidArr] FightPickLoot uidArr
         * @property {string|null} [fightData] FightPickLoot fightData
         */

        /**
         * Constructs a new FightPickLoot.
         * @memberof msgProto
         * @classdesc Represents a FightPickLoot.
         * @implements IFightPickLoot
         * @constructor
         * @param {msgProto.IFightPickLoot=} [properties] Properties to set
         */
        function FightPickLoot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightPickLoot copyId.
         * @member {number} copyId
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.copyId = 0;

        /**
         * FightPickLoot uidArr.
         * @member {string} uidArr
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.uidArr = "";

        /**
         * FightPickLoot fightData.
         * @member {string} fightData
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.fightData = "";

        /**
         * Encodes the specified FightPickLoot message. Does not implicitly {@link msgProto.FightPickLoot.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {msgProto.IFightPickLoot} message FightPickLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightPickLoot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.uidArr != null && message.hasOwnProperty("uidArr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.uidArr);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Decodes a FightPickLoot message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightPickLoot} FightPickLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightPickLoot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightPickLoot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.uidArr = reader.string();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FightPickLoot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FightPickLoot} FightPickLoot
         */
        FightPickLoot.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FightPickLoot)
                return object;
            var message = new $root.msgProto.FightPickLoot();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.uidArr != null)
                message.uidArr = String(object.uidArr);
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            return message;
        };

        /**
         * Creates a plain object from a FightPickLoot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {msgProto.FightPickLoot} message FightPickLoot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FightPickLoot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.uidArr = "";
                object.fightData = "";
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.uidArr != null && message.hasOwnProperty("uidArr"))
                object.uidArr = message.uidArr;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            return object;
        };

        /**
         * Converts this FightPickLoot to JSON.
         * @function toJSON
         * @memberof msgProto.FightPickLoot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FightPickLoot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FightPickLoot;
    })();

    msgProto.FightRevive = (function() {

        /**
         * Properties of a FightRevive.
         * @memberof msgProto
         * @interface IFightRevive
         */

        /**
         * Constructs a new FightRevive.
         * @memberof msgProto
         * @classdesc Represents a FightRevive.
         * @implements IFightRevive
         * @constructor
         * @param {msgProto.IFightRevive=} [properties] Properties to set
         */
        function FightRevive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FightRevive message. Does not implicitly {@link msgProto.FightRevive.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightRevive
         * @static
         * @param {msgProto.IFightRevive} message FightRevive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRevive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FightRevive message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightRevive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightRevive} FightRevive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRevive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightRevive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FightRevive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FightRevive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FightRevive} FightRevive
         */
        FightRevive.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FightRevive)
                return object;
            return new $root.msgProto.FightRevive();
        };

        /**
         * Creates a plain object from a FightRevive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FightRevive
         * @static
         * @param {msgProto.FightRevive} message FightRevive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FightRevive.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FightRevive to JSON.
         * @function toJSON
         * @memberof msgProto.FightRevive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FightRevive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FightRevive;
    })();

    msgProto.FightGetAndInitNextLoot = (function() {

        /**
         * Properties of a FightGetAndInitNextLoot.
         * @memberof msgProto
         * @interface IFightGetAndInitNextLoot
         * @property {number|null} [copyId] FightGetAndInitNextLoot copyId
         * @property {boolean|null} [isBoss] FightGetAndInitNextLoot isBoss
         * @property {number|null} [lvl] FightGetAndInitNextLoot lvl
         */

        /**
         * Constructs a new FightGetAndInitNextLoot.
         * @memberof msgProto
         * @classdesc Represents a FightGetAndInitNextLoot.
         * @implements IFightGetAndInitNextLoot
         * @constructor
         * @param {msgProto.IFightGetAndInitNextLoot=} [properties] Properties to set
         */
        function FightGetAndInitNextLoot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightGetAndInitNextLoot copyId.
         * @member {number} copyId
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.copyId = 0;

        /**
         * FightGetAndInitNextLoot isBoss.
         * @member {boolean} isBoss
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.isBoss = false;

        /**
         * FightGetAndInitNextLoot lvl.
         * @member {number} lvl
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.lvl = 0;

        /**
         * Encodes the specified FightGetAndInitNextLoot message. Does not implicitly {@link msgProto.FightGetAndInitNextLoot.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {msgProto.IFightGetAndInitNextLoot} message FightGetAndInitNextLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightGetAndInitNextLoot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.isBoss != null && message.hasOwnProperty("isBoss"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBoss);
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lvl);
            return writer;
        };

        /**
         * Decodes a FightGetAndInitNextLoot message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightGetAndInitNextLoot} FightGetAndInitNextLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightGetAndInitNextLoot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightGetAndInitNextLoot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.isBoss = reader.bool();
                    break;
                case 3:
                    message.lvl = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FightGetAndInitNextLoot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FightGetAndInitNextLoot} FightGetAndInitNextLoot
         */
        FightGetAndInitNextLoot.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FightGetAndInitNextLoot)
                return object;
            var message = new $root.msgProto.FightGetAndInitNextLoot();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.isBoss != null)
                message.isBoss = Boolean(object.isBoss);
            if (object.lvl != null)
                message.lvl = object.lvl | 0;
            return message;
        };

        /**
         * Creates a plain object from a FightGetAndInitNextLoot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {msgProto.FightGetAndInitNextLoot} message FightGetAndInitNextLoot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FightGetAndInitNextLoot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.isBoss = false;
                object.lvl = 0;
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.isBoss != null && message.hasOwnProperty("isBoss"))
                object.isBoss = message.isBoss;
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                object.lvl = message.lvl;
            return object;
        };

        /**
         * Converts this FightGetAndInitNextLoot to JSON.
         * @function toJSON
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FightGetAndInitNextLoot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FightGetAndInitNextLoot;
    })();

    msgProto.FiveDaysTargetGetInfo = (function() {

        /**
         * Properties of a FiveDaysTargetGetInfo.
         * @memberof msgProto
         * @interface IFiveDaysTargetGetInfo
         */

        /**
         * Constructs a new FiveDaysTargetGetInfo.
         * @memberof msgProto
         * @classdesc Represents a FiveDaysTargetGetInfo.
         * @implements IFiveDaysTargetGetInfo
         * @constructor
         * @param {msgProto.IFiveDaysTargetGetInfo=} [properties] Properties to set
         */
        function FiveDaysTargetGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FiveDaysTargetGetInfo message. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo} message FiveDaysTargetGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FiveDaysTargetGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FiveDaysTargetGetInfo} FiveDaysTargetGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FiveDaysTargetGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FiveDaysTargetGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FiveDaysTargetGetInfo} FiveDaysTargetGetInfo
         */
        FiveDaysTargetGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FiveDaysTargetGetInfo)
                return object;
            return new $root.msgProto.FiveDaysTargetGetInfo();
        };

        /**
         * Creates a plain object from a FiveDaysTargetGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {msgProto.FiveDaysTargetGetInfo} message FiveDaysTargetGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FiveDaysTargetGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FiveDaysTargetGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FiveDaysTargetGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FiveDaysTargetGetInfo;
    })();

    msgProto.FiveDaysTargetGetInfo1 = (function() {

        /**
         * Properties of a FiveDaysTargetGetInfo1.
         * @memberof msgProto
         * @interface IFiveDaysTargetGetInfo1
         */

        /**
         * Constructs a new FiveDaysTargetGetInfo1.
         * @memberof msgProto
         * @classdesc Represents a FiveDaysTargetGetInfo1.
         * @implements IFiveDaysTargetGetInfo1
         * @constructor
         * @param {msgProto.IFiveDaysTargetGetInfo1=} [properties] Properties to set
         */
        function FiveDaysTargetGetInfo1(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified FiveDaysTargetGetInfo1 message. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo1.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo1} message FiveDaysTargetGetInfo1 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo1.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a FiveDaysTargetGetInfo1 message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FiveDaysTargetGetInfo1} FiveDaysTargetGetInfo1
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo1.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FiveDaysTargetGetInfo1();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a FiveDaysTargetGetInfo1 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.FiveDaysTargetGetInfo1} FiveDaysTargetGetInfo1
         */
        FiveDaysTargetGetInfo1.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.FiveDaysTargetGetInfo1)
                return object;
            return new $root.msgProto.FiveDaysTargetGetInfo1();
        };

        /**
         * Creates a plain object from a FiveDaysTargetGetInfo1 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {msgProto.FiveDaysTargetGetInfo1} message FiveDaysTargetGetInfo1
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FiveDaysTargetGetInfo1.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FiveDaysTargetGetInfo1 to JSON.
         * @function toJSON
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FiveDaysTargetGetInfo1.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FiveDaysTargetGetInfo1;
    })();

    msgProto.GuildGetInfo = (function() {

        /**
         * Properties of a GuildGetInfo.
         * @memberof msgProto
         * @interface IGuildGetInfo
         */

        /**
         * Constructs a new GuildGetInfo.
         * @memberof msgProto
         * @classdesc Represents a GuildGetInfo.
         * @implements IGuildGetInfo
         * @constructor
         * @param {msgProto.IGuildGetInfo=} [properties] Properties to set
         */
        function GuildGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildGetInfo message. Does not implicitly {@link msgProto.GuildGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {msgProto.IGuildGetInfo} message GuildGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGetInfo} GuildGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildGetInfo} GuildGetInfo
         */
        GuildGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildGetInfo)
                return object;
            return new $root.msgProto.GuildGetInfo();
        };

        /**
         * Creates a plain object from a GuildGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {msgProto.GuildGetInfo} message GuildGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.GuildGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildGetInfo;
    })();

    msgProto.GuildEstablishGuild = (function() {

        /**
         * Properties of a GuildEstablishGuild.
         * @memberof msgProto
         * @interface IGuildEstablishGuild
         * @property {string|null} [name] GuildEstablishGuild name
         */

        /**
         * Constructs a new GuildEstablishGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildEstablishGuild.
         * @implements IGuildEstablishGuild
         * @constructor
         * @param {msgProto.IGuildEstablishGuild=} [properties] Properties to set
         */
        function GuildEstablishGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildEstablishGuild name.
         * @member {string} name
         * @memberof msgProto.GuildEstablishGuild
         * @instance
         */
        GuildEstablishGuild.prototype.name = "";

        /**
         * Encodes the specified GuildEstablishGuild message. Does not implicitly {@link msgProto.GuildEstablishGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {msgProto.IGuildEstablishGuild} message GuildEstablishGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildEstablishGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Decodes a GuildEstablishGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildEstablishGuild} GuildEstablishGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildEstablishGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildEstablishGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildEstablishGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildEstablishGuild} GuildEstablishGuild
         */
        GuildEstablishGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildEstablishGuild)
                return object;
            var message = new $root.msgProto.GuildEstablishGuild();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a GuildEstablishGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {msgProto.GuildEstablishGuild} message GuildEstablishGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildEstablishGuild.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this GuildEstablishGuild to JSON.
         * @function toJSON
         * @memberof msgProto.GuildEstablishGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildEstablishGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildEstablishGuild;
    })();

    msgProto.GuildSeekGuild = (function() {

        /**
         * Properties of a GuildSeekGuild.
         * @memberof msgProto
         * @interface IGuildSeekGuild
         * @property {number|null} [guildId] GuildSeekGuild guildId
         */

        /**
         * Constructs a new GuildSeekGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildSeekGuild.
         * @implements IGuildSeekGuild
         * @constructor
         * @param {msgProto.IGuildSeekGuild=} [properties] Properties to set
         */
        function GuildSeekGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSeekGuild guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildSeekGuild
         * @instance
         */
        GuildSeekGuild.prototype.guildId = 0;

        /**
         * Encodes the specified GuildSeekGuild message. Does not implicitly {@link msgProto.GuildSeekGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {msgProto.IGuildSeekGuild} message GuildSeekGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSeekGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildSeekGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSeekGuild} GuildSeekGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSeekGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSeekGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildSeekGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildSeekGuild} GuildSeekGuild
         */
        GuildSeekGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildSeekGuild)
                return object;
            var message = new $root.msgProto.GuildSeekGuild();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildSeekGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {msgProto.GuildSeekGuild} message GuildSeekGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildSeekGuild.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guildId = 0;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildSeekGuild to JSON.
         * @function toJSON
         * @memberof msgProto.GuildSeekGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildSeekGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildSeekGuild;
    })();

    msgProto.GuildJoinGuild = (function() {

        /**
         * Properties of a GuildJoinGuild.
         * @memberof msgProto
         * @interface IGuildJoinGuild
         * @property {number|null} [guildId] GuildJoinGuild guildId
         */

        /**
         * Constructs a new GuildJoinGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildJoinGuild.
         * @implements IGuildJoinGuild
         * @constructor
         * @param {msgProto.IGuildJoinGuild=} [properties] Properties to set
         */
        function GuildJoinGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildJoinGuild guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildJoinGuild
         * @instance
         */
        GuildJoinGuild.prototype.guildId = 0;

        /**
         * Encodes the specified GuildJoinGuild message. Does not implicitly {@link msgProto.GuildJoinGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {msgProto.IGuildJoinGuild} message GuildJoinGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildJoinGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildJoinGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildJoinGuild} GuildJoinGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildJoinGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildJoinGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildJoinGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildJoinGuild} GuildJoinGuild
         */
        GuildJoinGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildJoinGuild)
                return object;
            var message = new $root.msgProto.GuildJoinGuild();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildJoinGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {msgProto.GuildJoinGuild} message GuildJoinGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildJoinGuild.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guildId = 0;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildJoinGuild to JSON.
         * @function toJSON
         * @memberof msgProto.GuildJoinGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildJoinGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildJoinGuild;
    })();

    msgProto.GuildGetAppliedMembers = (function() {

        /**
         * Properties of a GuildGetAppliedMembers.
         * @memberof msgProto
         * @interface IGuildGetAppliedMembers
         */

        /**
         * Constructs a new GuildGetAppliedMembers.
         * @memberof msgProto
         * @classdesc Represents a GuildGetAppliedMembers.
         * @implements IGuildGetAppliedMembers
         * @constructor
         * @param {msgProto.IGuildGetAppliedMembers=} [properties] Properties to set
         */
        function GuildGetAppliedMembers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildGetAppliedMembers message. Does not implicitly {@link msgProto.GuildGetAppliedMembers.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {msgProto.IGuildGetAppliedMembers} message GuildGetAppliedMembers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetAppliedMembers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildGetAppliedMembers message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGetAppliedMembers} GuildGetAppliedMembers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetAppliedMembers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGetAppliedMembers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildGetAppliedMembers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildGetAppliedMembers} GuildGetAppliedMembers
         */
        GuildGetAppliedMembers.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildGetAppliedMembers)
                return object;
            return new $root.msgProto.GuildGetAppliedMembers();
        };

        /**
         * Creates a plain object from a GuildGetAppliedMembers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {msgProto.GuildGetAppliedMembers} message GuildGetAppliedMembers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildGetAppliedMembers.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildGetAppliedMembers to JSON.
         * @function toJSON
         * @memberof msgProto.GuildGetAppliedMembers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildGetAppliedMembers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildGetAppliedMembers;
    })();

    msgProto.GuildAppliedMembersSet = (function() {

        /**
         * Properties of a GuildAppliedMembersSet.
         * @memberof msgProto
         * @interface IGuildAppliedMembersSet
         * @property {number|Long|null} [tUserId] GuildAppliedMembersSet tUserId
         * @property {boolean|null} [isConsent] GuildAppliedMembersSet isConsent
         */

        /**
         * Constructs a new GuildAppliedMembersSet.
         * @memberof msgProto
         * @classdesc Represents a GuildAppliedMembersSet.
         * @implements IGuildAppliedMembersSet
         * @constructor
         * @param {msgProto.IGuildAppliedMembersSet=} [properties] Properties to set
         */
        function GuildAppliedMembersSet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildAppliedMembersSet tUserId.
         * @member {number|Long} tUserId
         * @memberof msgProto.GuildAppliedMembersSet
         * @instance
         */
        GuildAppliedMembersSet.prototype.tUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GuildAppliedMembersSet isConsent.
         * @member {boolean} isConsent
         * @memberof msgProto.GuildAppliedMembersSet
         * @instance
         */
        GuildAppliedMembersSet.prototype.isConsent = false;

        /**
         * Encodes the specified GuildAppliedMembersSet message. Does not implicitly {@link msgProto.GuildAppliedMembersSet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {msgProto.IGuildAppliedMembersSet} message GuildAppliedMembersSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildAppliedMembersSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tUserId != null && message.hasOwnProperty("tUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tUserId);
            if (message.isConsent != null && message.hasOwnProperty("isConsent"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isConsent);
            return writer;
        };

        /**
         * Decodes a GuildAppliedMembersSet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildAppliedMembersSet} GuildAppliedMembersSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildAppliedMembersSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildAppliedMembersSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tUserId = reader.uint64();
                    break;
                case 2:
                    message.isConsent = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildAppliedMembersSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildAppliedMembersSet} GuildAppliedMembersSet
         */
        GuildAppliedMembersSet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildAppliedMembersSet)
                return object;
            var message = new $root.msgProto.GuildAppliedMembersSet();
            if (object.tUserId != null)
                if ($util.Long)
                    (message.tUserId = $util.Long.fromValue(object.tUserId)).unsigned = true;
                else if (typeof object.tUserId === "string")
                    message.tUserId = parseInt(object.tUserId, 10);
                else if (typeof object.tUserId === "number")
                    message.tUserId = object.tUserId;
                else if (typeof object.tUserId === "object")
                    message.tUserId = new $util.LongBits(object.tUserId.low >>> 0, object.tUserId.high >>> 0).toNumber(true);
            if (object.isConsent != null)
                message.isConsent = Boolean(object.isConsent);
            return message;
        };

        /**
         * Creates a plain object from a GuildAppliedMembersSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {msgProto.GuildAppliedMembersSet} message GuildAppliedMembersSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildAppliedMembersSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tUserId = options.longs === String ? "0" : 0;
                object.isConsent = false;
            }
            if (message.tUserId != null && message.hasOwnProperty("tUserId"))
                if (typeof message.tUserId === "number")
                    object.tUserId = options.longs === String ? String(message.tUserId) : message.tUserId;
                else
                    object.tUserId = options.longs === String ? $util.Long.prototype.toString.call(message.tUserId) : options.longs === Number ? new $util.LongBits(message.tUserId.low >>> 0, message.tUserId.high >>> 0).toNumber(true) : message.tUserId;
            if (message.isConsent != null && message.hasOwnProperty("isConsent"))
                object.isConsent = message.isConsent;
            return object;
        };

        /**
         * Converts this GuildAppliedMembersSet to JSON.
         * @function toJSON
         * @memberof msgProto.GuildAppliedMembersSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildAppliedMembersSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildAppliedMembersSet;
    })();

    msgProto.GuildGuildSetting = (function() {

        /**
         * Properties of a GuildGuildSetting.
         * @memberof msgProto
         * @interface IGuildGuildSetting
         * @property {string|null} [joinCon] GuildGuildSetting joinCon
         * @property {number|null} [joinLvl] GuildGuildSetting joinLvl
         */

        /**
         * Constructs a new GuildGuildSetting.
         * @memberof msgProto
         * @classdesc Represents a GuildGuildSetting.
         * @implements IGuildGuildSetting
         * @constructor
         * @param {msgProto.IGuildGuildSetting=} [properties] Properties to set
         */
        function GuildGuildSetting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildGuildSetting joinCon.
         * @member {string} joinCon
         * @memberof msgProto.GuildGuildSetting
         * @instance
         */
        GuildGuildSetting.prototype.joinCon = "";

        /**
         * GuildGuildSetting joinLvl.
         * @member {number} joinLvl
         * @memberof msgProto.GuildGuildSetting
         * @instance
         */
        GuildGuildSetting.prototype.joinLvl = 0;

        /**
         * Encodes the specified GuildGuildSetting message. Does not implicitly {@link msgProto.GuildGuildSetting.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {msgProto.IGuildGuildSetting} message GuildGuildSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGuildSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.joinCon != null && message.hasOwnProperty("joinCon"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.joinCon);
            if (message.joinLvl != null && message.hasOwnProperty("joinLvl"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.joinLvl);
            return writer;
        };

        /**
         * Decodes a GuildGuildSetting message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGuildSetting} GuildGuildSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGuildSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGuildSetting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.joinCon = reader.string();
                    break;
                case 2:
                    message.joinLvl = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildGuildSetting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildGuildSetting} GuildGuildSetting
         */
        GuildGuildSetting.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildGuildSetting)
                return object;
            var message = new $root.msgProto.GuildGuildSetting();
            if (object.joinCon != null)
                message.joinCon = String(object.joinCon);
            if (object.joinLvl != null)
                message.joinLvl = object.joinLvl | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildGuildSetting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {msgProto.GuildGuildSetting} message GuildGuildSetting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildGuildSetting.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.joinCon = "";
                object.joinLvl = 0;
            }
            if (message.joinCon != null && message.hasOwnProperty("joinCon"))
                object.joinCon = message.joinCon;
            if (message.joinLvl != null && message.hasOwnProperty("joinLvl"))
                object.joinLvl = message.joinLvl;
            return object;
        };

        /**
         * Converts this GuildGuildSetting to JSON.
         * @function toJSON
         * @memberof msgProto.GuildGuildSetting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildGuildSetting.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildGuildSetting;
    })();

    msgProto.GuildExitGuild = (function() {

        /**
         * Properties of a GuildExitGuild.
         * @memberof msgProto
         * @interface IGuildExitGuild
         */

        /**
         * Constructs a new GuildExitGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildExitGuild.
         * @implements IGuildExitGuild
         * @constructor
         * @param {msgProto.IGuildExitGuild=} [properties] Properties to set
         */
        function GuildExitGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildExitGuild message. Does not implicitly {@link msgProto.GuildExitGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {msgProto.IGuildExitGuild} message GuildExitGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildExitGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildExitGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildExitGuild} GuildExitGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildExitGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildExitGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildExitGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildExitGuild} GuildExitGuild
         */
        GuildExitGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildExitGuild)
                return object;
            return new $root.msgProto.GuildExitGuild();
        };

        /**
         * Creates a plain object from a GuildExitGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {msgProto.GuildExitGuild} message GuildExitGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildExitGuild.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildExitGuild to JSON.
         * @function toJSON
         * @memberof msgProto.GuildExitGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildExitGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildExitGuild;
    })();

    msgProto.GuildSetNotice = (function() {

        /**
         * Properties of a GuildSetNotice.
         * @memberof msgProto
         * @interface IGuildSetNotice
         * @property {string|null} [notice] GuildSetNotice notice
         */

        /**
         * Constructs a new GuildSetNotice.
         * @memberof msgProto
         * @classdesc Represents a GuildSetNotice.
         * @implements IGuildSetNotice
         * @constructor
         * @param {msgProto.IGuildSetNotice=} [properties] Properties to set
         */
        function GuildSetNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSetNotice notice.
         * @member {string} notice
         * @memberof msgProto.GuildSetNotice
         * @instance
         */
        GuildSetNotice.prototype.notice = "";

        /**
         * Encodes the specified GuildSetNotice message. Does not implicitly {@link msgProto.GuildSetNotice.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {msgProto.IGuildSetNotice} message GuildSetNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notice != null && message.hasOwnProperty("notice"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.notice);
            return writer;
        };

        /**
         * Decodes a GuildSetNotice message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSetNotice} GuildSetNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSetNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.notice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildSetNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildSetNotice} GuildSetNotice
         */
        GuildSetNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildSetNotice)
                return object;
            var message = new $root.msgProto.GuildSetNotice();
            if (object.notice != null)
                message.notice = String(object.notice);
            return message;
        };

        /**
         * Creates a plain object from a GuildSetNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {msgProto.GuildSetNotice} message GuildSetNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildSetNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.notice = "";
            if (message.notice != null && message.hasOwnProperty("notice"))
                object.notice = message.notice;
            return object;
        };

        /**
         * Converts this GuildSetNotice to JSON.
         * @function toJSON
         * @memberof msgProto.GuildSetNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildSetNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildSetNotice;
    })();

    msgProto.GuildLottery = (function() {

        /**
         * Properties of a GuildLottery.
         * @memberof msgProto
         * @interface IGuildLottery
         * @property {number|null} [count] GuildLottery count
         */

        /**
         * Constructs a new GuildLottery.
         * @memberof msgProto
         * @classdesc Represents a GuildLottery.
         * @implements IGuildLottery
         * @constructor
         * @param {msgProto.IGuildLottery=} [properties] Properties to set
         */
        function GuildLottery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildLottery count.
         * @member {number} count
         * @memberof msgProto.GuildLottery
         * @instance
         */
        GuildLottery.prototype.count = 0;

        /**
         * Encodes the specified GuildLottery message. Does not implicitly {@link msgProto.GuildLottery.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildLottery
         * @static
         * @param {msgProto.IGuildLottery} message GuildLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildLottery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Decodes a GuildLottery message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildLottery} GuildLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildLottery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildLottery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildLottery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildLottery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildLottery} GuildLottery
         */
        GuildLottery.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildLottery)
                return object;
            var message = new $root.msgProto.GuildLottery();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildLottery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildLottery
         * @static
         * @param {msgProto.GuildLottery} message GuildLottery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildLottery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this GuildLottery to JSON.
         * @function toJSON
         * @memberof msgProto.GuildLottery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildLottery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildLottery;
    })();

    msgProto.GuildSetEnnoble = (function() {

        /**
         * Properties of a GuildSetEnnoble.
         * @memberof msgProto
         * @interface IGuildSetEnnoble
         * @property {number|null} [targetUserId] GuildSetEnnoble targetUserId
         * @property {number|null} [ennobleType] GuildSetEnnoble ennobleType
         */

        /**
         * Constructs a new GuildSetEnnoble.
         * @memberof msgProto
         * @classdesc Represents a GuildSetEnnoble.
         * @implements IGuildSetEnnoble
         * @constructor
         * @param {msgProto.IGuildSetEnnoble=} [properties] Properties to set
         */
        function GuildSetEnnoble(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSetEnnoble targetUserId.
         * @member {number} targetUserId
         * @memberof msgProto.GuildSetEnnoble
         * @instance
         */
        GuildSetEnnoble.prototype.targetUserId = 0;

        /**
         * GuildSetEnnoble ennobleType.
         * @member {number} ennobleType
         * @memberof msgProto.GuildSetEnnoble
         * @instance
         */
        GuildSetEnnoble.prototype.ennobleType = 0;

        /**
         * Encodes the specified GuildSetEnnoble message. Does not implicitly {@link msgProto.GuildSetEnnoble.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {msgProto.IGuildSetEnnoble} message GuildSetEnnoble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetEnnoble.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.targetUserId);
            if (message.ennobleType != null && message.hasOwnProperty("ennobleType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ennobleType);
            return writer;
        };

        /**
         * Decodes a GuildSetEnnoble message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSetEnnoble} GuildSetEnnoble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetEnnoble.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSetEnnoble();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetUserId = reader.uint32();
                    break;
                case 2:
                    message.ennobleType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildSetEnnoble message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildSetEnnoble} GuildSetEnnoble
         */
        GuildSetEnnoble.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildSetEnnoble)
                return object;
            var message = new $root.msgProto.GuildSetEnnoble();
            if (object.targetUserId != null)
                message.targetUserId = object.targetUserId >>> 0;
            if (object.ennobleType != null)
                message.ennobleType = object.ennobleType | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildSetEnnoble message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {msgProto.GuildSetEnnoble} message GuildSetEnnoble
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildSetEnnoble.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.targetUserId = 0;
                object.ennobleType = 0;
            }
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                object.targetUserId = message.targetUserId;
            if (message.ennobleType != null && message.hasOwnProperty("ennobleType"))
                object.ennobleType = message.ennobleType;
            return object;
        };

        /**
         * Converts this GuildSetEnnoble to JSON.
         * @function toJSON
         * @memberof msgProto.GuildSetEnnoble
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildSetEnnoble.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildSetEnnoble;
    })();

    msgProto.GuildPersonPickAct = (function() {

        /**
         * Properties of a GuildPersonPickAct.
         * @memberof msgProto
         * @interface IGuildPersonPickAct
         * @property {number|null} [actId] GuildPersonPickAct actId
         */

        /**
         * Constructs a new GuildPersonPickAct.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonPickAct.
         * @implements IGuildPersonPickAct
         * @constructor
         * @param {msgProto.IGuildPersonPickAct=} [properties] Properties to set
         */
        function GuildPersonPickAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildPersonPickAct actId.
         * @member {number} actId
         * @memberof msgProto.GuildPersonPickAct
         * @instance
         */
        GuildPersonPickAct.prototype.actId = 0;

        /**
         * Encodes the specified GuildPersonPickAct message. Does not implicitly {@link msgProto.GuildPersonPickAct.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {msgProto.IGuildPersonPickAct} message GuildPersonPickAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonPickAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actId != null && message.hasOwnProperty("actId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.actId);
            return writer;
        };

        /**
         * Decodes a GuildPersonPickAct message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonPickAct} GuildPersonPickAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonPickAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonPickAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildPersonPickAct message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildPersonPickAct} GuildPersonPickAct
         */
        GuildPersonPickAct.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildPersonPickAct)
                return object;
            var message = new $root.msgProto.GuildPersonPickAct();
            if (object.actId != null)
                message.actId = object.actId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildPersonPickAct message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {msgProto.GuildPersonPickAct} message GuildPersonPickAct
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildPersonPickAct.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.actId = 0;
            if (message.actId != null && message.hasOwnProperty("actId"))
                object.actId = message.actId;
            return object;
        };

        /**
         * Converts this GuildPersonPickAct to JSON.
         * @function toJSON
         * @memberof msgProto.GuildPersonPickAct
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildPersonPickAct.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildPersonPickAct;
    })();

    msgProto.GuildPersonGetMemberList = (function() {

        /**
         * Properties of a GuildPersonGetMemberList.
         * @memberof msgProto
         * @interface IGuildPersonGetMemberList
         */

        /**
         * Constructs a new GuildPersonGetMemberList.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonGetMemberList.
         * @implements IGuildPersonGetMemberList
         * @constructor
         * @param {msgProto.IGuildPersonGetMemberList=} [properties] Properties to set
         */
        function GuildPersonGetMemberList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildPersonGetMemberList message. Does not implicitly {@link msgProto.GuildPersonGetMemberList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {msgProto.IGuildPersonGetMemberList} message GuildPersonGetMemberList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonGetMemberList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildPersonGetMemberList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonGetMemberList} GuildPersonGetMemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonGetMemberList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonGetMemberList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildPersonGetMemberList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildPersonGetMemberList} GuildPersonGetMemberList
         */
        GuildPersonGetMemberList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildPersonGetMemberList)
                return object;
            return new $root.msgProto.GuildPersonGetMemberList();
        };

        /**
         * Creates a plain object from a GuildPersonGetMemberList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {msgProto.GuildPersonGetMemberList} message GuildPersonGetMemberList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildPersonGetMemberList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildPersonGetMemberList to JSON.
         * @function toJSON
         * @memberof msgProto.GuildPersonGetMemberList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildPersonGetMemberList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildPersonGetMemberList;
    })();

    msgProto.GuildPersonOpMember = (function() {

        /**
         * Properties of a GuildPersonOpMember.
         * @memberof msgProto
         * @interface IGuildPersonOpMember
         * @property {number|Long|null} [targetUserId] GuildPersonOpMember targetUserId
         * @property {number|null} [op] GuildPersonOpMember op
         */

        /**
         * Constructs a new GuildPersonOpMember.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonOpMember.
         * @implements IGuildPersonOpMember
         * @constructor
         * @param {msgProto.IGuildPersonOpMember=} [properties] Properties to set
         */
        function GuildPersonOpMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildPersonOpMember targetUserId.
         * @member {number|Long} targetUserId
         * @memberof msgProto.GuildPersonOpMember
         * @instance
         */
        GuildPersonOpMember.prototype.targetUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GuildPersonOpMember op.
         * @member {number} op
         * @memberof msgProto.GuildPersonOpMember
         * @instance
         */
        GuildPersonOpMember.prototype.op = 0;

        /**
         * Encodes the specified GuildPersonOpMember message. Does not implicitly {@link msgProto.GuildPersonOpMember.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {msgProto.IGuildPersonOpMember} message GuildPersonOpMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonOpMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.targetUserId);
            if (message.op != null && message.hasOwnProperty("op"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            return writer;
        };

        /**
         * Decodes a GuildPersonOpMember message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonOpMember} GuildPersonOpMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonOpMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonOpMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetUserId = reader.uint64();
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildPersonOpMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildPersonOpMember} GuildPersonOpMember
         */
        GuildPersonOpMember.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildPersonOpMember)
                return object;
            var message = new $root.msgProto.GuildPersonOpMember();
            if (object.targetUserId != null)
                if ($util.Long)
                    (message.targetUserId = $util.Long.fromValue(object.targetUserId)).unsigned = true;
                else if (typeof object.targetUserId === "string")
                    message.targetUserId = parseInt(object.targetUserId, 10);
                else if (typeof object.targetUserId === "number")
                    message.targetUserId = object.targetUserId;
                else if (typeof object.targetUserId === "object")
                    message.targetUserId = new $util.LongBits(object.targetUserId.low >>> 0, object.targetUserId.high >>> 0).toNumber(true);
            if (object.op != null)
                message.op = object.op | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildPersonOpMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {msgProto.GuildPersonOpMember} message GuildPersonOpMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildPersonOpMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.targetUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.targetUserId = options.longs === String ? "0" : 0;
                object.op = 0;
            }
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                if (typeof message.targetUserId === "number")
                    object.targetUserId = options.longs === String ? String(message.targetUserId) : message.targetUserId;
                else
                    object.targetUserId = options.longs === String ? $util.Long.prototype.toString.call(message.targetUserId) : options.longs === Number ? new $util.LongBits(message.targetUserId.low >>> 0, message.targetUserId.high >>> 0).toNumber(true) : message.targetUserId;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            return object;
        };

        /**
         * Converts this GuildPersonOpMember to JSON.
         * @function toJSON
         * @memberof msgProto.GuildPersonOpMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildPersonOpMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildPersonOpMember;
    })();

    msgProto.GuildWarGetInfo = (function() {

        /**
         * Properties of a GuildWarGetInfo.
         * @memberof msgProto
         * @interface IGuildWarGetInfo
         */

        /**
         * Constructs a new GuildWarGetInfo.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetInfo.
         * @implements IGuildWarGetInfo
         * @constructor
         * @param {msgProto.IGuildWarGetInfo=} [properties] Properties to set
         */
        function GuildWarGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarGetInfo message. Does not implicitly {@link msgProto.GuildWarGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {msgProto.IGuildWarGetInfo} message GuildWarGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetInfo} GuildWarGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetInfo} GuildWarGetInfo
         */
        GuildWarGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetInfo)
                return object;
            return new $root.msgProto.GuildWarGetInfo();
        };

        /**
         * Creates a plain object from a GuildWarGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {msgProto.GuildWarGetInfo} message GuildWarGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetInfo;
    })();

    msgProto.GuildWarGetGuildList = (function() {

        /**
         * Properties of a GuildWarGetGuildList.
         * @memberof msgProto
         * @interface IGuildWarGetGuildList
         * @property {number|null} [guildId] GuildWarGetGuildList guildId
         */

        /**
         * Constructs a new GuildWarGetGuildList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetGuildList.
         * @implements IGuildWarGetGuildList
         * @constructor
         * @param {msgProto.IGuildWarGetGuildList=} [properties] Properties to set
         */
        function GuildWarGetGuildList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetGuildList guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetGuildList
         * @instance
         */
        GuildWarGetGuildList.prototype.guildId = 0;

        /**
         * Encodes the specified GuildWarGetGuildList message. Does not implicitly {@link msgProto.GuildWarGetGuildList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {msgProto.IGuildWarGetGuildList} message GuildWarGetGuildList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildWarGetGuildList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetGuildList} GuildWarGetGuildList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetGuildList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetGuildList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetGuildList} GuildWarGetGuildList
         */
        GuildWarGetGuildList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetGuildList)
                return object;
            var message = new $root.msgProto.GuildWarGetGuildList();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarGetGuildList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {msgProto.GuildWarGetGuildList} message GuildWarGetGuildList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetGuildList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guildId = 0;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildWarGetGuildList to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetGuildList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetGuildList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetGuildList;
    })();

    msgProto.GuildWarGetWarAttackData = (function() {

        /**
         * Properties of a GuildWarGetWarAttackData.
         * @memberof msgProto
         * @interface IGuildWarGetWarAttackData
         * @property {number|null} [serverId] GuildWarGetWarAttackData serverId
         * @property {number|null} [guildId] GuildWarGetWarAttackData guildId
         */

        /**
         * Constructs a new GuildWarGetWarAttackData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetWarAttackData.
         * @implements IGuildWarGetWarAttackData
         * @constructor
         * @param {msgProto.IGuildWarGetWarAttackData=} [properties] Properties to set
         */
        function GuildWarGetWarAttackData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetWarAttackData serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarGetWarAttackData
         * @instance
         */
        GuildWarGetWarAttackData.prototype.serverId = 0;

        /**
         * GuildWarGetWarAttackData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetWarAttackData
         * @instance
         */
        GuildWarGetWarAttackData.prototype.guildId = 0;

        /**
         * Encodes the specified GuildWarGetWarAttackData message. Does not implicitly {@link msgProto.GuildWarGetWarAttackData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {msgProto.IGuildWarGetWarAttackData} message GuildWarGetWarAttackData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarAttackData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildWarGetWarAttackData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetWarAttackData} GuildWarGetWarAttackData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarAttackData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetWarAttackData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetWarAttackData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetWarAttackData} GuildWarGetWarAttackData
         */
        GuildWarGetWarAttackData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetWarAttackData)
                return object;
            var message = new $root.msgProto.GuildWarGetWarAttackData();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarGetWarAttackData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {msgProto.GuildWarGetWarAttackData} message GuildWarGetWarAttackData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetWarAttackData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverId = 0;
                object.guildId = 0;
            }
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildWarGetWarAttackData to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetWarAttackData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetWarAttackData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetWarAttackData;
    })();

    msgProto.GuildWarGetWarDefenceData = (function() {

        /**
         * Properties of a GuildWarGetWarDefenceData.
         * @memberof msgProto
         * @interface IGuildWarGetWarDefenceData
         * @property {number|null} [guildId] GuildWarGetWarDefenceData guildId
         */

        /**
         * Constructs a new GuildWarGetWarDefenceData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetWarDefenceData.
         * @implements IGuildWarGetWarDefenceData
         * @constructor
         * @param {msgProto.IGuildWarGetWarDefenceData=} [properties] Properties to set
         */
        function GuildWarGetWarDefenceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetWarDefenceData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @instance
         */
        GuildWarGetWarDefenceData.prototype.guildId = 0;

        /**
         * Encodes the specified GuildWarGetWarDefenceData message. Does not implicitly {@link msgProto.GuildWarGetWarDefenceData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {msgProto.IGuildWarGetWarDefenceData} message GuildWarGetWarDefenceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarDefenceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildWarGetWarDefenceData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetWarDefenceData} GuildWarGetWarDefenceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarDefenceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetWarDefenceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetWarDefenceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetWarDefenceData} GuildWarGetWarDefenceData
         */
        GuildWarGetWarDefenceData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetWarDefenceData)
                return object;
            var message = new $root.msgProto.GuildWarGetWarDefenceData();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarGetWarDefenceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {msgProto.GuildWarGetWarDefenceData} message GuildWarGetWarDefenceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetWarDefenceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guildId = 0;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildWarGetWarDefenceData to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetWarDefenceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetWarDefenceData;
    })();

    msgProto.GuildWarGetDefenceRecordList = (function() {

        /**
         * Properties of a GuildWarGetDefenceRecordList.
         * @memberof msgProto
         * @interface IGuildWarGetDefenceRecordList
         */

        /**
         * Constructs a new GuildWarGetDefenceRecordList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetDefenceRecordList.
         * @implements IGuildWarGetDefenceRecordList
         * @constructor
         * @param {msgProto.IGuildWarGetDefenceRecordList=} [properties] Properties to set
         */
        function GuildWarGetDefenceRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarGetDefenceRecordList message. Does not implicitly {@link msgProto.GuildWarGetDefenceRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {msgProto.IGuildWarGetDefenceRecordList} message GuildWarGetDefenceRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetDefenceRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarGetDefenceRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetDefenceRecordList} GuildWarGetDefenceRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetDefenceRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetDefenceRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetDefenceRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetDefenceRecordList} GuildWarGetDefenceRecordList
         */
        GuildWarGetDefenceRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetDefenceRecordList)
                return object;
            return new $root.msgProto.GuildWarGetDefenceRecordList();
        };

        /**
         * Creates a plain object from a GuildWarGetDefenceRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {msgProto.GuildWarGetDefenceRecordList} message GuildWarGetDefenceRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetDefenceRecordList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarGetDefenceRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetDefenceRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetDefenceRecordList;
    })();

    msgProto.GuildWarGetAttackRecordList = (function() {

        /**
         * Properties of a GuildWarGetAttackRecordList.
         * @memberof msgProto
         * @interface IGuildWarGetAttackRecordList
         */

        /**
         * Constructs a new GuildWarGetAttackRecordList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetAttackRecordList.
         * @implements IGuildWarGetAttackRecordList
         * @constructor
         * @param {msgProto.IGuildWarGetAttackRecordList=} [properties] Properties to set
         */
        function GuildWarGetAttackRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarGetAttackRecordList message. Does not implicitly {@link msgProto.GuildWarGetAttackRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {msgProto.IGuildWarGetAttackRecordList} message GuildWarGetAttackRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetAttackRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarGetAttackRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetAttackRecordList} GuildWarGetAttackRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetAttackRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetAttackRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetAttackRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetAttackRecordList} GuildWarGetAttackRecordList
         */
        GuildWarGetAttackRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetAttackRecordList)
                return object;
            return new $root.msgProto.GuildWarGetAttackRecordList();
        };

        /**
         * Creates a plain object from a GuildWarGetAttackRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {msgProto.GuildWarGetAttackRecordList} message GuildWarGetAttackRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetAttackRecordList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarGetAttackRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetAttackRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetAttackRecordList;
    })();

    msgProto.GuildWarGetGuildWarAllRank = (function() {

        /**
         * Properties of a GuildWarGetGuildWarAllRank.
         * @memberof msgProto
         * @interface IGuildWarGetGuildWarAllRank
         */

        /**
         * Constructs a new GuildWarGetGuildWarAllRank.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetGuildWarAllRank.
         * @implements IGuildWarGetGuildWarAllRank
         * @constructor
         * @param {msgProto.IGuildWarGetGuildWarAllRank=} [properties] Properties to set
         */
        function GuildWarGetGuildWarAllRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarGetGuildWarAllRank message. Does not implicitly {@link msgProto.GuildWarGetGuildWarAllRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {msgProto.IGuildWarGetGuildWarAllRank} message GuildWarGetGuildWarAllRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildWarAllRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarGetGuildWarAllRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetGuildWarAllRank} GuildWarGetGuildWarAllRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildWarAllRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetGuildWarAllRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetGuildWarAllRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetGuildWarAllRank} GuildWarGetGuildWarAllRank
         */
        GuildWarGetGuildWarAllRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetGuildWarAllRank)
                return object;
            return new $root.msgProto.GuildWarGetGuildWarAllRank();
        };

        /**
         * Creates a plain object from a GuildWarGetGuildWarAllRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {msgProto.GuildWarGetGuildWarAllRank} message GuildWarGetGuildWarAllRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetGuildWarAllRank.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarGetGuildWarAllRank to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetGuildWarAllRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetGuildWarAllRank;
    })();

    msgProto.GuildWarGetLastRankList = (function() {

        /**
         * Properties of a GuildWarGetLastRankList.
         * @memberof msgProto
         * @interface IGuildWarGetLastRankList
         * @property {number|null} [groupId] GuildWarGetLastRankList groupId
         */

        /**
         * Constructs a new GuildWarGetLastRankList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetLastRankList.
         * @implements IGuildWarGetLastRankList
         * @constructor
         * @param {msgProto.IGuildWarGetLastRankList=} [properties] Properties to set
         */
        function GuildWarGetLastRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetLastRankList groupId.
         * @member {number} groupId
         * @memberof msgProto.GuildWarGetLastRankList
         * @instance
         */
        GuildWarGetLastRankList.prototype.groupId = 0;

        /**
         * Encodes the specified GuildWarGetLastRankList message. Does not implicitly {@link msgProto.GuildWarGetLastRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {msgProto.IGuildWarGetLastRankList} message GuildWarGetLastRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetLastRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupId);
            return writer;
        };

        /**
         * Decodes a GuildWarGetLastRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetLastRankList} GuildWarGetLastRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetLastRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetLastRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetLastRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetLastRankList} GuildWarGetLastRankList
         */
        GuildWarGetLastRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetLastRankList)
                return object;
            var message = new $root.msgProto.GuildWarGetLastRankList();
            if (object.groupId != null)
                message.groupId = object.groupId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarGetLastRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {msgProto.GuildWarGetLastRankList} message GuildWarGetLastRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetLastRankList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.groupId = 0;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            return object;
        };

        /**
         * Converts this GuildWarGetLastRankList to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetLastRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetLastRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetLastRankList;
    })();

    msgProto.GuildWarGetSignUpData = (function() {

        /**
         * Properties of a GuildWarGetSignUpData.
         * @memberof msgProto
         * @interface IGuildWarGetSignUpData
         * @property {number|null} [guildId] GuildWarGetSignUpData guildId
         */

        /**
         * Constructs a new GuildWarGetSignUpData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetSignUpData.
         * @implements IGuildWarGetSignUpData
         * @constructor
         * @param {msgProto.IGuildWarGetSignUpData=} [properties] Properties to set
         */
        function GuildWarGetSignUpData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetSignUpData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetSignUpData
         * @instance
         */
        GuildWarGetSignUpData.prototype.guildId = 0;

        /**
         * Encodes the specified GuildWarGetSignUpData message. Does not implicitly {@link msgProto.GuildWarGetSignUpData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {msgProto.IGuildWarGetSignUpData} message GuildWarGetSignUpData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetSignUpData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Decodes a GuildWarGetSignUpData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetSignUpData} GuildWarGetSignUpData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetSignUpData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetSignUpData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarGetSignUpData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarGetSignUpData} GuildWarGetSignUpData
         */
        GuildWarGetSignUpData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarGetSignUpData)
                return object;
            var message = new $root.msgProto.GuildWarGetSignUpData();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarGetSignUpData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {msgProto.GuildWarGetSignUpData} message GuildWarGetSignUpData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarGetSignUpData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.guildId = 0;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            return object;
        };

        /**
         * Converts this GuildWarGetSignUpData to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarGetSignUpData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarGetSignUpData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarGetSignUpData;
    })();

    msgProto.GuildWarSignUp = (function() {

        /**
         * Properties of a GuildWarSignUp.
         * @memberof msgProto
         * @interface IGuildWarSignUp
         * @property {number|null} [groupId] GuildWarSignUp groupId
         */

        /**
         * Constructs a new GuildWarSignUp.
         * @memberof msgProto
         * @classdesc Represents a GuildWarSignUp.
         * @implements IGuildWarSignUp
         * @constructor
         * @param {msgProto.IGuildWarSignUp=} [properties] Properties to set
         */
        function GuildWarSignUp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarSignUp groupId.
         * @member {number} groupId
         * @memberof msgProto.GuildWarSignUp
         * @instance
         */
        GuildWarSignUp.prototype.groupId = 0;

        /**
         * Encodes the specified GuildWarSignUp message. Does not implicitly {@link msgProto.GuildWarSignUp.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {msgProto.IGuildWarSignUp} message GuildWarSignUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSignUp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupId);
            return writer;
        };

        /**
         * Decodes a GuildWarSignUp message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarSignUp} GuildWarSignUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSignUp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarSignUp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarSignUp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarSignUp} GuildWarSignUp
         */
        GuildWarSignUp.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarSignUp)
                return object;
            var message = new $root.msgProto.GuildWarSignUp();
            if (object.groupId != null)
                message.groupId = object.groupId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarSignUp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {msgProto.GuildWarSignUp} message GuildWarSignUp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarSignUp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.groupId = 0;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            return object;
        };

        /**
         * Converts this GuildWarSignUp to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarSignUp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarSignUp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarSignUp;
    })();

    msgProto.GuildWarFightStartDoor = (function() {

        /**
         * Properties of a GuildWarFightStartDoor.
         * @memberof msgProto
         * @interface IGuildWarFightStartDoor
         * @property {number|null} [serverId] GuildWarFightStartDoor serverId
         * @property {number|null} [guildId] GuildWarFightStartDoor guildId
         * @property {number|null} [door] GuildWarFightStartDoor door
         */

        /**
         * Constructs a new GuildWarFightStartDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarFightStartDoor.
         * @implements IGuildWarFightStartDoor
         * @constructor
         * @param {msgProto.IGuildWarFightStartDoor=} [properties] Properties to set
         */
        function GuildWarFightStartDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarFightStartDoor serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.serverId = 0;

        /**
         * GuildWarFightStartDoor guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.guildId = 0;

        /**
         * GuildWarFightStartDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.door = 0;

        /**
         * Encodes the specified GuildWarFightStartDoor message. Does not implicitly {@link msgProto.GuildWarFightStartDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {msgProto.IGuildWarFightStartDoor} message GuildWarFightStartDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightStartDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.door);
            return writer;
        };

        /**
         * Decodes a GuildWarFightStartDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarFightStartDoor} GuildWarFightStartDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightStartDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarFightStartDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarFightStartDoor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarFightStartDoor} GuildWarFightStartDoor
         */
        GuildWarFightStartDoor.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarFightStartDoor)
                return object;
            var message = new $root.msgProto.GuildWarFightStartDoor();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            if (object.door != null)
                message.door = object.door | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarFightStartDoor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {msgProto.GuildWarFightStartDoor} message GuildWarFightStartDoor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarFightStartDoor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverId = 0;
                object.guildId = 0;
                object.door = 0;
            }
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            return object;
        };

        /**
         * Converts this GuildWarFightStartDoor to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarFightStartDoor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarFightStartDoor;
    })();

    msgProto.GuildWarFightEndDoor = (function() {

        /**
         * Properties of a GuildWarFightEndDoor.
         * @memberof msgProto
         * @interface IGuildWarFightEndDoor
         * @property {number|null} [serverId] GuildWarFightEndDoor serverId
         * @property {number|null} [guildId] GuildWarFightEndDoor guildId
         * @property {number|null} [door] GuildWarFightEndDoor door
         * @property {boolean|null} [isWin] GuildWarFightEndDoor isWin
         */

        /**
         * Constructs a new GuildWarFightEndDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarFightEndDoor.
         * @implements IGuildWarFightEndDoor
         * @constructor
         * @param {msgProto.IGuildWarFightEndDoor=} [properties] Properties to set
         */
        function GuildWarFightEndDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarFightEndDoor serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.serverId = 0;

        /**
         * GuildWarFightEndDoor guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.guildId = 0;

        /**
         * GuildWarFightEndDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.door = 0;

        /**
         * GuildWarFightEndDoor isWin.
         * @member {boolean} isWin
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.isWin = false;

        /**
         * Encodes the specified GuildWarFightEndDoor message. Does not implicitly {@link msgProto.GuildWarFightEndDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {msgProto.IGuildWarFightEndDoor} message GuildWarFightEndDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightEndDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.door);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isWin);
            return writer;
        };

        /**
         * Decodes a GuildWarFightEndDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarFightEndDoor} GuildWarFightEndDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightEndDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarFightEndDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.door = reader.int32();
                    break;
                case 4:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarFightEndDoor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarFightEndDoor} GuildWarFightEndDoor
         */
        GuildWarFightEndDoor.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarFightEndDoor)
                return object;
            var message = new $root.msgProto.GuildWarFightEndDoor();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            if (object.door != null)
                message.door = object.door | 0;
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            return message;
        };

        /**
         * Creates a plain object from a GuildWarFightEndDoor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {msgProto.GuildWarFightEndDoor} message GuildWarFightEndDoor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarFightEndDoor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverId = 0;
                object.guildId = 0;
                object.door = 0;
                object.isWin = false;
            }
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            return object;
        };

        /**
         * Converts this GuildWarFightEndDoor to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarFightEndDoor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarFightEndDoor;
    })();

    msgProto.GuildWarUpDoor = (function() {

        /**
         * Properties of a GuildWarUpDoor.
         * @memberof msgProto
         * @interface IGuildWarUpDoor
         * @property {number|null} [door] GuildWarUpDoor door
         */

        /**
         * Constructs a new GuildWarUpDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarUpDoor.
         * @implements IGuildWarUpDoor
         * @constructor
         * @param {msgProto.IGuildWarUpDoor=} [properties] Properties to set
         */
        function GuildWarUpDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarUpDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarUpDoor
         * @instance
         */
        GuildWarUpDoor.prototype.door = 0;

        /**
         * Encodes the specified GuildWarUpDoor message. Does not implicitly {@link msgProto.GuildWarUpDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {msgProto.IGuildWarUpDoor} message GuildWarUpDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarUpDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.door);
            return writer;
        };

        /**
         * Decodes a GuildWarUpDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarUpDoor} GuildWarUpDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarUpDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarUpDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarUpDoor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarUpDoor} GuildWarUpDoor
         */
        GuildWarUpDoor.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarUpDoor)
                return object;
            var message = new $root.msgProto.GuildWarUpDoor();
            if (object.door != null)
                message.door = object.door | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarUpDoor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {msgProto.GuildWarUpDoor} message GuildWarUpDoor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarUpDoor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.door = 0;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            return object;
        };

        /**
         * Converts this GuildWarUpDoor to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarUpDoor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarUpDoor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarUpDoor;
    })();

    msgProto.GuildWarDownDoor = (function() {

        /**
         * Properties of a GuildWarDownDoor.
         * @memberof msgProto
         * @interface IGuildWarDownDoor
         * @property {number|null} [door] GuildWarDownDoor door
         */

        /**
         * Constructs a new GuildWarDownDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarDownDoor.
         * @implements IGuildWarDownDoor
         * @constructor
         * @param {msgProto.IGuildWarDownDoor=} [properties] Properties to set
         */
        function GuildWarDownDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarDownDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarDownDoor
         * @instance
         */
        GuildWarDownDoor.prototype.door = 0;

        /**
         * Encodes the specified GuildWarDownDoor message. Does not implicitly {@link msgProto.GuildWarDownDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {msgProto.IGuildWarDownDoor} message GuildWarDownDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarDownDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.door);
            return writer;
        };

        /**
         * Decodes a GuildWarDownDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarDownDoor} GuildWarDownDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarDownDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarDownDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarDownDoor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarDownDoor} GuildWarDownDoor
         */
        GuildWarDownDoor.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarDownDoor)
                return object;
            var message = new $root.msgProto.GuildWarDownDoor();
            if (object.door != null)
                message.door = object.door | 0;
            return message;
        };

        /**
         * Creates a plain object from a GuildWarDownDoor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {msgProto.GuildWarDownDoor} message GuildWarDownDoor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarDownDoor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.door = 0;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            return object;
        };

        /**
         * Converts this GuildWarDownDoor to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarDownDoor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarDownDoor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarDownDoor;
    })();

    msgProto.GuildWarEnter = (function() {

        /**
         * Properties of a GuildWarEnter.
         * @memberof msgProto
         * @interface IGuildWarEnter
         */

        /**
         * Constructs a new GuildWarEnter.
         * @memberof msgProto
         * @classdesc Represents a GuildWarEnter.
         * @implements IGuildWarEnter
         * @constructor
         * @param {msgProto.IGuildWarEnter=} [properties] Properties to set
         */
        function GuildWarEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarEnter message. Does not implicitly {@link msgProto.GuildWarEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {msgProto.IGuildWarEnter} message GuildWarEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarEnter} GuildWarEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarEnter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarEnter} GuildWarEnter
         */
        GuildWarEnter.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarEnter)
                return object;
            return new $root.msgProto.GuildWarEnter();
        };

        /**
         * Creates a plain object from a GuildWarEnter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {msgProto.GuildWarEnter} message GuildWarEnter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarEnter.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarEnter to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarEnter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarEnter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarEnter;
    })();

    msgProto.GuildWarClearCd = (function() {

        /**
         * Properties of a GuildWarClearCd.
         * @memberof msgProto
         * @interface IGuildWarClearCd
         */

        /**
         * Constructs a new GuildWarClearCd.
         * @memberof msgProto
         * @classdesc Represents a GuildWarClearCd.
         * @implements IGuildWarClearCd
         * @constructor
         * @param {msgProto.IGuildWarClearCd=} [properties] Properties to set
         */
        function GuildWarClearCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarClearCd message. Does not implicitly {@link msgProto.GuildWarClearCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {msgProto.IGuildWarClearCd} message GuildWarClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarClearCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarClearCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarClearCd} GuildWarClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarClearCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarClearCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarClearCd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarClearCd} GuildWarClearCd
         */
        GuildWarClearCd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarClearCd)
                return object;
            return new $root.msgProto.GuildWarClearCd();
        };

        /**
         * Creates a plain object from a GuildWarClearCd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {msgProto.GuildWarClearCd} message GuildWarClearCd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarClearCd.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarClearCd to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarClearCd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarClearCd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarClearCd;
    })();

    msgProto.GuildWarInspire = (function() {

        /**
         * Properties of a GuildWarInspire.
         * @memberof msgProto
         * @interface IGuildWarInspire
         */

        /**
         * Constructs a new GuildWarInspire.
         * @memberof msgProto
         * @classdesc Represents a GuildWarInspire.
         * @implements IGuildWarInspire
         * @constructor
         * @param {msgProto.IGuildWarInspire=} [properties] Properties to set
         */
        function GuildWarInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified GuildWarInspire message. Does not implicitly {@link msgProto.GuildWarInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {msgProto.IGuildWarInspire} message GuildWarInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a GuildWarInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarInspire} GuildWarInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarInspire message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarInspire} GuildWarInspire
         */
        GuildWarInspire.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarInspire)
                return object;
            return new $root.msgProto.GuildWarInspire();
        };

        /**
         * Creates a plain object from a GuildWarInspire message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {msgProto.GuildWarInspire} message GuildWarInspire
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarInspire.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GuildWarInspire to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarInspire
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarInspire.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarInspire;
    })();

    msgProto.GuildWarSyncData = (function() {

        /**
         * Properties of a GuildWarSyncData.
         * @memberof msgProto
         * @interface IGuildWarSyncData
         * @property {number|null} [sceneType] GuildWarSyncData sceneType
         * @property {string|null} [attackData] GuildWarSyncData attackData
         */

        /**
         * Constructs a new GuildWarSyncData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarSyncData.
         * @implements IGuildWarSyncData
         * @constructor
         * @param {msgProto.IGuildWarSyncData=} [properties] Properties to set
         */
        function GuildWarSyncData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarSyncData sceneType.
         * @member {number} sceneType
         * @memberof msgProto.GuildWarSyncData
         * @instance
         */
        GuildWarSyncData.prototype.sceneType = 0;

        /**
         * GuildWarSyncData attackData.
         * @member {string} attackData
         * @memberof msgProto.GuildWarSyncData
         * @instance
         */
        GuildWarSyncData.prototype.attackData = "";

        /**
         * Encodes the specified GuildWarSyncData message. Does not implicitly {@link msgProto.GuildWarSyncData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {msgProto.IGuildWarSyncData} message GuildWarSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSyncData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sceneType != null && message.hasOwnProperty("sceneType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sceneType);
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.attackData);
            return writer;
        };

        /**
         * Decodes a GuildWarSyncData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarSyncData} GuildWarSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSyncData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarSyncData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sceneType = reader.int32();
                    break;
                case 2:
                    message.attackData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GuildWarSyncData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GuildWarSyncData} GuildWarSyncData
         */
        GuildWarSyncData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GuildWarSyncData)
                return object;
            var message = new $root.msgProto.GuildWarSyncData();
            if (object.sceneType != null)
                message.sceneType = object.sceneType | 0;
            if (object.attackData != null)
                message.attackData = String(object.attackData);
            return message;
        };

        /**
         * Creates a plain object from a GuildWarSyncData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {msgProto.GuildWarSyncData} message GuildWarSyncData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GuildWarSyncData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sceneType = 0;
                object.attackData = "";
            }
            if (message.sceneType != null && message.hasOwnProperty("sceneType"))
                object.sceneType = message.sceneType;
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                object.attackData = message.attackData;
            return object;
        };

        /**
         * Converts this GuildWarSyncData to JSON.
         * @function toJSON
         * @memberof msgProto.GuildWarSyncData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GuildWarSyncData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GuildWarSyncData;
    })();

    msgProto.HonorGetInfo = (function() {

        /**
         * Properties of an HonorGetInfo.
         * @memberof msgProto
         * @interface IHonorGetInfo
         */

        /**
         * Constructs a new HonorGetInfo.
         * @memberof msgProto
         * @classdesc Represents an HonorGetInfo.
         * @implements IHonorGetInfo
         * @constructor
         * @param {msgProto.IHonorGetInfo=} [properties] Properties to set
         */
        function HonorGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified HonorGetInfo message. Does not implicitly {@link msgProto.HonorGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {msgProto.IHonorGetInfo} message HonorGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an HonorGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorGetInfo} HonorGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an HonorGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HonorGetInfo} HonorGetInfo
         */
        HonorGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HonorGetInfo)
                return object;
            return new $root.msgProto.HonorGetInfo();
        };

        /**
         * Creates a plain object from an HonorGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {msgProto.HonorGetInfo} message HonorGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HonorGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HonorGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.HonorGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HonorGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HonorGetInfo;
    })();

    msgProto.HonorGetAward = (function() {

        /**
         * Properties of an HonorGetAward.
         * @memberof msgProto
         * @interface IHonorGetAward
         * @property {number|null} [honorId] HonorGetAward honorId
         */

        /**
         * Constructs a new HonorGetAward.
         * @memberof msgProto
         * @classdesc Represents an HonorGetAward.
         * @implements IHonorGetAward
         * @constructor
         * @param {msgProto.IHonorGetAward=} [properties] Properties to set
         */
        function HonorGetAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HonorGetAward honorId.
         * @member {number} honorId
         * @memberof msgProto.HonorGetAward
         * @instance
         */
        HonorGetAward.prototype.honorId = 0;

        /**
         * Encodes the specified HonorGetAward message. Does not implicitly {@link msgProto.HonorGetAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {msgProto.IHonorGetAward} message HonorGetAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.honorId != null && message.hasOwnProperty("honorId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.honorId);
            return writer;
        };

        /**
         * Decodes an HonorGetAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorGetAward} HonorGetAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorGetAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.honorId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an HonorGetAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HonorGetAward} HonorGetAward
         */
        HonorGetAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HonorGetAward)
                return object;
            var message = new $root.msgProto.HonorGetAward();
            if (object.honorId != null)
                message.honorId = object.honorId | 0;
            return message;
        };

        /**
         * Creates a plain object from an HonorGetAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {msgProto.HonorGetAward} message HonorGetAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HonorGetAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.honorId = 0;
            if (message.honorId != null && message.hasOwnProperty("honorId"))
                object.honorId = message.honorId;
            return object;
        };

        /**
         * Converts this HonorGetAward to JSON.
         * @function toJSON
         * @memberof msgProto.HonorGetAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HonorGetAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HonorGetAward;
    })();

    msgProto.HonorBugAlter = (function() {

        /**
         * Properties of an HonorBugAlter.
         * @memberof msgProto
         * @interface IHonorBugAlter
         */

        /**
         * Constructs a new HonorBugAlter.
         * @memberof msgProto
         * @classdesc Represents an HonorBugAlter.
         * @implements IHonorBugAlter
         * @constructor
         * @param {msgProto.IHonorBugAlter=} [properties] Properties to set
         */
        function HonorBugAlter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified HonorBugAlter message. Does not implicitly {@link msgProto.HonorBugAlter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {msgProto.IHonorBugAlter} message HonorBugAlter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorBugAlter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an HonorBugAlter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorBugAlter} HonorBugAlter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorBugAlter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorBugAlter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an HonorBugAlter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HonorBugAlter} HonorBugAlter
         */
        HonorBugAlter.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HonorBugAlter)
                return object;
            return new $root.msgProto.HonorBugAlter();
        };

        /**
         * Creates a plain object from an HonorBugAlter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {msgProto.HonorBugAlter} message HonorBugAlter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HonorBugAlter.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HonorBugAlter to JSON.
         * @function toJSON
         * @memberof msgProto.HonorBugAlter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HonorBugAlter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HonorBugAlter;
    })();

    msgProto.HeartStuntGetInfo = (function() {

        /**
         * Properties of a HeartStuntGetInfo.
         * @memberof msgProto
         * @interface IHeartStuntGetInfo
         */

        /**
         * Constructs a new HeartStuntGetInfo.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntGetInfo.
         * @implements IHeartStuntGetInfo
         * @constructor
         * @param {msgProto.IHeartStuntGetInfo=} [properties] Properties to set
         */
        function HeartStuntGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified HeartStuntGetInfo message. Does not implicitly {@link msgProto.HeartStuntGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {msgProto.IHeartStuntGetInfo} message HeartStuntGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a HeartStuntGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntGetInfo} HeartStuntGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeartStuntGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeartStuntGetInfo} HeartStuntGetInfo
         */
        HeartStuntGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeartStuntGetInfo)
                return object;
            return new $root.msgProto.HeartStuntGetInfo();
        };

        /**
         * Creates a plain object from a HeartStuntGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {msgProto.HeartStuntGetInfo} message HeartStuntGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartStuntGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HeartStuntGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.HeartStuntGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartStuntGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartStuntGetInfo;
    })();

    msgProto.HeartStuntChoMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntChoMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntChoMenCulMethods
         * @property {number|null} [index] HeartStuntChoMenCulMethods index
         * @property {number|null} [heartStuntId] HeartStuntChoMenCulMethods heartStuntId
         */

        /**
         * Constructs a new HeartStuntChoMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntChoMenCulMethods.
         * @implements IHeartStuntChoMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntChoMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntChoMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntChoMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @instance
         */
        HeartStuntChoMenCulMethods.prototype.index = 0;

        /**
         * HeartStuntChoMenCulMethods heartStuntId.
         * @member {number} heartStuntId
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @instance
         */
        HeartStuntChoMenCulMethods.prototype.heartStuntId = 0;

        /**
         * Encodes the specified HeartStuntChoMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntChoMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChoMenCulMethods} message HeartStuntChoMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChoMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heartStuntId);
            return writer;
        };

        /**
         * Decodes a HeartStuntChoMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntChoMenCulMethods} HeartStuntChoMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChoMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntChoMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.heartStuntId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeartStuntChoMenCulMethods message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeartStuntChoMenCulMethods} HeartStuntChoMenCulMethods
         */
        HeartStuntChoMenCulMethods.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeartStuntChoMenCulMethods)
                return object;
            var message = new $root.msgProto.HeartStuntChoMenCulMethods();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.heartStuntId != null)
                message.heartStuntId = object.heartStuntId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeartStuntChoMenCulMethods message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {msgProto.HeartStuntChoMenCulMethods} message HeartStuntChoMenCulMethods
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartStuntChoMenCulMethods.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.heartStuntId = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                object.heartStuntId = message.heartStuntId;
            return object;
        };

        /**
         * Converts this HeartStuntChoMenCulMethods to JSON.
         * @function toJSON
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartStuntChoMenCulMethods.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartStuntChoMenCulMethods;
    })();

    msgProto.HeartStuntStuMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntStuMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntStuMenCulMethods
         * @property {number|null} [index] HeartStuntStuMenCulMethods index
         */

        /**
         * Constructs a new HeartStuntStuMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntStuMenCulMethods.
         * @implements IHeartStuntStuMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntStuMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntStuMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntStuMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @instance
         */
        HeartStuntStuMenCulMethods.prototype.index = 0;

        /**
         * Encodes the specified HeartStuntStuMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntStuMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntStuMenCulMethods} message HeartStuntStuMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntStuMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeartStuntStuMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntStuMenCulMethods} HeartStuntStuMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntStuMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntStuMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeartStuntStuMenCulMethods message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeartStuntStuMenCulMethods} HeartStuntStuMenCulMethods
         */
        HeartStuntStuMenCulMethods.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeartStuntStuMenCulMethods)
                return object;
            var message = new $root.msgProto.HeartStuntStuMenCulMethods();
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeartStuntStuMenCulMethods message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {msgProto.HeartStuntStuMenCulMethods} message HeartStuntStuMenCulMethods
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartStuntStuMenCulMethods.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeartStuntStuMenCulMethods to JSON.
         * @function toJSON
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartStuntStuMenCulMethods.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartStuntStuMenCulMethods;
    })();

    msgProto.HeartStuntChaMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntChaMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntChaMenCulMethods
         * @property {number|null} [index] HeartStuntChaMenCulMethods index
         * @property {number|null} [heartStuntId] HeartStuntChaMenCulMethods heartStuntId
         */

        /**
         * Constructs a new HeartStuntChaMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntChaMenCulMethods.
         * @implements IHeartStuntChaMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntChaMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntChaMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntChaMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @instance
         */
        HeartStuntChaMenCulMethods.prototype.index = 0;

        /**
         * HeartStuntChaMenCulMethods heartStuntId.
         * @member {number} heartStuntId
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @instance
         */
        HeartStuntChaMenCulMethods.prototype.heartStuntId = 0;

        /**
         * Encodes the specified HeartStuntChaMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntChaMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChaMenCulMethods} message HeartStuntChaMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChaMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heartStuntId);
            return writer;
        };

        /**
         * Decodes a HeartStuntChaMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntChaMenCulMethods} HeartStuntChaMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChaMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntChaMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.heartStuntId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeartStuntChaMenCulMethods message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeartStuntChaMenCulMethods} HeartStuntChaMenCulMethods
         */
        HeartStuntChaMenCulMethods.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeartStuntChaMenCulMethods)
                return object;
            var message = new $root.msgProto.HeartStuntChaMenCulMethods();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.heartStuntId != null)
                message.heartStuntId = object.heartStuntId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeartStuntChaMenCulMethods message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {msgProto.HeartStuntChaMenCulMethods} message HeartStuntChaMenCulMethods
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartStuntChaMenCulMethods.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.heartStuntId = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                object.heartStuntId = message.heartStuntId;
            return object;
        };

        /**
         * Converts this HeartStuntChaMenCulMethods to JSON.
         * @function toJSON
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartStuntChaMenCulMethods.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartStuntChaMenCulMethods;
    })();

    msgProto.HeroCallHero = (function() {

        /**
         * Properties of a HeroCallHero.
         * @memberof msgProto
         * @interface IHeroCallHero
         * @property {number|null} [tempId] HeroCallHero tempId
         * @property {number|null} [sex] HeroCallHero sex
         */

        /**
         * Constructs a new HeroCallHero.
         * @memberof msgProto
         * @classdesc Represents a HeroCallHero.
         * @implements IHeroCallHero
         * @constructor
         * @param {msgProto.IHeroCallHero=} [properties] Properties to set
         */
        function HeroCallHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroCallHero tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroCallHero
         * @instance
         */
        HeroCallHero.prototype.tempId = 0;

        /**
         * HeroCallHero sex.
         * @member {number} sex
         * @memberof msgProto.HeroCallHero
         * @instance
         */
        HeroCallHero.prototype.sex = 0;

        /**
         * Encodes the specified HeroCallHero message. Does not implicitly {@link msgProto.HeroCallHero.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {msgProto.IHeroCallHero} message HeroCallHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCallHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.sex != null && message.hasOwnProperty("sex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sex);
            return writer;
        };

        /**
         * Decodes a HeroCallHero message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroCallHero} HeroCallHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCallHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroCallHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.sex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroCallHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroCallHero} HeroCallHero
         */
        HeroCallHero.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroCallHero)
                return object;
            var message = new $root.msgProto.HeroCallHero();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.sex != null)
                message.sex = object.sex | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroCallHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {msgProto.HeroCallHero} message HeroCallHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroCallHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.sex = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex = message.sex;
            return object;
        };

        /**
         * Converts this HeroCallHero to JSON.
         * @function toJSON
         * @memberof msgProto.HeroCallHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroCallHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroCallHero;
    })();

    msgProto.HeroUpSkill = (function() {

        /**
         * Properties of a HeroUpSkill.
         * @memberof msgProto
         * @interface IHeroUpSkill
         * @property {number|null} [tempId] HeroUpSkill tempId
         * @property {number|null} [index] HeroUpSkill index
         */

        /**
         * Constructs a new HeroUpSkill.
         * @memberof msgProto
         * @classdesc Represents a HeroUpSkill.
         * @implements IHeroUpSkill
         * @constructor
         * @param {msgProto.IHeroUpSkill=} [properties] Properties to set
         */
        function HeroUpSkill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpSkill tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpSkill
         * @instance
         */
        HeroUpSkill.prototype.tempId = 0;

        /**
         * HeroUpSkill index.
         * @member {number} index
         * @memberof msgProto.HeroUpSkill
         * @instance
         */
        HeroUpSkill.prototype.index = 0;

        /**
         * Encodes the specified HeroUpSkill message. Does not implicitly {@link msgProto.HeroUpSkill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {msgProto.IHeroUpSkill} message HeroUpSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpSkill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroUpSkill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpSkill} HeroUpSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpSkill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpSkill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroUpSkill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroUpSkill} HeroUpSkill
         */
        HeroUpSkill.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroUpSkill)
                return object;
            var message = new $root.msgProto.HeroUpSkill();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroUpSkill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {msgProto.HeroUpSkill} message HeroUpSkill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroUpSkill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroUpSkill to JSON.
         * @function toJSON
         * @memberof msgProto.HeroUpSkill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroUpSkill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroUpSkill;
    })();

    msgProto.HeroClearSkillCd = (function() {

        /**
         * Properties of a HeroClearSkillCd.
         * @memberof msgProto
         * @interface IHeroClearSkillCd
         */

        /**
         * Constructs a new HeroClearSkillCd.
         * @memberof msgProto
         * @classdesc Represents a HeroClearSkillCd.
         * @implements IHeroClearSkillCd
         * @constructor
         * @param {msgProto.IHeroClearSkillCd=} [properties] Properties to set
         */
        function HeroClearSkillCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified HeroClearSkillCd message. Does not implicitly {@link msgProto.HeroClearSkillCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {msgProto.IHeroClearSkillCd} message HeroClearSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroClearSkillCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a HeroClearSkillCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroClearSkillCd} HeroClearSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroClearSkillCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroClearSkillCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroClearSkillCd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroClearSkillCd} HeroClearSkillCd
         */
        HeroClearSkillCd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroClearSkillCd)
                return object;
            return new $root.msgProto.HeroClearSkillCd();
        };

        /**
         * Creates a plain object from a HeroClearSkillCd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {msgProto.HeroClearSkillCd} message HeroClearSkillCd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroClearSkillCd.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HeroClearSkillCd to JSON.
         * @function toJSON
         * @memberof msgProto.HeroClearSkillCd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroClearSkillCd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroClearSkillCd;
    })();

    msgProto.HeroWearRune = (function() {

        /**
         * Properties of a HeroWearRune.
         * @memberof msgProto
         * @interface IHeroWearRune
         * @property {number|null} [tempId] HeroWearRune tempId
         * @property {number|null} [index] HeroWearRune index
         */

        /**
         * Constructs a new HeroWearRune.
         * @memberof msgProto
         * @classdesc Represents a HeroWearRune.
         * @implements IHeroWearRune
         * @constructor
         * @param {msgProto.IHeroWearRune=} [properties] Properties to set
         */
        function HeroWearRune(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWearRune tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWearRune
         * @instance
         */
        HeroWearRune.prototype.tempId = 0;

        /**
         * HeroWearRune index.
         * @member {number} index
         * @memberof msgProto.HeroWearRune
         * @instance
         */
        HeroWearRune.prototype.index = 0;

        /**
         * Encodes the specified HeroWearRune message. Does not implicitly {@link msgProto.HeroWearRune.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {msgProto.IHeroWearRune} message HeroWearRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearRune.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroWearRune message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWearRune} HeroWearRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearRune.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWearRune();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroWearRune message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroWearRune} HeroWearRune
         */
        HeroWearRune.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroWearRune)
                return object;
            var message = new $root.msgProto.HeroWearRune();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroWearRune message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {msgProto.HeroWearRune} message HeroWearRune
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroWearRune.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroWearRune to JSON.
         * @function toJSON
         * @memberof msgProto.HeroWearRune
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroWearRune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroWearRune;
    })();

    msgProto.HeroUpRealm = (function() {

        /**
         * Properties of a HeroUpRealm.
         * @memberof msgProto
         * @interface IHeroUpRealm
         * @property {number|null} [tempId] HeroUpRealm tempId
         */

        /**
         * Constructs a new HeroUpRealm.
         * @memberof msgProto
         * @classdesc Represents a HeroUpRealm.
         * @implements IHeroUpRealm
         * @constructor
         * @param {msgProto.IHeroUpRealm=} [properties] Properties to set
         */
        function HeroUpRealm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpRealm tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpRealm
         * @instance
         */
        HeroUpRealm.prototype.tempId = 0;

        /**
         * Encodes the specified HeroUpRealm message. Does not implicitly {@link msgProto.HeroUpRealm.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {msgProto.IHeroUpRealm} message HeroUpRealm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpRealm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes a HeroUpRealm message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpRealm} HeroUpRealm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpRealm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpRealm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroUpRealm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroUpRealm} HeroUpRealm
         */
        HeroUpRealm.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroUpRealm)
                return object;
            var message = new $root.msgProto.HeroUpRealm();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroUpRealm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {msgProto.HeroUpRealm} message HeroUpRealm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroUpRealm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tempId = 0;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this HeroUpRealm to JSON.
         * @function toJSON
         * @memberof msgProto.HeroUpRealm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroUpRealm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroUpRealm;
    })();

    msgProto.HeroStrength = (function() {

        /**
         * Properties of a HeroStrength.
         * @memberof msgProto
         * @interface IHeroStrength
         * @property {number|null} [tempId] HeroStrength tempId
         * @property {number|null} [index] HeroStrength index
         */

        /**
         * Constructs a new HeroStrength.
         * @memberof msgProto
         * @classdesc Represents a HeroStrength.
         * @implements IHeroStrength
         * @constructor
         * @param {msgProto.IHeroStrength=} [properties] Properties to set
         */
        function HeroStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroStrength tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroStrength
         * @instance
         */
        HeroStrength.prototype.tempId = 0;

        /**
         * HeroStrength index.
         * @member {number} index
         * @memberof msgProto.HeroStrength
         * @instance
         */
        HeroStrength.prototype.index = 0;

        /**
         * Encodes the specified HeroStrength message. Does not implicitly {@link msgProto.HeroStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroStrength
         * @static
         * @param {msgProto.IHeroStrength} message HeroStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroStrength} HeroStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroStrength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroStrength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroStrength} HeroStrength
         */
        HeroStrength.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroStrength)
                return object;
            var message = new $root.msgProto.HeroStrength();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroStrength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroStrength
         * @static
         * @param {msgProto.HeroStrength} message HeroStrength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroStrength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroStrength to JSON.
         * @function toJSON
         * @memberof msgProto.HeroStrength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroStrength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroStrength;
    })();

    msgProto.HeroEquipRefine = (function() {

        /**
         * Properties of a HeroEquipRefine.
         * @memberof msgProto
         * @interface IHeroEquipRefine
         * @property {number|null} [tempId] HeroEquipRefine tempId
         * @property {number|null} [index] HeroEquipRefine index
         */

        /**
         * Constructs a new HeroEquipRefine.
         * @memberof msgProto
         * @classdesc Represents a HeroEquipRefine.
         * @implements IHeroEquipRefine
         * @constructor
         * @param {msgProto.IHeroEquipRefine=} [properties] Properties to set
         */
        function HeroEquipRefine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroEquipRefine tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroEquipRefine
         * @instance
         */
        HeroEquipRefine.prototype.tempId = 0;

        /**
         * HeroEquipRefine index.
         * @member {number} index
         * @memberof msgProto.HeroEquipRefine
         * @instance
         */
        HeroEquipRefine.prototype.index = 0;

        /**
         * Encodes the specified HeroEquipRefine message. Does not implicitly {@link msgProto.HeroEquipRefine.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {msgProto.IHeroEquipRefine} message HeroEquipRefine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroEquipRefine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroEquipRefine message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroEquipRefine} HeroEquipRefine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroEquipRefine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroEquipRefine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroEquipRefine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroEquipRefine} HeroEquipRefine
         */
        HeroEquipRefine.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroEquipRefine)
                return object;
            var message = new $root.msgProto.HeroEquipRefine();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroEquipRefine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {msgProto.HeroEquipRefine} message HeroEquipRefine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroEquipRefine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroEquipRefine to JSON.
         * @function toJSON
         * @memberof msgProto.HeroEquipRefine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroEquipRefine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroEquipRefine;
    })();

    msgProto.HeroUpStar = (function() {

        /**
         * Properties of a HeroUpStar.
         * @memberof msgProto
         * @interface IHeroUpStar
         * @property {number|null} [tempId] HeroUpStar tempId
         * @property {number|null} [index] HeroUpStar index
         */

        /**
         * Constructs a new HeroUpStar.
         * @memberof msgProto
         * @classdesc Represents a HeroUpStar.
         * @implements IHeroUpStar
         * @constructor
         * @param {msgProto.IHeroUpStar=} [properties] Properties to set
         */
        function HeroUpStar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpStar tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpStar
         * @instance
         */
        HeroUpStar.prototype.tempId = 0;

        /**
         * HeroUpStar index.
         * @member {number} index
         * @memberof msgProto.HeroUpStar
         * @instance
         */
        HeroUpStar.prototype.index = 0;

        /**
         * Encodes the specified HeroUpStar message. Does not implicitly {@link msgProto.HeroUpStar.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {msgProto.IHeroUpStar} message HeroUpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpStar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroUpStar message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpStar} HeroUpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpStar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpStar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroUpStar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroUpStar} HeroUpStar
         */
        HeroUpStar.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroUpStar)
                return object;
            var message = new $root.msgProto.HeroUpStar();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroUpStar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {msgProto.HeroUpStar} message HeroUpStar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroUpStar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroUpStar to JSON.
         * @function toJSON
         * @memberof msgProto.HeroUpStar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroUpStar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroUpStar;
    })();

    msgProto.HeroStarTop = (function() {

        /**
         * Properties of a HeroStarTop.
         * @memberof msgProto
         * @interface IHeroStarTop
         * @property {number|null} [tempId] HeroStarTop tempId
         * @property {number|null} [index] HeroStarTop index
         */

        /**
         * Constructs a new HeroStarTop.
         * @memberof msgProto
         * @classdesc Represents a HeroStarTop.
         * @implements IHeroStarTop
         * @constructor
         * @param {msgProto.IHeroStarTop=} [properties] Properties to set
         */
        function HeroStarTop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroStarTop tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroStarTop
         * @instance
         */
        HeroStarTop.prototype.tempId = 0;

        /**
         * HeroStarTop index.
         * @member {number} index
         * @memberof msgProto.HeroStarTop
         * @instance
         */
        HeroStarTop.prototype.index = 0;

        /**
         * Encodes the specified HeroStarTop message. Does not implicitly {@link msgProto.HeroStarTop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {msgProto.IHeroStarTop} message HeroStarTop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStarTop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a HeroStarTop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroStarTop} HeroStarTop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStarTop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroStarTop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroStarTop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroStarTop} HeroStarTop
         */
        HeroStarTop.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroStarTop)
                return object;
            var message = new $root.msgProto.HeroStarTop();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroStarTop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {msgProto.HeroStarTop} message HeroStarTop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroStarTop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HeroStarTop to JSON.
         * @function toJSON
         * @memberof msgProto.HeroStarTop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroStarTop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroStarTop;
    })();

    msgProto.heroUpGem = (function() {

        /**
         * Properties of a heroUpGem.
         * @memberof msgProto
         * @interface IheroUpGem
         * @property {number|null} [tempId] heroUpGem tempId
         * @property {number|null} [index] heroUpGem index
         */

        /**
         * Constructs a new heroUpGem.
         * @memberof msgProto
         * @classdesc Represents a heroUpGem.
         * @implements IheroUpGem
         * @constructor
         * @param {msgProto.IheroUpGem=} [properties] Properties to set
         */
        function heroUpGem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * heroUpGem tempId.
         * @member {number} tempId
         * @memberof msgProto.heroUpGem
         * @instance
         */
        heroUpGem.prototype.tempId = 0;

        /**
         * heroUpGem index.
         * @member {number} index
         * @memberof msgProto.heroUpGem
         * @instance
         */
        heroUpGem.prototype.index = 0;

        /**
         * Encodes the specified heroUpGem message. Does not implicitly {@link msgProto.heroUpGem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.heroUpGem
         * @static
         * @param {msgProto.IheroUpGem} message heroUpGem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroUpGem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Decodes a heroUpGem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.heroUpGem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.heroUpGem} heroUpGem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroUpGem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.heroUpGem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a heroUpGem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.heroUpGem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.heroUpGem} heroUpGem
         */
        heroUpGem.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.heroUpGem)
                return object;
            var message = new $root.msgProto.heroUpGem();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a heroUpGem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.heroUpGem
         * @static
         * @param {msgProto.heroUpGem} message heroUpGem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        heroUpGem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.index = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this heroUpGem to JSON.
         * @function toJSON
         * @memberof msgProto.heroUpGem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        heroUpGem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return heroUpGem;
    })();

    msgProto.heroWingFos = (function() {

        /**
         * Properties of a heroWingFos.
         * @memberof msgProto
         * @interface IheroWingFos
         * @property {number|null} [tempId] heroWingFos tempId
         * @property {number|null} [fosType] heroWingFos fosType
         */

        /**
         * Constructs a new heroWingFos.
         * @memberof msgProto
         * @classdesc Represents a heroWingFos.
         * @implements IheroWingFos
         * @constructor
         * @param {msgProto.IheroWingFos=} [properties] Properties to set
         */
        function heroWingFos(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * heroWingFos tempId.
         * @member {number} tempId
         * @memberof msgProto.heroWingFos
         * @instance
         */
        heroWingFos.prototype.tempId = 0;

        /**
         * heroWingFos fosType.
         * @member {number} fosType
         * @memberof msgProto.heroWingFos
         * @instance
         */
        heroWingFos.prototype.fosType = 0;

        /**
         * Encodes the specified heroWingFos message. Does not implicitly {@link msgProto.heroWingFos.verify|verify} messages.
         * @function encode
         * @memberof msgProto.heroWingFos
         * @static
         * @param {msgProto.IheroWingFos} message heroWingFos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroWingFos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fosType);
            return writer;
        };

        /**
         * Decodes a heroWingFos message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.heroWingFos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.heroWingFos} heroWingFos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroWingFos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.heroWingFos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.fosType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a heroWingFos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.heroWingFos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.heroWingFos} heroWingFos
         */
        heroWingFos.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.heroWingFos)
                return object;
            var message = new $root.msgProto.heroWingFos();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.fosType != null)
                message.fosType = object.fosType | 0;
            return message;
        };

        /**
         * Creates a plain object from a heroWingFos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.heroWingFos
         * @static
         * @param {msgProto.heroWingFos} message heroWingFos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        heroWingFos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.fosType = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                object.fosType = message.fosType;
            return object;
        };

        /**
         * Converts this heroWingFos to JSON.
         * @function toJSON
         * @memberof msgProto.heroWingFos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        heroWingFos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return heroWingFos;
    })();

    msgProto.Hero_wingStrength = (function() {

        /**
         * Properties of a Hero_wingStrength.
         * @memberof msgProto
         * @interface IHero_wingStrength
         * @property {number|null} [tempId] Hero_wingStrength tempId
         * @property {number|null} [part] Hero_wingStrength part
         * @property {boolean|null} [isReplace] Hero_wingStrength isReplace
         */

        /**
         * Constructs a new Hero_wingStrength.
         * @memberof msgProto
         * @classdesc Represents a Hero_wingStrength.
         * @implements IHero_wingStrength
         * @constructor
         * @param {msgProto.IHero_wingStrength=} [properties] Properties to set
         */
        function Hero_wingStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hero_wingStrength tempId.
         * @member {number} tempId
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.tempId = 0;

        /**
         * Hero_wingStrength part.
         * @member {number} part
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.part = 0;

        /**
         * Hero_wingStrength isReplace.
         * @member {boolean} isReplace
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.isReplace = false;

        /**
         * Encodes the specified Hero_wingStrength message. Does not implicitly {@link msgProto.Hero_wingStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {msgProto.IHero_wingStrength} message Hero_wingStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero_wingStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.part != null && message.hasOwnProperty("part"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.part);
            if (message.isReplace != null && message.hasOwnProperty("isReplace"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isReplace);
            return writer;
        };

        /**
         * Decodes a Hero_wingStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Hero_wingStrength} Hero_wingStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero_wingStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Hero_wingStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.part = reader.int32();
                    break;
                case 3:
                    message.isReplace = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a Hero_wingStrength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.Hero_wingStrength} Hero_wingStrength
         */
        Hero_wingStrength.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.Hero_wingStrength)
                return object;
            var message = new $root.msgProto.Hero_wingStrength();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.part != null)
                message.part = object.part | 0;
            if (object.isReplace != null)
                message.isReplace = Boolean(object.isReplace);
            return message;
        };

        /**
         * Creates a plain object from a Hero_wingStrength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {msgProto.Hero_wingStrength} message Hero_wingStrength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hero_wingStrength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.part = 0;
                object.isReplace = false;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.part != null && message.hasOwnProperty("part"))
                object.part = message.part;
            if (message.isReplace != null && message.hasOwnProperty("isReplace"))
                object.isReplace = message.isReplace;
            return object;
        };

        /**
         * Converts this Hero_wingStrength to JSON.
         * @function toJSON
         * @memberof msgProto.Hero_wingStrength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hero_wingStrength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hero_wingStrength;
    })();

    msgProto.HeroWingFos2Top = (function() {

        /**
         * Properties of a HeroWingFos2Top.
         * @memberof msgProto
         * @interface IHeroWingFos2Top
         * @property {number|null} [tempId] HeroWingFos2Top tempId
         * @property {number|null} [fosType] HeroWingFos2Top fosType
         * @property {boolean|null} [isUseDiamond] HeroWingFos2Top isUseDiamond
         */

        /**
         * Constructs a new HeroWingFos2Top.
         * @memberof msgProto
         * @classdesc Represents a HeroWingFos2Top.
         * @implements IHeroWingFos2Top
         * @constructor
         * @param {msgProto.IHeroWingFos2Top=} [properties] Properties to set
         */
        function HeroWingFos2Top(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWingFos2Top tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.tempId = 0;

        /**
         * HeroWingFos2Top fosType.
         * @member {number} fosType
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.fosType = 0;

        /**
         * HeroWingFos2Top isUseDiamond.
         * @member {boolean} isUseDiamond
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.isUseDiamond = false;

        /**
         * Encodes the specified HeroWingFos2Top message. Does not implicitly {@link msgProto.HeroWingFos2Top.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {msgProto.IHeroWingFos2Top} message HeroWingFos2Top message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingFos2Top.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fosType);
            if (message.isUseDiamond != null && message.hasOwnProperty("isUseDiamond"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isUseDiamond);
            return writer;
        };

        /**
         * Decodes a HeroWingFos2Top message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWingFos2Top} HeroWingFos2Top
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingFos2Top.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWingFos2Top();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.fosType = reader.int32();
                    break;
                case 3:
                    message.isUseDiamond = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroWingFos2Top message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroWingFos2Top} HeroWingFos2Top
         */
        HeroWingFos2Top.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroWingFos2Top)
                return object;
            var message = new $root.msgProto.HeroWingFos2Top();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.fosType != null)
                message.fosType = object.fosType | 0;
            if (object.isUseDiamond != null)
                message.isUseDiamond = Boolean(object.isUseDiamond);
            return message;
        };

        /**
         * Creates a plain object from a HeroWingFos2Top message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {msgProto.HeroWingFos2Top} message HeroWingFos2Top
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroWingFos2Top.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.fosType = 0;
                object.isUseDiamond = false;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                object.fosType = message.fosType;
            if (message.isUseDiamond != null && message.hasOwnProperty("isUseDiamond"))
                object.isUseDiamond = message.isUseDiamond;
            return object;
        };

        /**
         * Converts this HeroWingFos2Top to JSON.
         * @function toJSON
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroWingFos2Top.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroWingFos2Top;
    })();

    msgProto.HeroUpWing = (function() {

        /**
         * Properties of a HeroUpWing.
         * @memberof msgProto
         * @interface IHeroUpWing
         * @property {number|null} [tempId] HeroUpWing tempId
         */

        /**
         * Constructs a new HeroUpWing.
         * @memberof msgProto
         * @classdesc Represents a HeroUpWing.
         * @implements IHeroUpWing
         * @constructor
         * @param {msgProto.IHeroUpWing=} [properties] Properties to set
         */
        function HeroUpWing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpWing tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpWing
         * @instance
         */
        HeroUpWing.prototype.tempId = 0;

        /**
         * Encodes the specified HeroUpWing message. Does not implicitly {@link msgProto.HeroUpWing.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {msgProto.IHeroUpWing} message HeroUpWing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpWing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes a HeroUpWing message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpWing} HeroUpWing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpWing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpWing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroUpWing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroUpWing} HeroUpWing
         */
        HeroUpWing.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroUpWing)
                return object;
            var message = new $root.msgProto.HeroUpWing();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroUpWing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {msgProto.HeroUpWing} message HeroUpWing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroUpWing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tempId = 0;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this HeroUpWing to JSON.
         * @function toJSON
         * @memberof msgProto.HeroUpWing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroUpWing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroUpWing;
    })();

    msgProto.HeroWingActivate = (function() {

        /**
         * Properties of a HeroWingActivate.
         * @memberof msgProto
         * @interface IHeroWingActivate
         * @property {number|null} [tempId] HeroWingActivate tempId
         */

        /**
         * Constructs a new HeroWingActivate.
         * @memberof msgProto
         * @classdesc Represents a HeroWingActivate.
         * @implements IHeroWingActivate
         * @constructor
         * @param {msgProto.IHeroWingActivate=} [properties] Properties to set
         */
        function HeroWingActivate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWingActivate tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWingActivate
         * @instance
         */
        HeroWingActivate.prototype.tempId = 0;

        /**
         * Encodes the specified HeroWingActivate message. Does not implicitly {@link msgProto.HeroWingActivate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {msgProto.IHeroWingActivate} message HeroWingActivate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingActivate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes a HeroWingActivate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWingActivate} HeroWingActivate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingActivate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWingActivate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroWingActivate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroWingActivate} HeroWingActivate
         */
        HeroWingActivate.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroWingActivate)
                return object;
            var message = new $root.msgProto.HeroWingActivate();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroWingActivate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {msgProto.HeroWingActivate} message HeroWingActivate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroWingActivate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tempId = 0;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this HeroWingActivate to JSON.
         * @function toJSON
         * @memberof msgProto.HeroWingActivate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroWingActivate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroWingActivate;
    })();

    msgProto.HeroCalPropAndCombat = (function() {

        /**
         * Properties of a HeroCalPropAndCombat.
         * @memberof msgProto
         * @interface IHeroCalPropAndCombat
         */

        /**
         * Constructs a new HeroCalPropAndCombat.
         * @memberof msgProto
         * @classdesc Represents a HeroCalPropAndCombat.
         * @implements IHeroCalPropAndCombat
         * @constructor
         * @param {msgProto.IHeroCalPropAndCombat=} [properties] Properties to set
         */
        function HeroCalPropAndCombat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified HeroCalPropAndCombat message. Does not implicitly {@link msgProto.HeroCalPropAndCombat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {msgProto.IHeroCalPropAndCombat} message HeroCalPropAndCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCalPropAndCombat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a HeroCalPropAndCombat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroCalPropAndCombat} HeroCalPropAndCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCalPropAndCombat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroCalPropAndCombat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroCalPropAndCombat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroCalPropAndCombat} HeroCalPropAndCombat
         */
        HeroCalPropAndCombat.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroCalPropAndCombat)
                return object;
            return new $root.msgProto.HeroCalPropAndCombat();
        };

        /**
         * Creates a plain object from a HeroCalPropAndCombat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {msgProto.HeroCalPropAndCombat} message HeroCalPropAndCombat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroCalPropAndCombat.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this HeroCalPropAndCombat to JSON.
         * @function toJSON
         * @memberof msgProto.HeroCalPropAndCombat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroCalPropAndCombat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroCalPropAndCombat;
    })();

    msgProto.HeroGetMainHeroDisplay = (function() {

        /**
         * Properties of a HeroGetMainHeroDisplay.
         * @memberof msgProto
         * @interface IHeroGetMainHeroDisplay
         * @property {number|Long|null} [userId] HeroGetMainHeroDisplay userId
         */

        /**
         * Constructs a new HeroGetMainHeroDisplay.
         * @memberof msgProto
         * @classdesc Represents a HeroGetMainHeroDisplay.
         * @implements IHeroGetMainHeroDisplay
         * @constructor
         * @param {msgProto.IHeroGetMainHeroDisplay=} [properties] Properties to set
         */
        function HeroGetMainHeroDisplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetMainHeroDisplay userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @instance
         */
        HeroGetMainHeroDisplay.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified HeroGetMainHeroDisplay message. Does not implicitly {@link msgProto.HeroGetMainHeroDisplay.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {msgProto.IHeroGetMainHeroDisplay} message HeroGetMainHeroDisplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetMainHeroDisplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Decodes a HeroGetMainHeroDisplay message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetMainHeroDisplay} HeroGetMainHeroDisplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetMainHeroDisplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetMainHeroDisplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroGetMainHeroDisplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroGetMainHeroDisplay} HeroGetMainHeroDisplay
         */
        HeroGetMainHeroDisplay.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroGetMainHeroDisplay)
                return object;
            var message = new $root.msgProto.HeroGetMainHeroDisplay();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a HeroGetMainHeroDisplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {msgProto.HeroGetMainHeroDisplay} message HeroGetMainHeroDisplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroGetMainHeroDisplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            return object;
        };

        /**
         * Converts this HeroGetMainHeroDisplay to JSON.
         * @function toJSON
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroGetMainHeroDisplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroGetMainHeroDisplay;
    })();

    msgProto.HeroGetHeroDisplayByTempId = (function() {

        /**
         * Properties of a HeroGetHeroDisplayByTempId.
         * @memberof msgProto
         * @interface IHeroGetHeroDisplayByTempId
         * @property {number|Long|null} [userId] HeroGetHeroDisplayByTempId userId
         * @property {number|null} [tempId] HeroGetHeroDisplayByTempId tempId
         */

        /**
         * Constructs a new HeroGetHeroDisplayByTempId.
         * @memberof msgProto
         * @classdesc Represents a HeroGetHeroDisplayByTempId.
         * @implements IHeroGetHeroDisplayByTempId
         * @constructor
         * @param {msgProto.IHeroGetHeroDisplayByTempId=} [properties] Properties to set
         */
        function HeroGetHeroDisplayByTempId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetHeroDisplayByTempId userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @instance
         */
        HeroGetHeroDisplayByTempId.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HeroGetHeroDisplayByTempId tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @instance
         */
        HeroGetHeroDisplayByTempId.prototype.tempId = 0;

        /**
         * Encodes the specified HeroGetHeroDisplayByTempId message. Does not implicitly {@link msgProto.HeroGetHeroDisplayByTempId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {msgProto.IHeroGetHeroDisplayByTempId} message HeroGetHeroDisplayByTempId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetHeroDisplayByTempId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes a HeroGetHeroDisplayByTempId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetHeroDisplayByTempId} HeroGetHeroDisplayByTempId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetHeroDisplayByTempId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetHeroDisplayByTempId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                case 2:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroGetHeroDisplayByTempId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroGetHeroDisplayByTempId} HeroGetHeroDisplayByTempId
         */
        HeroGetHeroDisplayByTempId.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroGetHeroDisplayByTempId)
                return object;
            var message = new $root.msgProto.HeroGetHeroDisplayByTempId();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroGetHeroDisplayByTempId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {msgProto.HeroGetHeroDisplayByTempId} message HeroGetHeroDisplayByTempId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroGetHeroDisplayByTempId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
                object.tempId = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this HeroGetHeroDisplayByTempId to JSON.
         * @function toJSON
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroGetHeroDisplayByTempId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroGetHeroDisplayByTempId;
    })();

    msgProto.HeroGetShowHeroData = (function() {

        /**
         * Properties of a HeroGetShowHeroData.
         * @memberof msgProto
         * @interface IHeroGetShowHeroData
         * @property {number|Long|null} [userId] HeroGetShowHeroData userId
         */

        /**
         * Constructs a new HeroGetShowHeroData.
         * @memberof msgProto
         * @classdesc Represents a HeroGetShowHeroData.
         * @implements IHeroGetShowHeroData
         * @constructor
         * @param {msgProto.IHeroGetShowHeroData=} [properties] Properties to set
         */
        function HeroGetShowHeroData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetShowHeroData userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetShowHeroData
         * @instance
         */
        HeroGetShowHeroData.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified HeroGetShowHeroData message. Does not implicitly {@link msgProto.HeroGetShowHeroData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {msgProto.IHeroGetShowHeroData} message HeroGetShowHeroData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetShowHeroData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Decodes a HeroGetShowHeroData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetShowHeroData} HeroGetShowHeroData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetShowHeroData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetShowHeroData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroGetShowHeroData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroGetShowHeroData} HeroGetShowHeroData
         */
        HeroGetShowHeroData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroGetShowHeroData)
                return object;
            var message = new $root.msgProto.HeroGetShowHeroData();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a HeroGetShowHeroData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {msgProto.HeroGetShowHeroData} message HeroGetShowHeroData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroGetShowHeroData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            return object;
        };

        /**
         * Converts this HeroGetShowHeroData to JSON.
         * @function toJSON
         * @memberof msgProto.HeroGetShowHeroData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroGetShowHeroData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroGetShowHeroData;
    })();

    msgProto.HeroWearAllRune = (function() {

        /**
         * Properties of a HeroWearAllRune.
         * @memberof msgProto
         * @interface IHeroWearAllRune
         * @property {number|null} [tempId] HeroWearAllRune tempId
         */

        /**
         * Constructs a new HeroWearAllRune.
         * @memberof msgProto
         * @classdesc Represents a HeroWearAllRune.
         * @implements IHeroWearAllRune
         * @constructor
         * @param {msgProto.IHeroWearAllRune=} [properties] Properties to set
         */
        function HeroWearAllRune(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWearAllRune tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWearAllRune
         * @instance
         */
        HeroWearAllRune.prototype.tempId = 0;

        /**
         * Encodes the specified HeroWearAllRune message. Does not implicitly {@link msgProto.HeroWearAllRune.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {msgProto.IHeroWearAllRune} message HeroWearAllRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearAllRune.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Decodes a HeroWearAllRune message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWearAllRune} HeroWearAllRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearAllRune.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWearAllRune();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroWearAllRune message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroWearAllRune} HeroWearAllRune
         */
        HeroWearAllRune.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroWearAllRune)
                return object;
            var message = new $root.msgProto.HeroWearAllRune();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroWearAllRune message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {msgProto.HeroWearAllRune} message HeroWearAllRune
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroWearAllRune.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tempId = 0;
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            return object;
        };

        /**
         * Converts this HeroWearAllRune to JSON.
         * @function toJSON
         * @memberof msgProto.HeroWearAllRune
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroWearAllRune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroWearAllRune;
    })();

    msgProto.HeroAutoInfuseSwitch = (function() {

        /**
         * Properties of a HeroAutoInfuseSwitch.
         * @memberof msgProto
         * @interface IHeroAutoInfuseSwitch
         * @property {boolean|null} [isOpenIn] HeroAutoInfuseSwitch isOpenIn
         */

        /**
         * Constructs a new HeroAutoInfuseSwitch.
         * @memberof msgProto
         * @classdesc Represents a HeroAutoInfuseSwitch.
         * @implements IHeroAutoInfuseSwitch
         * @constructor
         * @param {msgProto.IHeroAutoInfuseSwitch=} [properties] Properties to set
         */
        function HeroAutoInfuseSwitch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroAutoInfuseSwitch isOpenIn.
         * @member {boolean} isOpenIn
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @instance
         */
        HeroAutoInfuseSwitch.prototype.isOpenIn = false;

        /**
         * Encodes the specified HeroAutoInfuseSwitch message. Does not implicitly {@link msgProto.HeroAutoInfuseSwitch.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {msgProto.IHeroAutoInfuseSwitch} message HeroAutoInfuseSwitch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroAutoInfuseSwitch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isOpenIn != null && message.hasOwnProperty("isOpenIn"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isOpenIn);
            return writer;
        };

        /**
         * Decodes a HeroAutoInfuseSwitch message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroAutoInfuseSwitch} HeroAutoInfuseSwitch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroAutoInfuseSwitch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroAutoInfuseSwitch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isOpenIn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroAutoInfuseSwitch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroAutoInfuseSwitch} HeroAutoInfuseSwitch
         */
        HeroAutoInfuseSwitch.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroAutoInfuseSwitch)
                return object;
            var message = new $root.msgProto.HeroAutoInfuseSwitch();
            if (object.isOpenIn != null)
                message.isOpenIn = Boolean(object.isOpenIn);
            return message;
        };

        /**
         * Creates a plain object from a HeroAutoInfuseSwitch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {msgProto.HeroAutoInfuseSwitch} message HeroAutoInfuseSwitch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroAutoInfuseSwitch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isOpenIn = false;
            if (message.isOpenIn != null && message.hasOwnProperty("isOpenIn"))
                object.isOpenIn = message.isOpenIn;
            return object;
        };

        /**
         * Converts this HeroAutoInfuseSwitch to JSON.
         * @function toJSON
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroAutoInfuseSwitch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroAutoInfuseSwitch;
    })();

    msgProto.HeroExtraInfuse = (function() {

        /**
         * Properties of a HeroExtraInfuse.
         * @memberof msgProto
         * @interface IHeroExtraInfuse
         * @property {number|null} [type] HeroExtraInfuse type
         */

        /**
         * Constructs a new HeroExtraInfuse.
         * @memberof msgProto
         * @classdesc Represents a HeroExtraInfuse.
         * @implements IHeroExtraInfuse
         * @constructor
         * @param {msgProto.IHeroExtraInfuse=} [properties] Properties to set
         */
        function HeroExtraInfuse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroExtraInfuse type.
         * @member {number} type
         * @memberof msgProto.HeroExtraInfuse
         * @instance
         */
        HeroExtraInfuse.prototype.type = 0;

        /**
         * Encodes the specified HeroExtraInfuse message. Does not implicitly {@link msgProto.HeroExtraInfuse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {msgProto.IHeroExtraInfuse} message HeroExtraInfuse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroExtraInfuse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Decodes a HeroExtraInfuse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroExtraInfuse} HeroExtraInfuse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroExtraInfuse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroExtraInfuse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroExtraInfuse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroExtraInfuse} HeroExtraInfuse
         */
        HeroExtraInfuse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroExtraInfuse)
                return object;
            var message = new $root.msgProto.HeroExtraInfuse();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a HeroExtraInfuse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {msgProto.HeroExtraInfuse} message HeroExtraInfuse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroExtraInfuse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this HeroExtraInfuse to JSON.
         * @function toJSON
         * @memberof msgProto.HeroExtraInfuse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroExtraInfuse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroExtraInfuse;
    })();

    msgProto.HeroSaveFightList = (function() {

        /**
         * Properties of a HeroSaveFightList.
         * @memberof msgProto
         * @interface IHeroSaveFightList
         * @property {string|null} [fightArr] HeroSaveFightList fightArr
         */

        /**
         * Constructs a new HeroSaveFightList.
         * @memberof msgProto
         * @classdesc Represents a HeroSaveFightList.
         * @implements IHeroSaveFightList
         * @constructor
         * @param {msgProto.IHeroSaveFightList=} [properties] Properties to set
         */
        function HeroSaveFightList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroSaveFightList fightArr.
         * @member {string} fightArr
         * @memberof msgProto.HeroSaveFightList
         * @instance
         */
        HeroSaveFightList.prototype.fightArr = "";

        /**
         * Encodes the specified HeroSaveFightList message. Does not implicitly {@link msgProto.HeroSaveFightList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {msgProto.IHeroSaveFightList} message HeroSaveFightList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroSaveFightList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightArr != null && message.hasOwnProperty("fightArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fightArr);
            return writer;
        };

        /**
         * Decodes a HeroSaveFightList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroSaveFightList} HeroSaveFightList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroSaveFightList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroSaveFightList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fightArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a HeroSaveFightList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.HeroSaveFightList} HeroSaveFightList
         */
        HeroSaveFightList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.HeroSaveFightList)
                return object;
            var message = new $root.msgProto.HeroSaveFightList();
            if (object.fightArr != null)
                message.fightArr = String(object.fightArr);
            return message;
        };

        /**
         * Creates a plain object from a HeroSaveFightList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {msgProto.HeroSaveFightList} message HeroSaveFightList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeroSaveFightList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fightArr = "";
            if (message.fightArr != null && message.hasOwnProperty("fightArr"))
                object.fightArr = message.fightArr;
            return object;
        };

        /**
         * Converts this HeroSaveFightList to JSON.
         * @function toJSON
         * @memberof msgProto.HeroSaveFightList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeroSaveFightList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeroSaveFightList;
    })();

    msgProto.LotteryLottery = (function() {

        /**
         * Properties of a LotteryLottery.
         * @memberof msgProto
         * @interface ILotteryLottery
         * @property {number|null} [type] LotteryLottery type
         * @property {number|null} [count] LotteryLottery count
         */

        /**
         * Constructs a new LotteryLottery.
         * @memberof msgProto
         * @classdesc Represents a LotteryLottery.
         * @implements ILotteryLottery
         * @constructor
         * @param {msgProto.ILotteryLottery=} [properties] Properties to set
         */
        function LotteryLottery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LotteryLottery type.
         * @member {number} type
         * @memberof msgProto.LotteryLottery
         * @instance
         */
        LotteryLottery.prototype.type = 0;

        /**
         * LotteryLottery count.
         * @member {number} count
         * @memberof msgProto.LotteryLottery
         * @instance
         */
        LotteryLottery.prototype.count = 0;

        /**
         * Encodes the specified LotteryLottery message. Does not implicitly {@link msgProto.LotteryLottery.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {msgProto.ILotteryLottery} message LotteryLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryLottery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Decodes a LotteryLottery message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryLottery} LotteryLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryLottery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryLottery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LotteryLottery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LotteryLottery} LotteryLottery
         */
        LotteryLottery.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LotteryLottery)
                return object;
            var message = new $root.msgProto.LotteryLottery();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a LotteryLottery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {msgProto.LotteryLottery} message LotteryLottery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LotteryLottery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.count = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this LotteryLottery to JSON.
         * @function toJSON
         * @memberof msgProto.LotteryLottery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LotteryLottery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LotteryLottery;
    })();

    msgProto.LotteryGetTreasureChest = (function() {

        /**
         * Properties of a LotteryGetTreasureChest.
         * @memberof msgProto
         * @interface ILotteryGetTreasureChest
         */

        /**
         * Constructs a new LotteryGetTreasureChest.
         * @memberof msgProto
         * @classdesc Represents a LotteryGetTreasureChest.
         * @implements ILotteryGetTreasureChest
         * @constructor
         * @param {msgProto.ILotteryGetTreasureChest=} [properties] Properties to set
         */
        function LotteryGetTreasureChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified LotteryGetTreasureChest message. Does not implicitly {@link msgProto.LotteryGetTreasureChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {msgProto.ILotteryGetTreasureChest} message LotteryGetTreasureChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetTreasureChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a LotteryGetTreasureChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryGetTreasureChest} LotteryGetTreasureChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetTreasureChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryGetTreasureChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LotteryGetTreasureChest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LotteryGetTreasureChest} LotteryGetTreasureChest
         */
        LotteryGetTreasureChest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LotteryGetTreasureChest)
                return object;
            return new $root.msgProto.LotteryGetTreasureChest();
        };

        /**
         * Creates a plain object from a LotteryGetTreasureChest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {msgProto.LotteryGetTreasureChest} message LotteryGetTreasureChest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LotteryGetTreasureChest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LotteryGetTreasureChest to JSON.
         * @function toJSON
         * @memberof msgProto.LotteryGetTreasureChest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LotteryGetTreasureChest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LotteryGetTreasureChest;
    })();

    msgProto.LotteryGetInfo = (function() {

        /**
         * Properties of a LotteryGetInfo.
         * @memberof msgProto
         * @interface ILotteryGetInfo
         */

        /**
         * Constructs a new LotteryGetInfo.
         * @memberof msgProto
         * @classdesc Represents a LotteryGetInfo.
         * @implements ILotteryGetInfo
         * @constructor
         * @param {msgProto.ILotteryGetInfo=} [properties] Properties to set
         */
        function LotteryGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified LotteryGetInfo message. Does not implicitly {@link msgProto.LotteryGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {msgProto.ILotteryGetInfo} message LotteryGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a LotteryGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryGetInfo} LotteryGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LotteryGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LotteryGetInfo} LotteryGetInfo
         */
        LotteryGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LotteryGetInfo)
                return object;
            return new $root.msgProto.LotteryGetInfo();
        };

        /**
         * Creates a plain object from a LotteryGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {msgProto.LotteryGetInfo} message LotteryGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LotteryGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LotteryGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.LotteryGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LotteryGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LotteryGetInfo;
    })();

    msgProto.TaskGetInfo = (function() {

        /**
         * Properties of a TaskGetInfo.
         * @memberof msgProto
         * @interface ITaskGetInfo
         */

        /**
         * Constructs a new TaskGetInfo.
         * @memberof msgProto
         * @classdesc Represents a TaskGetInfo.
         * @implements ITaskGetInfo
         * @constructor
         * @param {msgProto.ITaskGetInfo=} [properties] Properties to set
         */
        function TaskGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified TaskGetInfo message. Does not implicitly {@link msgProto.TaskGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {msgProto.ITaskGetInfo} message TaskGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a TaskGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskGetInfo} TaskGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TaskGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TaskGetInfo} TaskGetInfo
         */
        TaskGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TaskGetInfo)
                return object;
            return new $root.msgProto.TaskGetInfo();
        };

        /**
         * Creates a plain object from a TaskGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {msgProto.TaskGetInfo} message TaskGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TaskGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.TaskGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskGetInfo;
    })();

    msgProto.TaskTaskAward = (function() {

        /**
         * Properties of a TaskTaskAward.
         * @memberof msgProto
         * @interface ITaskTaskAward
         * @property {number|null} [taskId] TaskTaskAward taskId
         */

        /**
         * Constructs a new TaskTaskAward.
         * @memberof msgProto
         * @classdesc Represents a TaskTaskAward.
         * @implements ITaskTaskAward
         * @constructor
         * @param {msgProto.ITaskTaskAward=} [properties] Properties to set
         */
        function TaskTaskAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskTaskAward taskId.
         * @member {number} taskId
         * @memberof msgProto.TaskTaskAward
         * @instance
         */
        TaskTaskAward.prototype.taskId = 0;

        /**
         * Encodes the specified TaskTaskAward message. Does not implicitly {@link msgProto.TaskTaskAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {msgProto.ITaskTaskAward} message TaskTaskAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskTaskAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            return writer;
        };

        /**
         * Decodes a TaskTaskAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskTaskAward} TaskTaskAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskTaskAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskTaskAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TaskTaskAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TaskTaskAward} TaskTaskAward
         */
        TaskTaskAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TaskTaskAward)
                return object;
            var message = new $root.msgProto.TaskTaskAward();
            if (object.taskId != null)
                message.taskId = object.taskId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TaskTaskAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {msgProto.TaskTaskAward} message TaskTaskAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskTaskAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.taskId = 0;
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            return object;
        };

        /**
         * Converts this TaskTaskAward to JSON.
         * @function toJSON
         * @memberof msgProto.TaskTaskAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskTaskAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskTaskAward;
    })();

    msgProto.TaskGetVitalityChest = (function() {

        /**
         * Properties of a TaskGetVitalityChest.
         * @memberof msgProto
         * @interface ITaskGetVitalityChest
         * @property {number|null} [index] TaskGetVitalityChest index
         */

        /**
         * Constructs a new TaskGetVitalityChest.
         * @memberof msgProto
         * @classdesc Represents a TaskGetVitalityChest.
         * @implements ITaskGetVitalityChest
         * @constructor
         * @param {msgProto.ITaskGetVitalityChest=} [properties] Properties to set
         */
        function TaskGetVitalityChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskGetVitalityChest index.
         * @member {number} index
         * @memberof msgProto.TaskGetVitalityChest
         * @instance
         */
        TaskGetVitalityChest.prototype.index = 0;

        /**
         * Encodes the specified TaskGetVitalityChest message. Does not implicitly {@link msgProto.TaskGetVitalityChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {msgProto.ITaskGetVitalityChest} message TaskGetVitalityChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetVitalityChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Decodes a TaskGetVitalityChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskGetVitalityChest} TaskGetVitalityChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetVitalityChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskGetVitalityChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TaskGetVitalityChest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TaskGetVitalityChest} TaskGetVitalityChest
         */
        TaskGetVitalityChest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TaskGetVitalityChest)
                return object;
            var message = new $root.msgProto.TaskGetVitalityChest();
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a TaskGetVitalityChest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {msgProto.TaskGetVitalityChest} message TaskGetVitalityChest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskGetVitalityChest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this TaskGetVitalityChest to JSON.
         * @function toJSON
         * @memberof msgProto.TaskGetVitalityChest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskGetVitalityChest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskGetVitalityChest;
    })();

    msgProto.PkBuyPKNum = (function() {

        /**
         * Properties of a PkBuyPKNum.
         * @memberof msgProto
         * @interface IPkBuyPKNum
         */

        /**
         * Constructs a new PkBuyPKNum.
         * @memberof msgProto
         * @classdesc Represents a PkBuyPKNum.
         * @implements IPkBuyPKNum
         * @constructor
         * @param {msgProto.IPkBuyPKNum=} [properties] Properties to set
         */
        function PkBuyPKNum(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkBuyPKNum message. Does not implicitly {@link msgProto.PkBuyPKNum.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {msgProto.IPkBuyPKNum} message PkBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkBuyPKNum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkBuyPKNum message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkBuyPKNum} PkBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkBuyPKNum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkBuyPKNum();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkBuyPKNum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkBuyPKNum} PkBuyPKNum
         */
        PkBuyPKNum.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkBuyPKNum)
                return object;
            return new $root.msgProto.PkBuyPKNum();
        };

        /**
         * Creates a plain object from a PkBuyPKNum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {msgProto.PkBuyPKNum} message PkBuyPKNum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkBuyPKNum.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkBuyPKNum to JSON.
         * @function toJSON
         * @memberof msgProto.PkBuyPKNum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkBuyPKNum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkBuyPKNum;
    })();

    msgProto.PkGetPKUserList = (function() {

        /**
         * Properties of a PkGetPKUserList.
         * @memberof msgProto
         * @interface IPkGetPKUserList
         */

        /**
         * Constructs a new PkGetPKUserList.
         * @memberof msgProto
         * @classdesc Represents a PkGetPKUserList.
         * @implements IPkGetPKUserList
         * @constructor
         * @param {msgProto.IPkGetPKUserList=} [properties] Properties to set
         */
        function PkGetPKUserList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkGetPKUserList message. Does not implicitly {@link msgProto.PkGetPKUserList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {msgProto.IPkGetPKUserList} message PkGetPKUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkGetPKUserList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetPKUserList} PkGetPKUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetPKUserList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetPKUserList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetPKUserList} PkGetPKUserList
         */
        PkGetPKUserList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetPKUserList)
                return object;
            return new $root.msgProto.PkGetPKUserList();
        };

        /**
         * Creates a plain object from a PkGetPKUserList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {msgProto.PkGetPKUserList} message PkGetPKUserList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetPKUserList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkGetPKUserList to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetPKUserList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetPKUserList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetPKUserList;
    })();

    msgProto.PkGetPKUserData = (function() {

        /**
         * Properties of a PkGetPKUserData.
         * @memberof msgProto
         * @interface IPkGetPKUserData
         * @property {number|Long|null} [userId] PkGetPKUserData userId
         */

        /**
         * Constructs a new PkGetPKUserData.
         * @memberof msgProto
         * @classdesc Represents a PkGetPKUserData.
         * @implements IPkGetPKUserData
         * @constructor
         * @param {msgProto.IPkGetPKUserData=} [properties] Properties to set
         */
        function PkGetPKUserData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkGetPKUserData userId.
         * @member {number|Long} userId
         * @memberof msgProto.PkGetPKUserData
         * @instance
         */
        PkGetPKUserData.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified PkGetPKUserData message. Does not implicitly {@link msgProto.PkGetPKUserData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {msgProto.IPkGetPKUserData} message PkGetPKUserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Decodes a PkGetPKUserData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetPKUserData} PkGetPKUserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetPKUserData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetPKUserData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetPKUserData} PkGetPKUserData
         */
        PkGetPKUserData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetPKUserData)
                return object;
            var message = new $root.msgProto.PkGetPKUserData();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PkGetPKUserData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {msgProto.PkGetPKUserData} message PkGetPKUserData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetPKUserData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            return object;
        };

        /**
         * Converts this PkGetPKUserData to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetPKUserData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetPKUserData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetPKUserData;
    })();

    msgProto.PkFight = (function() {

        /**
         * Properties of a PkFight.
         * @memberof msgProto
         * @interface IPkFight
         * @property {number|Long|null} [enemyId] PkFight enemyId
         * @property {boolean|null} [isNPC] PkFight isNPC
         * @property {number|null} [fightType] PkFight fightType
         */

        /**
         * Constructs a new PkFight.
         * @memberof msgProto
         * @classdesc Represents a PkFight.
         * @implements IPkFight
         * @constructor
         * @param {msgProto.IPkFight=} [properties] Properties to set
         */
        function PkFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkFight enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkFight isNPC.
         * @member {boolean} isNPC
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.isNPC = false;

        /**
         * PkFight fightType.
         * @member {number} fightType
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.fightType = 0;

        /**
         * Encodes the specified PkFight message. Does not implicitly {@link msgProto.PkFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkFight
         * @static
         * @param {msgProto.IPkFight} message PkFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            if (message.isNPC != null && message.hasOwnProperty("isNPC"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isNPC);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fightType);
            return writer;
        };

        /**
         * Decodes a PkFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkFight} PkFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                case 2:
                    message.isNPC = reader.bool();
                    break;
                case 3:
                    message.fightType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkFight} PkFight
         */
        PkFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkFight)
                return object;
            var message = new $root.msgProto.PkFight();
            if (object.enemyId != null)
                if ($util.Long)
                    (message.enemyId = $util.Long.fromValue(object.enemyId)).unsigned = true;
                else if (typeof object.enemyId === "string")
                    message.enemyId = parseInt(object.enemyId, 10);
                else if (typeof object.enemyId === "number")
                    message.enemyId = object.enemyId;
                else if (typeof object.enemyId === "object")
                    message.enemyId = new $util.LongBits(object.enemyId.low >>> 0, object.enemyId.high >>> 0).toNumber(true);
            if (object.isNPC != null)
                message.isNPC = Boolean(object.isNPC);
            if (object.fightType != null)
                message.fightType = object.fightType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PkFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkFight
         * @static
         * @param {msgProto.PkFight} message PkFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.enemyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enemyId = options.longs === String ? "0" : 0;
                object.isNPC = false;
                object.fightType = 0;
            }
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (typeof message.enemyId === "number")
                    object.enemyId = options.longs === String ? String(message.enemyId) : message.enemyId;
                else
                    object.enemyId = options.longs === String ? $util.Long.prototype.toString.call(message.enemyId) : options.longs === Number ? new $util.LongBits(message.enemyId.low >>> 0, message.enemyId.high >>> 0).toNumber(true) : message.enemyId;
            if (message.isNPC != null && message.hasOwnProperty("isNPC"))
                object.isNPC = message.isNPC;
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                object.fightType = message.fightType;
            return object;
        };

        /**
         * Converts this PkFight to JSON.
         * @function toJSON
         * @memberof msgProto.PkFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkFight;
    })();

    msgProto.PkGetEnemyList = (function() {

        /**
         * Properties of a PkGetEnemyList.
         * @memberof msgProto
         * @interface IPkGetEnemyList
         */

        /**
         * Constructs a new PkGetEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkGetEnemyList.
         * @implements IPkGetEnemyList
         * @constructor
         * @param {msgProto.IPkGetEnemyList=} [properties] Properties to set
         */
        function PkGetEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkGetEnemyList message. Does not implicitly {@link msgProto.PkGetEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {msgProto.IPkGetEnemyList} message PkGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkGetEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetEnemyList} PkGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetEnemyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetEnemyList} PkGetEnemyList
         */
        PkGetEnemyList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetEnemyList)
                return object;
            return new $root.msgProto.PkGetEnemyList();
        };

        /**
         * Creates a plain object from a PkGetEnemyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {msgProto.PkGetEnemyList} message PkGetEnemyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetEnemyList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkGetEnemyList to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetEnemyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetEnemyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetEnemyList;
    })();

    msgProto.PkGetUserRanks = (function() {

        /**
         * Properties of a PkGetUserRanks.
         * @memberof msgProto
         * @interface IPkGetUserRanks
         */

        /**
         * Constructs a new PkGetUserRanks.
         * @memberof msgProto
         * @classdesc Represents a PkGetUserRanks.
         * @implements IPkGetUserRanks
         * @constructor
         * @param {msgProto.IPkGetUserRanks=} [properties] Properties to set
         */
        function PkGetUserRanks(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkGetUserRanks message. Does not implicitly {@link msgProto.PkGetUserRanks.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {msgProto.IPkGetUserRanks} message PkGetUserRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetUserRanks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkGetUserRanks message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetUserRanks} PkGetUserRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetUserRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetUserRanks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetUserRanks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetUserRanks} PkGetUserRanks
         */
        PkGetUserRanks.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetUserRanks)
                return object;
            return new $root.msgProto.PkGetUserRanks();
        };

        /**
         * Creates a plain object from a PkGetUserRanks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {msgProto.PkGetUserRanks} message PkGetUserRanks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetUserRanks.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkGetUserRanks to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetUserRanks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetUserRanks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetUserRanks;
    })();

    msgProto.PkGetRank = (function() {

        /**
         * Properties of a PkGetRank.
         * @memberof msgProto
         * @interface IPkGetRank
         */

        /**
         * Constructs a new PkGetRank.
         * @memberof msgProto
         * @classdesc Represents a PkGetRank.
         * @implements IPkGetRank
         * @constructor
         * @param {msgProto.IPkGetRank=} [properties] Properties to set
         */
        function PkGetRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkGetRank message. Does not implicitly {@link msgProto.PkGetRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetRank
         * @static
         * @param {msgProto.IPkGetRank} message PkGetRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkGetRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetRank} PkGetRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetRank} PkGetRank
         */
        PkGetRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetRank)
                return object;
            return new $root.msgProto.PkGetRank();
        };

        /**
         * Creates a plain object from a PkGetRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetRank
         * @static
         * @param {msgProto.PkGetRank} message PkGetRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetRank.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkGetRank to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetRank;
    })();

    msgProto.PkChangeSign = (function() {

        /**
         * Properties of a PkChangeSign.
         * @memberof msgProto
         * @interface IPkChangeSign
         * @property {string|null} [sign] PkChangeSign sign
         */

        /**
         * Constructs a new PkChangeSign.
         * @memberof msgProto
         * @classdesc Represents a PkChangeSign.
         * @implements IPkChangeSign
         * @constructor
         * @param {msgProto.IPkChangeSign=} [properties] Properties to set
         */
        function PkChangeSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkChangeSign sign.
         * @member {string} sign
         * @memberof msgProto.PkChangeSign
         * @instance
         */
        PkChangeSign.prototype.sign = "";

        /**
         * Encodes the specified PkChangeSign message. Does not implicitly {@link msgProto.PkChangeSign.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {msgProto.IPkChangeSign} message PkChangeSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkChangeSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sign);
            return writer;
        };

        /**
         * Decodes a PkChangeSign message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkChangeSign} PkChangeSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkChangeSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkChangeSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sign = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkChangeSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkChangeSign} PkChangeSign
         */
        PkChangeSign.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkChangeSign)
                return object;
            var message = new $root.msgProto.PkChangeSign();
            if (object.sign != null)
                message.sign = String(object.sign);
            return message;
        };

        /**
         * Creates a plain object from a PkChangeSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {msgProto.PkChangeSign} message PkChangeSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkChangeSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sign = "";
            if (message.sign != null && message.hasOwnProperty("sign"))
                object.sign = message.sign;
            return object;
        };

        /**
         * Converts this PkChangeSign to JSON.
         * @function toJSON
         * @memberof msgProto.PkChangeSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkChangeSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkChangeSign;
    })();

    msgProto.PkSetRead = (function() {

        /**
         * Properties of a PkSetRead.
         * @memberof msgProto
         * @interface IPkSetRead
         */

        /**
         * Constructs a new PkSetRead.
         * @memberof msgProto
         * @classdesc Represents a PkSetRead.
         * @implements IPkSetRead
         * @constructor
         * @param {msgProto.IPkSetRead=} [properties] Properties to set
         */
        function PkSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkSetRead message. Does not implicitly {@link msgProto.PkSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkSetRead
         * @static
         * @param {msgProto.IPkSetRead} message PkSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkSetRead} PkSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkSetRead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkSetRead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkSetRead} PkSetRead
         */
        PkSetRead.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkSetRead)
                return object;
            return new $root.msgProto.PkSetRead();
        };

        /**
         * Creates a plain object from a PkSetRead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkSetRead
         * @static
         * @param {msgProto.PkSetRead} message PkSetRead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkSetRead.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkSetRead to JSON.
         * @function toJSON
         * @memberof msgProto.PkSetRead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkSetRead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkSetRead;
    })();

    msgProto.PkSkip = (function() {

        /**
         * Properties of a PkSkip.
         * @memberof msgProto
         * @interface IPkSkip
         */

        /**
         * Constructs a new PkSkip.
         * @memberof msgProto
         * @classdesc Represents a PkSkip.
         * @implements IPkSkip
         * @constructor
         * @param {msgProto.IPkSkip=} [properties] Properties to set
         */
        function PkSkip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkSkip message. Does not implicitly {@link msgProto.PkSkip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkSkip
         * @static
         * @param {msgProto.IPkSkip} message PkSkip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSkip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkSkip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkSkip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkSkip} PkSkip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSkip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkSkip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkSkip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkSkip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkSkip} PkSkip
         */
        PkSkip.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkSkip)
                return object;
            return new $root.msgProto.PkSkip();
        };

        /**
         * Creates a plain object from a PkSkip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkSkip
         * @static
         * @param {msgProto.PkSkip} message PkSkip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkSkip.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkSkip to JSON.
         * @function toJSON
         * @memberof msgProto.PkSkip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkSkip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkSkip;
    })();

    msgProto.PkPickRankAward = (function() {

        /**
         * Properties of a PkPickRankAward.
         * @memberof msgProto
         * @interface IPkPickRankAward
         */

        /**
         * Constructs a new PkPickRankAward.
         * @memberof msgProto
         * @classdesc Represents a PkPickRankAward.
         * @implements IPkPickRankAward
         * @constructor
         * @param {msgProto.IPkPickRankAward=} [properties] Properties to set
         */
        function PkPickRankAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkPickRankAward message. Does not implicitly {@link msgProto.PkPickRankAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {msgProto.IPkPickRankAward} message PkPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkPickRankAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkPickRankAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkPickRankAward} PkPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkPickRankAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkPickRankAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkPickRankAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkPickRankAward} PkPickRankAward
         */
        PkPickRankAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkPickRankAward)
                return object;
            return new $root.msgProto.PkPickRankAward();
        };

        /**
         * Creates a plain object from a PkPickRankAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {msgProto.PkPickRankAward} message PkPickRankAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkPickRankAward.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkPickRankAward to JSON.
         * @function toJSON
         * @memberof msgProto.PkPickRankAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkPickRankAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkPickRankAward;
    })();

    msgProto.PkGetEnemyRecord = (function() {

        /**
         * Properties of a PkGetEnemyRecord.
         * @memberof msgProto
         * @interface IPkGetEnemyRecord
         * @property {number|Long|null} [enemyId] PkGetEnemyRecord enemyId
         */

        /**
         * Constructs a new PkGetEnemyRecord.
         * @memberof msgProto
         * @classdesc Represents a PkGetEnemyRecord.
         * @implements IPkGetEnemyRecord
         * @constructor
         * @param {msgProto.IPkGetEnemyRecord=} [properties] Properties to set
         */
        function PkGetEnemyRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkGetEnemyRecord enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkGetEnemyRecord
         * @instance
         */
        PkGetEnemyRecord.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified PkGetEnemyRecord message. Does not implicitly {@link msgProto.PkGetEnemyRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {msgProto.IPkGetEnemyRecord} message PkGetEnemyRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            return writer;
        };

        /**
         * Decodes a PkGetEnemyRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetEnemyRecord} PkGetEnemyRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetEnemyRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetEnemyRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetEnemyRecord} PkGetEnemyRecord
         */
        PkGetEnemyRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetEnemyRecord)
                return object;
            var message = new $root.msgProto.PkGetEnemyRecord();
            if (object.enemyId != null)
                if ($util.Long)
                    (message.enemyId = $util.Long.fromValue(object.enemyId)).unsigned = true;
                else if (typeof object.enemyId === "string")
                    message.enemyId = parseInt(object.enemyId, 10);
                else if (typeof object.enemyId === "number")
                    message.enemyId = object.enemyId;
                else if (typeof object.enemyId === "object")
                    message.enemyId = new $util.LongBits(object.enemyId.low >>> 0, object.enemyId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PkGetEnemyRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {msgProto.PkGetEnemyRecord} message PkGetEnemyRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetEnemyRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.enemyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enemyId = options.longs === String ? "0" : 0;
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (typeof message.enemyId === "number")
                    object.enemyId = options.longs === String ? String(message.enemyId) : message.enemyId;
                else
                    object.enemyId = options.longs === String ? $util.Long.prototype.toString.call(message.enemyId) : options.longs === Number ? new $util.LongBits(message.enemyId.low >>> 0, message.enemyId.high >>> 0).toNumber(true) : message.enemyId;
            return object;
        };

        /**
         * Converts this PkGetEnemyRecord to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetEnemyRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetEnemyRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetEnemyRecord;
    })();

    msgProto.PkGetList = (function() {

        /**
         * Properties of a PkGetList.
         * @memberof msgProto
         * @interface IPkGetList
         */

        /**
         * Constructs a new PkGetList.
         * @memberof msgProto
         * @classdesc Represents a PkGetList.
         * @implements IPkGetList
         * @constructor
         * @param {msgProto.IPkGetList=} [properties] Properties to set
         */
        function PkGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkGetList message. Does not implicitly {@link msgProto.PkGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetList
         * @static
         * @param {msgProto.IPkGetList} message PkGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetList} PkGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkGetList} PkGetList
         */
        PkGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkGetList)
                return object;
            return new $root.msgProto.PkGetList();
        };

        /**
         * Creates a plain object from a PkGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkGetList
         * @static
         * @param {msgProto.PkGetList} message PkGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkGetList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkGetList to JSON.
         * @function toJSON
         * @memberof msgProto.PkGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkGetList;
    })();

    msgProto.PkOutOpen = (function() {

        /**
         * Properties of a PkOutOpen.
         * @memberof msgProto
         * @interface IPkOutOpen
         */

        /**
         * Constructs a new PkOutOpen.
         * @memberof msgProto
         * @classdesc Represents a PkOutOpen.
         * @implements IPkOutOpen
         * @constructor
         * @param {msgProto.IPkOutOpen=} [properties] Properties to set
         */
        function PkOutOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutOpen message. Does not implicitly {@link msgProto.PkOutOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {msgProto.IPkOutOpen} message PkOutOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutOpen} PkOutOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutOpen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutOpen} PkOutOpen
         */
        PkOutOpen.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutOpen)
                return object;
            return new $root.msgProto.PkOutOpen();
        };

        /**
         * Creates a plain object from a PkOutOpen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {msgProto.PkOutOpen} message PkOutOpen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutOpen.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutOpen to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutOpen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutOpen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutOpen;
    })();

    msgProto.PkOutGetEnemyList = (function() {

        /**
         * Properties of a PkOutGetEnemyList.
         * @memberof msgProto
         * @interface IPkOutGetEnemyList
         */

        /**
         * Constructs a new PkOutGetEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetEnemyList.
         * @implements IPkOutGetEnemyList
         * @constructor
         * @param {msgProto.IPkOutGetEnemyList=} [properties] Properties to set
         */
        function PkOutGetEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetEnemyList message. Does not implicitly {@link msgProto.PkOutGetEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {msgProto.IPkOutGetEnemyList} message PkOutGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetEnemyList} PkOutGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetEnemyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetEnemyList} PkOutGetEnemyList
         */
        PkOutGetEnemyList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetEnemyList)
                return object;
            return new $root.msgProto.PkOutGetEnemyList();
        };

        /**
         * Creates a plain object from a PkOutGetEnemyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {msgProto.PkOutGetEnemyList} message PkOutGetEnemyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetEnemyList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetEnemyList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetEnemyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetEnemyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetEnemyList;
    })();

    msgProto.PkOutGetRevengeEnemyList = (function() {

        /**
         * Properties of a PkOutGetRevengeEnemyList.
         * @memberof msgProto
         * @interface IPkOutGetRevengeEnemyList
         */

        /**
         * Constructs a new PkOutGetRevengeEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRevengeEnemyList.
         * @implements IPkOutGetRevengeEnemyList
         * @constructor
         * @param {msgProto.IPkOutGetRevengeEnemyList=} [properties] Properties to set
         */
        function PkOutGetRevengeEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetRevengeEnemyList message. Does not implicitly {@link msgProto.PkOutGetRevengeEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {msgProto.IPkOutGetRevengeEnemyList} message PkOutGetRevengeEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRevengeEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetRevengeEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRevengeEnemyList} PkOutGetRevengeEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRevengeEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRevengeEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetRevengeEnemyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetRevengeEnemyList} PkOutGetRevengeEnemyList
         */
        PkOutGetRevengeEnemyList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetRevengeEnemyList)
                return object;
            return new $root.msgProto.PkOutGetRevengeEnemyList();
        };

        /**
         * Creates a plain object from a PkOutGetRevengeEnemyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {msgProto.PkOutGetRevengeEnemyList} message PkOutGetRevengeEnemyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetRevengeEnemyList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetRevengeEnemyList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetRevengeEnemyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetRevengeEnemyList;
    })();

    msgProto.PkOutRefreshEnemy = (function() {

        /**
         * Properties of a PkOutRefreshEnemy.
         * @memberof msgProto
         * @interface IPkOutRefreshEnemy
         */

        /**
         * Constructs a new PkOutRefreshEnemy.
         * @memberof msgProto
         * @classdesc Represents a PkOutRefreshEnemy.
         * @implements IPkOutRefreshEnemy
         * @constructor
         * @param {msgProto.IPkOutRefreshEnemy=} [properties] Properties to set
         */
        function PkOutRefreshEnemy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutRefreshEnemy message. Does not implicitly {@link msgProto.PkOutRefreshEnemy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {msgProto.IPkOutRefreshEnemy} message PkOutRefreshEnemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutRefreshEnemy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutRefreshEnemy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutRefreshEnemy} PkOutRefreshEnemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutRefreshEnemy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutRefreshEnemy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutRefreshEnemy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutRefreshEnemy} PkOutRefreshEnemy
         */
        PkOutRefreshEnemy.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutRefreshEnemy)
                return object;
            return new $root.msgProto.PkOutRefreshEnemy();
        };

        /**
         * Creates a plain object from a PkOutRefreshEnemy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {msgProto.PkOutRefreshEnemy} message PkOutRefreshEnemy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutRefreshEnemy.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutRefreshEnemy to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutRefreshEnemy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutRefreshEnemy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutRefreshEnemy;
    })();

    msgProto.PkOutStart = (function() {

        /**
         * Properties of a PkOutStart.
         * @memberof msgProto
         * @interface IPkOutStart
         * @property {number|Long|null} [enemyId] PkOutStart enemyId
         * @property {number|null} [fightType] PkOutStart fightType
         * @property {boolean|null} [isRevenge] PkOutStart isRevenge
         */

        /**
         * Constructs a new PkOutStart.
         * @memberof msgProto
         * @classdesc Represents a PkOutStart.
         * @implements IPkOutStart
         * @constructor
         * @param {msgProto.IPkOutStart=} [properties] Properties to set
         */
        function PkOutStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutStart enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkOutStart fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.fightType = 0;

        /**
         * PkOutStart isRevenge.
         * @member {boolean} isRevenge
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.isRevenge = false;

        /**
         * Encodes the specified PkOutStart message. Does not implicitly {@link msgProto.PkOutStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutStart
         * @static
         * @param {msgProto.IPkOutStart} message PkOutStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fightType);
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isRevenge);
            return writer;
        };

        /**
         * Decodes a PkOutStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutStart} PkOutStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                case 2:
                    message.fightType = reader.int32();
                    break;
                case 3:
                    message.isRevenge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutStart} PkOutStart
         */
        PkOutStart.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutStart)
                return object;
            var message = new $root.msgProto.PkOutStart();
            if (object.enemyId != null)
                if ($util.Long)
                    (message.enemyId = $util.Long.fromValue(object.enemyId)).unsigned = true;
                else if (typeof object.enemyId === "string")
                    message.enemyId = parseInt(object.enemyId, 10);
                else if (typeof object.enemyId === "number")
                    message.enemyId = object.enemyId;
                else if (typeof object.enemyId === "object")
                    message.enemyId = new $util.LongBits(object.enemyId.low >>> 0, object.enemyId.high >>> 0).toNumber(true);
            if (object.fightType != null)
                message.fightType = object.fightType | 0;
            if (object.isRevenge != null)
                message.isRevenge = Boolean(object.isRevenge);
            return message;
        };

        /**
         * Creates a plain object from a PkOutStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutStart
         * @static
         * @param {msgProto.PkOutStart} message PkOutStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.enemyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enemyId = options.longs === String ? "0" : 0;
                object.fightType = 0;
                object.isRevenge = false;
            }
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (typeof message.enemyId === "number")
                    object.enemyId = options.longs === String ? String(message.enemyId) : message.enemyId;
                else
                    object.enemyId = options.longs === String ? $util.Long.prototype.toString.call(message.enemyId) : options.longs === Number ? new $util.LongBits(message.enemyId.low >>> 0, message.enemyId.high >>> 0).toNumber(true) : message.enemyId;
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                object.fightType = message.fightType;
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                object.isRevenge = message.isRevenge;
            return object;
        };

        /**
         * Converts this PkOutStart to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutStart;
    })();

    msgProto.PkOutEnd = (function() {

        /**
         * Properties of a PkOutEnd.
         * @memberof msgProto
         * @interface IPkOutEnd
         * @property {boolean|null} [isWin] PkOutEnd isWin
         * @property {number|Long|null} [enemyId] PkOutEnd enemyId
         * @property {string|null} [fightData] PkOutEnd fightData
         * @property {number|null} [fightType] PkOutEnd fightType
         * @property {boolean|null} [isRevenge] PkOutEnd isRevenge
         */

        /**
         * Constructs a new PkOutEnd.
         * @memberof msgProto
         * @classdesc Represents a PkOutEnd.
         * @implements IPkOutEnd
         * @constructor
         * @param {msgProto.IPkOutEnd=} [properties] Properties to set
         */
        function PkOutEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.isWin = false;

        /**
         * PkOutEnd enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkOutEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.fightData = "";

        /**
         * PkOutEnd fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.fightType = 0;

        /**
         * PkOutEnd isRevenge.
         * @member {boolean} isRevenge
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.isRevenge = false;

        /**
         * Encodes the specified PkOutEnd message. Does not implicitly {@link msgProto.PkOutEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {msgProto.IPkOutEnd} message PkOutEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.enemyId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fightType);
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isRevenge);
            return writer;
        };

        /**
         * Decodes a PkOutEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutEnd} PkOutEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                case 2:
                    message.enemyId = reader.uint64();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                case 4:
                    message.fightType = reader.int32();
                    break;
                case 5:
                    message.isRevenge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutEnd} PkOutEnd
         */
        PkOutEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutEnd)
                return object;
            var message = new $root.msgProto.PkOutEnd();
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.enemyId != null)
                if ($util.Long)
                    (message.enemyId = $util.Long.fromValue(object.enemyId)).unsigned = true;
                else if (typeof object.enemyId === "string")
                    message.enemyId = parseInt(object.enemyId, 10);
                else if (typeof object.enemyId === "number")
                    message.enemyId = object.enemyId;
                else if (typeof object.enemyId === "object")
                    message.enemyId = new $util.LongBits(object.enemyId.low >>> 0, object.enemyId.high >>> 0).toNumber(true);
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            if (object.fightType != null)
                message.fightType = object.fightType | 0;
            if (object.isRevenge != null)
                message.isRevenge = Boolean(object.isRevenge);
            return message;
        };

        /**
         * Creates a plain object from a PkOutEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {msgProto.PkOutEnd} message PkOutEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isWin = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.enemyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enemyId = options.longs === String ? "0" : 0;
                object.fightData = "";
                object.fightType = 0;
                object.isRevenge = false;
            }
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (typeof message.enemyId === "number")
                    object.enemyId = options.longs === String ? String(message.enemyId) : message.enemyId;
                else
                    object.enemyId = options.longs === String ? $util.Long.prototype.toString.call(message.enemyId) : options.longs === Number ? new $util.LongBits(message.enemyId.low >>> 0, message.enemyId.high >>> 0).toNumber(true) : message.enemyId;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                object.fightType = message.fightType;
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                object.isRevenge = message.isRevenge;
            return object;
        };

        /**
         * Converts this PkOutEnd to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutEnd;
    })();

    msgProto.PkOutGetRankList = (function() {

        /**
         * Properties of a PkOutGetRankList.
         * @memberof msgProto
         * @interface IPkOutGetRankList
         */

        /**
         * Constructs a new PkOutGetRankList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRankList.
         * @implements IPkOutGetRankList
         * @constructor
         * @param {msgProto.IPkOutGetRankList=} [properties] Properties to set
         */
        function PkOutGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetRankList message. Does not implicitly {@link msgProto.PkOutGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {msgProto.IPkOutGetRankList} message PkOutGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRankList} PkOutGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetRankList} PkOutGetRankList
         */
        PkOutGetRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetRankList)
                return object;
            return new $root.msgProto.PkOutGetRankList();
        };

        /**
         * Creates a plain object from a PkOutGetRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {msgProto.PkOutGetRankList} message PkOutGetRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetRankList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetRankList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetRankList;
    })();

    msgProto.PkOutGetMyRank = (function() {

        /**
         * Properties of a PkOutGetMyRank.
         * @memberof msgProto
         * @interface IPkOutGetMyRank
         */

        /**
         * Constructs a new PkOutGetMyRank.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetMyRank.
         * @implements IPkOutGetMyRank
         * @constructor
         * @param {msgProto.IPkOutGetMyRank=} [properties] Properties to set
         */
        function PkOutGetMyRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetMyRank message. Does not implicitly {@link msgProto.PkOutGetMyRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {msgProto.IPkOutGetMyRank} message PkOutGetMyRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetMyRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetMyRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetMyRank} PkOutGetMyRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetMyRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetMyRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetMyRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetMyRank} PkOutGetMyRank
         */
        PkOutGetMyRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetMyRank)
                return object;
            return new $root.msgProto.PkOutGetMyRank();
        };

        /**
         * Creates a plain object from a PkOutGetMyRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {msgProto.PkOutGetMyRank} message PkOutGetMyRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetMyRank.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetMyRank to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetMyRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetMyRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetMyRank;
    })();

    msgProto.PkOutGetPkRecordList = (function() {

        /**
         * Properties of a PkOutGetPkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetPkRecordList
         */

        /**
         * Constructs a new PkOutGetPkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetPkRecordList.
         * @implements IPkOutGetPkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetPkRecordList=} [properties] Properties to set
         */
        function PkOutGetPkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetPkRecordList message. Does not implicitly {@link msgProto.PkOutGetPkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {msgProto.IPkOutGetPkRecordList} message PkOutGetPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetPkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetPkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetPkRecordList} PkOutGetPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetPkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetPkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetPkRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetPkRecordList} PkOutGetPkRecordList
         */
        PkOutGetPkRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetPkRecordList)
                return object;
            return new $root.msgProto.PkOutGetPkRecordList();
        };

        /**
         * Creates a plain object from a PkOutGetPkRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {msgProto.PkOutGetPkRecordList} message PkOutGetPkRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetPkRecordList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetPkRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetPkRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetPkRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetPkRecordList;
    })();

    msgProto.PkOutGetRankPkRecordList = (function() {

        /**
         * Properties of a PkOutGetRankPkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetRankPkRecordList
         */

        /**
         * Constructs a new PkOutGetRankPkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRankPkRecordList.
         * @implements IPkOutGetRankPkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetRankPkRecordList=} [properties] Properties to set
         */
        function PkOutGetRankPkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetRankPkRecordList message. Does not implicitly {@link msgProto.PkOutGetRankPkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {msgProto.IPkOutGetRankPkRecordList} message PkOutGetRankPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankPkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetRankPkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRankPkRecordList} PkOutGetRankPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankPkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRankPkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetRankPkRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetRankPkRecordList} PkOutGetRankPkRecordList
         */
        PkOutGetRankPkRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetRankPkRecordList)
                return object;
            return new $root.msgProto.PkOutGetRankPkRecordList();
        };

        /**
         * Creates a plain object from a PkOutGetRankPkRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {msgProto.PkOutGetRankPkRecordList} message PkOutGetRankPkRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetRankPkRecordList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetRankPkRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetRankPkRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetRankPkRecordList;
    })();

    msgProto.PkOutSetPkRecordRead = (function() {

        /**
         * Properties of a PkOutSetPkRecordRead.
         * @memberof msgProto
         * @interface IPkOutSetPkRecordRead
         */

        /**
         * Constructs a new PkOutSetPkRecordRead.
         * @memberof msgProto
         * @classdesc Represents a PkOutSetPkRecordRead.
         * @implements IPkOutSetPkRecordRead
         * @constructor
         * @param {msgProto.IPkOutSetPkRecordRead=} [properties] Properties to set
         */
        function PkOutSetPkRecordRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutSetPkRecordRead message. Does not implicitly {@link msgProto.PkOutSetPkRecordRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {msgProto.IPkOutSetPkRecordRead} message PkOutSetPkRecordRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutSetPkRecordRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutSetPkRecordRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutSetPkRecordRead} PkOutSetPkRecordRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutSetPkRecordRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutSetPkRecordRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutSetPkRecordRead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutSetPkRecordRead} PkOutSetPkRecordRead
         */
        PkOutSetPkRecordRead.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutSetPkRecordRead)
                return object;
            return new $root.msgProto.PkOutSetPkRecordRead();
        };

        /**
         * Creates a plain object from a PkOutSetPkRecordRead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {msgProto.PkOutSetPkRecordRead} message PkOutSetPkRecordRead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutSetPkRecordRead.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutSetPkRecordRead to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutSetPkRecordRead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutSetPkRecordRead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutSetPkRecordRead;
    })();

    msgProto.PkOutDealRecord = (function() {

        /**
         * Properties of a PkOutDealRecord.
         * @memberof msgProto
         * @interface IPkOutDealRecord
         * @property {number|null} [fightType] PkOutDealRecord fightType
         */

        /**
         * Constructs a new PkOutDealRecord.
         * @memberof msgProto
         * @classdesc Represents a PkOutDealRecord.
         * @implements IPkOutDealRecord
         * @constructor
         * @param {msgProto.IPkOutDealRecord=} [properties] Properties to set
         */
        function PkOutDealRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutDealRecord fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutDealRecord
         * @instance
         */
        PkOutDealRecord.prototype.fightType = 0;

        /**
         * Encodes the specified PkOutDealRecord message. Does not implicitly {@link msgProto.PkOutDealRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {msgProto.IPkOutDealRecord} message PkOutDealRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutDealRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fightType);
            return writer;
        };

        /**
         * Decodes a PkOutDealRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutDealRecord} PkOutDealRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutDealRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutDealRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fightType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutDealRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutDealRecord} PkOutDealRecord
         */
        PkOutDealRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutDealRecord)
                return object;
            var message = new $root.msgProto.PkOutDealRecord();
            if (object.fightType != null)
                message.fightType = object.fightType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PkOutDealRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {msgProto.PkOutDealRecord} message PkOutDealRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutDealRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fightType = 0;
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                object.fightType = message.fightType;
            return object;
        };

        /**
         * Converts this PkOutDealRecord to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutDealRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutDealRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutDealRecord;
    })();

    msgProto.PkOutClearPkValue = (function() {

        /**
         * Properties of a PkOutClearPkValue.
         * @memberof msgProto
         * @interface IPkOutClearPkValue
         */

        /**
         * Constructs a new PkOutClearPkValue.
         * @memberof msgProto
         * @classdesc Represents a PkOutClearPkValue.
         * @implements IPkOutClearPkValue
         * @constructor
         * @param {msgProto.IPkOutClearPkValue=} [properties] Properties to set
         */
        function PkOutClearPkValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutClearPkValue message. Does not implicitly {@link msgProto.PkOutClearPkValue.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {msgProto.IPkOutClearPkValue} message PkOutClearPkValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutClearPkValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutClearPkValue message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutClearPkValue} PkOutClearPkValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutClearPkValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutClearPkValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutClearPkValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutClearPkValue} PkOutClearPkValue
         */
        PkOutClearPkValue.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutClearPkValue)
                return object;
            return new $root.msgProto.PkOutClearPkValue();
        };

        /**
         * Creates a plain object from a PkOutClearPkValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {msgProto.PkOutClearPkValue} message PkOutClearPkValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutClearPkValue.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutClearPkValue to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutClearPkValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutClearPkValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutClearPkValue;
    })();

    msgProto.PkOutResetBePkKill = (function() {

        /**
         * Properties of a PkOutResetBePkKill.
         * @memberof msgProto
         * @interface IPkOutResetBePkKill
         */

        /**
         * Constructs a new PkOutResetBePkKill.
         * @memberof msgProto
         * @classdesc Represents a PkOutResetBePkKill.
         * @implements IPkOutResetBePkKill
         * @constructor
         * @param {msgProto.IPkOutResetBePkKill=} [properties] Properties to set
         */
        function PkOutResetBePkKill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutResetBePkKill message. Does not implicitly {@link msgProto.PkOutResetBePkKill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {msgProto.IPkOutResetBePkKill} message PkOutResetBePkKill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutResetBePkKill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutResetBePkKill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutResetBePkKill} PkOutResetBePkKill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutResetBePkKill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutResetBePkKill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutResetBePkKill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutResetBePkKill} PkOutResetBePkKill
         */
        PkOutResetBePkKill.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutResetBePkKill)
                return object;
            return new $root.msgProto.PkOutResetBePkKill();
        };

        /**
         * Creates a plain object from a PkOutResetBePkKill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {msgProto.PkOutResetBePkKill} message PkOutResetBePkKill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutResetBePkKill.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutResetBePkKill to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutResetBePkKill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutResetBePkKill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutResetBePkKill;
    })();

    msgProto.PkOutIncognito = (function() {

        /**
         * Properties of a PkOutIncognito.
         * @memberof msgProto
         * @interface IPkOutIncognito
         */

        /**
         * Constructs a new PkOutIncognito.
         * @memberof msgProto
         * @classdesc Represents a PkOutIncognito.
         * @implements IPkOutIncognito
         * @constructor
         * @param {msgProto.IPkOutIncognito=} [properties] Properties to set
         */
        function PkOutIncognito(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutIncognito message. Does not implicitly {@link msgProto.PkOutIncognito.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {msgProto.IPkOutIncognito} message PkOutIncognito message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutIncognito.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutIncognito message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutIncognito} PkOutIncognito
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutIncognito.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutIncognito();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutIncognito message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutIncognito} PkOutIncognito
         */
        PkOutIncognito.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutIncognito)
                return object;
            return new $root.msgProto.PkOutIncognito();
        };

        /**
         * Creates a plain object from a PkOutIncognito message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {msgProto.PkOutIncognito} message PkOutIncognito
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutIncognito.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutIncognito to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutIncognito
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutIncognito.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutIncognito;
    })();

    msgProto.PkOutGetTreasurePkRecordList = (function() {

        /**
         * Properties of a PkOutGetTreasurePkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetTreasurePkRecordList
         */

        /**
         * Constructs a new PkOutGetTreasurePkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetTreasurePkRecordList.
         * @implements IPkOutGetTreasurePkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetTreasurePkRecordList=} [properties] Properties to set
         */
        function PkOutGetTreasurePkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PkOutGetTreasurePkRecordList message. Does not implicitly {@link msgProto.PkOutGetTreasurePkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {msgProto.IPkOutGetTreasurePkRecordList} message PkOutGetTreasurePkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetTreasurePkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PkOutGetTreasurePkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetTreasurePkRecordList} PkOutGetTreasurePkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetTreasurePkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetTreasurePkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PkOutGetTreasurePkRecordList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PkOutGetTreasurePkRecordList} PkOutGetTreasurePkRecordList
         */
        PkOutGetTreasurePkRecordList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PkOutGetTreasurePkRecordList)
                return object;
            return new $root.msgProto.PkOutGetTreasurePkRecordList();
        };

        /**
         * Creates a plain object from a PkOutGetTreasurePkRecordList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {msgProto.PkOutGetTreasurePkRecordList} message PkOutGetTreasurePkRecordList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PkOutGetTreasurePkRecordList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PkOutGetTreasurePkRecordList to JSON.
         * @function toJSON
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PkOutGetTreasurePkRecordList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PkOutGetTreasurePkRecordList;
    })();

    msgProto.ShopGetInfo = (function() {

        /**
         * Properties of a ShopGetInfo.
         * @memberof msgProto
         * @interface IShopGetInfo
         * @property {number|null} [type] ShopGetInfo type
         */

        /**
         * Constructs a new ShopGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ShopGetInfo.
         * @implements IShopGetInfo
         * @constructor
         * @param {msgProto.IShopGetInfo=} [properties] Properties to set
         */
        function ShopGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopGetInfo type.
         * @member {number} type
         * @memberof msgProto.ShopGetInfo
         * @instance
         */
        ShopGetInfo.prototype.type = 0;

        /**
         * Encodes the specified ShopGetInfo message. Does not implicitly {@link msgProto.ShopGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {msgProto.IShopGetInfo} message ShopGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Decodes a ShopGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopGetInfo} ShopGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ShopGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ShopGetInfo} ShopGetInfo
         */
        ShopGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ShopGetInfo)
                return object;
            var message = new $root.msgProto.ShopGetInfo();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShopGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {msgProto.ShopGetInfo} message ShopGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShopGetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this ShopGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ShopGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShopGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShopGetInfo;
    })();

    msgProto.ShopRefreshExShop = (function() {

        /**
         * Properties of a ShopRefreshExShop.
         * @memberof msgProto
         * @interface IShopRefreshExShop
         * @property {number|null} [type] ShopRefreshExShop type
         * @property {boolean|null} [lvlRefresh] ShopRefreshExShop lvlRefresh
         */

        /**
         * Constructs a new ShopRefreshExShop.
         * @memberof msgProto
         * @classdesc Represents a ShopRefreshExShop.
         * @implements IShopRefreshExShop
         * @constructor
         * @param {msgProto.IShopRefreshExShop=} [properties] Properties to set
         */
        function ShopRefreshExShop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopRefreshExShop type.
         * @member {number} type
         * @memberof msgProto.ShopRefreshExShop
         * @instance
         */
        ShopRefreshExShop.prototype.type = 0;

        /**
         * ShopRefreshExShop lvlRefresh.
         * @member {boolean} lvlRefresh
         * @memberof msgProto.ShopRefreshExShop
         * @instance
         */
        ShopRefreshExShop.prototype.lvlRefresh = false;

        /**
         * Encodes the specified ShopRefreshExShop message. Does not implicitly {@link msgProto.ShopRefreshExShop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {msgProto.IShopRefreshExShop} message ShopRefreshExShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopRefreshExShop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.lvlRefresh != null && message.hasOwnProperty("lvlRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.lvlRefresh);
            return writer;
        };

        /**
         * Decodes a ShopRefreshExShop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopRefreshExShop} ShopRefreshExShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopRefreshExShop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopRefreshExShop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.lvlRefresh = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ShopRefreshExShop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ShopRefreshExShop} ShopRefreshExShop
         */
        ShopRefreshExShop.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ShopRefreshExShop)
                return object;
            var message = new $root.msgProto.ShopRefreshExShop();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.lvlRefresh != null)
                message.lvlRefresh = Boolean(object.lvlRefresh);
            return message;
        };

        /**
         * Creates a plain object from a ShopRefreshExShop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {msgProto.ShopRefreshExShop} message ShopRefreshExShop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShopRefreshExShop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.lvlRefresh = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.lvlRefresh != null && message.hasOwnProperty("lvlRefresh"))
                object.lvlRefresh = message.lvlRefresh;
            return object;
        };

        /**
         * Converts this ShopRefreshExShop to JSON.
         * @function toJSON
         * @memberof msgProto.ShopRefreshExShop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShopRefreshExShop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShopRefreshExShop;
    })();

    msgProto.ShopBuy = (function() {

        /**
         * Properties of a ShopBuy.
         * @memberof msgProto
         * @interface IShopBuy
         * @property {number|null} [index] ShopBuy index
         * @property {number|null} [type] ShopBuy type
         * @property {number|null} [num] ShopBuy num
         */

        /**
         * Constructs a new ShopBuy.
         * @memberof msgProto
         * @classdesc Represents a ShopBuy.
         * @implements IShopBuy
         * @constructor
         * @param {msgProto.IShopBuy=} [properties] Properties to set
         */
        function ShopBuy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopBuy index.
         * @member {number} index
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.index = 0;

        /**
         * ShopBuy type.
         * @member {number} type
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.type = 0;

        /**
         * ShopBuy num.
         * @member {number} num
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.num = 0;

        /**
         * Encodes the specified ShopBuy message. Does not implicitly {@link msgProto.ShopBuy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopBuy
         * @static
         * @param {msgProto.IShopBuy} message ShopBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.num != null && message.hasOwnProperty("num"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num);
            return writer;
        };

        /**
         * Decodes a ShopBuy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopBuy} ShopBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopBuy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ShopBuy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ShopBuy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ShopBuy} ShopBuy
         */
        ShopBuy.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ShopBuy)
                return object;
            var message = new $root.msgProto.ShopBuy();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShopBuy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ShopBuy
         * @static
         * @param {msgProto.ShopBuy} message ShopBuy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShopBuy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.type = 0;
                object.num = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this ShopBuy to JSON.
         * @function toJSON
         * @memberof msgProto.ShopBuy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShopBuy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShopBuy;
    })();

    msgProto.ShopBuyAll = (function() {

        /**
         * Properties of a ShopBuyAll.
         * @memberof msgProto
         * @interface IShopBuyAll
         * @property {number|null} [type] ShopBuyAll type
         */

        /**
         * Constructs a new ShopBuyAll.
         * @memberof msgProto
         * @classdesc Represents a ShopBuyAll.
         * @implements IShopBuyAll
         * @constructor
         * @param {msgProto.IShopBuyAll=} [properties] Properties to set
         */
        function ShopBuyAll(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopBuyAll type.
         * @member {number} type
         * @memberof msgProto.ShopBuyAll
         * @instance
         */
        ShopBuyAll.prototype.type = 0;

        /**
         * Encodes the specified ShopBuyAll message. Does not implicitly {@link msgProto.ShopBuyAll.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {msgProto.IShopBuyAll} message ShopBuyAll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuyAll.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Decodes a ShopBuyAll message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopBuyAll} ShopBuyAll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuyAll.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopBuyAll();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ShopBuyAll message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ShopBuyAll} ShopBuyAll
         */
        ShopBuyAll.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ShopBuyAll)
                return object;
            var message = new $root.msgProto.ShopBuyAll();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a ShopBuyAll message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {msgProto.ShopBuyAll} message ShopBuyAll
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShopBuyAll.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this ShopBuyAll to JSON.
         * @function toJSON
         * @memberof msgProto.ShopBuyAll
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShopBuyAll.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShopBuyAll;
    })();

    msgProto.CopyGetInfo = (function() {

        /**
         * Properties of a CopyGetInfo.
         * @memberof msgProto
         * @interface ICopyGetInfo
         * @property {number|null} [type] CopyGetInfo type
         */

        /**
         * Constructs a new CopyGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CopyGetInfo.
         * @implements ICopyGetInfo
         * @constructor
         * @param {msgProto.ICopyGetInfo=} [properties] Properties to set
         */
        function CopyGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGetInfo type.
         * @member {number} type
         * @memberof msgProto.CopyGetInfo
         * @instance
         */
        CopyGetInfo.prototype.type = 0;

        /**
         * Encodes the specified CopyGetInfo message. Does not implicitly {@link msgProto.CopyGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {msgProto.ICopyGetInfo} message CopyGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Decodes a CopyGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGetInfo} CopyGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyGetInfo} CopyGetInfo
         */
        CopyGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyGetInfo)
                return object;
            var message = new $root.msgProto.CopyGetInfo();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {msgProto.CopyGetInfo} message CopyGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyGetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this CopyGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.CopyGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyGetInfo;
    })();

    msgProto.CopyBuyCopyCount = (function() {

        /**
         * Properties of a CopyBuyCopyCount.
         * @memberof msgProto
         * @interface ICopyBuyCopyCount
         * @property {number|null} [type] CopyBuyCopyCount type
         * @property {number|null} [copyId] CopyBuyCopyCount copyId
         */

        /**
         * Constructs a new CopyBuyCopyCount.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyCopyCount.
         * @implements ICopyBuyCopyCount
         * @constructor
         * @param {msgProto.ICopyBuyCopyCount=} [properties] Properties to set
         */
        function CopyBuyCopyCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyBuyCopyCount type.
         * @member {number} type
         * @memberof msgProto.CopyBuyCopyCount
         * @instance
         */
        CopyBuyCopyCount.prototype.type = 0;

        /**
         * CopyBuyCopyCount copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyBuyCopyCount
         * @instance
         */
        CopyBuyCopyCount.prototype.copyId = 0;

        /**
         * Encodes the specified CopyBuyCopyCount message. Does not implicitly {@link msgProto.CopyBuyCopyCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {msgProto.ICopyBuyCopyCount} message CopyBuyCopyCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyCopyCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.copyId);
            return writer;
        };

        /**
         * Decodes a CopyBuyCopyCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyCopyCount} CopyBuyCopyCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyCopyCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyCopyCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyBuyCopyCount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyBuyCopyCount} CopyBuyCopyCount
         */
        CopyBuyCopyCount.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyBuyCopyCount)
                return object;
            var message = new $root.msgProto.CopyBuyCopyCount();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyBuyCopyCount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {msgProto.CopyBuyCopyCount} message CopyBuyCopyCount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyBuyCopyCount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.copyId = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            return object;
        };

        /**
         * Converts this CopyBuyCopyCount to JSON.
         * @function toJSON
         * @memberof msgProto.CopyBuyCopyCount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyBuyCopyCount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyBuyCopyCount;
    })();

    msgProto.CopyBuyEquipTessera = (function() {

        /**
         * Properties of a CopyBuyEquipTessera.
         * @memberof msgProto
         * @interface ICopyBuyEquipTessera
         */

        /**
         * Constructs a new CopyBuyEquipTessera.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyEquipTessera.
         * @implements ICopyBuyEquipTessera
         * @constructor
         * @param {msgProto.ICopyBuyEquipTessera=} [properties] Properties to set
         */
        function CopyBuyEquipTessera(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CopyBuyEquipTessera message. Does not implicitly {@link msgProto.CopyBuyEquipTessera.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {msgProto.ICopyBuyEquipTessera} message CopyBuyEquipTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyEquipTessera.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CopyBuyEquipTessera message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyEquipTessera} CopyBuyEquipTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyEquipTessera.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyEquipTessera();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyBuyEquipTessera message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyBuyEquipTessera} CopyBuyEquipTessera
         */
        CopyBuyEquipTessera.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyBuyEquipTessera)
                return object;
            return new $root.msgProto.CopyBuyEquipTessera();
        };

        /**
         * Creates a plain object from a CopyBuyEquipTessera message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {msgProto.CopyBuyEquipTessera} message CopyBuyEquipTessera
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyBuyEquipTessera.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CopyBuyEquipTessera to JSON.
         * @function toJSON
         * @memberof msgProto.CopyBuyEquipTessera
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyBuyEquipTessera.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyBuyEquipTessera;
    })();

    msgProto.CopyBuyRealmTessera = (function() {

        /**
         * Properties of a CopyBuyRealmTessera.
         * @memberof msgProto
         * @interface ICopyBuyRealmTessera
         */

        /**
         * Constructs a new CopyBuyRealmTessera.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyRealmTessera.
         * @implements ICopyBuyRealmTessera
         * @constructor
         * @param {msgProto.ICopyBuyRealmTessera=} [properties] Properties to set
         */
        function CopyBuyRealmTessera(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CopyBuyRealmTessera message. Does not implicitly {@link msgProto.CopyBuyRealmTessera.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {msgProto.ICopyBuyRealmTessera} message CopyBuyRealmTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyRealmTessera.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CopyBuyRealmTessera message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyRealmTessera} CopyBuyRealmTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyRealmTessera.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyRealmTessera();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyBuyRealmTessera message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyBuyRealmTessera} CopyBuyRealmTessera
         */
        CopyBuyRealmTessera.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyBuyRealmTessera)
                return object;
            return new $root.msgProto.CopyBuyRealmTessera();
        };

        /**
         * Creates a plain object from a CopyBuyRealmTessera message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {msgProto.CopyBuyRealmTessera} message CopyBuyRealmTessera
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyBuyRealmTessera.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CopyBuyRealmTessera to JSON.
         * @function toJSON
         * @memberof msgProto.CopyBuyRealmTessera
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyBuyRealmTessera.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyBuyRealmTessera;
    })();

    msgProto.CopyCopyWipe = (function() {

        /**
         * Properties of a CopyCopyWipe.
         * @memberof msgProto
         * @interface ICopyCopyWipe
         * @property {number|null} [copyId] CopyCopyWipe copyId
         */

        /**
         * Constructs a new CopyCopyWipe.
         * @memberof msgProto
         * @classdesc Represents a CopyCopyWipe.
         * @implements ICopyCopyWipe
         * @constructor
         * @param {msgProto.ICopyCopyWipe=} [properties] Properties to set
         */
        function CopyCopyWipe(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyCopyWipe copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyCopyWipe
         * @instance
         */
        CopyCopyWipe.prototype.copyId = 0;

        /**
         * Encodes the specified CopyCopyWipe message. Does not implicitly {@link msgProto.CopyCopyWipe.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {msgProto.ICopyCopyWipe} message CopyCopyWipe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyCopyWipe.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Decodes a CopyCopyWipe message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyCopyWipe} CopyCopyWipe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyCopyWipe.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyCopyWipe();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyCopyWipe message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyCopyWipe} CopyCopyWipe
         */
        CopyCopyWipe.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyCopyWipe)
                return object;
            var message = new $root.msgProto.CopyCopyWipe();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyCopyWipe message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {msgProto.CopyCopyWipe} message CopyCopyWipe
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyCopyWipe.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.copyId = 0;
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            return object;
        };

        /**
         * Converts this CopyCopyWipe to JSON.
         * @function toJSON
         * @memberof msgProto.CopyCopyWipe
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyCopyWipe.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyCopyWipe;
    })();

    msgProto.Copy_start = (function() {

        /**
         * Properties of a Copy_start.
         * @memberof msgProto
         * @interface ICopy_start
         * @property {number|null} [copyId] Copy_start copyId
         * @property {string|null} [biCost] Copy_start biCost
         */

        /**
         * Constructs a new Copy_start.
         * @memberof msgProto
         * @classdesc Represents a Copy_start.
         * @implements ICopy_start
         * @constructor
         * @param {msgProto.ICopy_start=} [properties] Properties to set
         */
        function Copy_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Copy_start copyId.
         * @member {number} copyId
         * @memberof msgProto.Copy_start
         * @instance
         */
        Copy_start.prototype.copyId = 0;

        /**
         * Copy_start biCost.
         * @member {string} biCost
         * @memberof msgProto.Copy_start
         * @instance
         */
        Copy_start.prototype.biCost = "";

        /**
         * Encodes the specified Copy_start message. Does not implicitly {@link msgProto.Copy_start.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Copy_start
         * @static
         * @param {msgProto.ICopy_start} message Copy_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Copy_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.biCost != null && message.hasOwnProperty("biCost"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.biCost);
            return writer;
        };

        /**
         * Decodes a Copy_start message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Copy_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Copy_start} Copy_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Copy_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Copy_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.biCost = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a Copy_start message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.Copy_start
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.Copy_start} Copy_start
         */
        Copy_start.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.Copy_start)
                return object;
            var message = new $root.msgProto.Copy_start();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.biCost != null)
                message.biCost = String(object.biCost);
            return message;
        };

        /**
         * Creates a plain object from a Copy_start message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.Copy_start
         * @static
         * @param {msgProto.Copy_start} message Copy_start
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Copy_start.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.biCost = "";
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.biCost != null && message.hasOwnProperty("biCost"))
                object.biCost = message.biCost;
            return object;
        };

        /**
         * Converts this Copy_start to JSON.
         * @function toJSON
         * @memberof msgProto.Copy_start
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Copy_start.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Copy_start;
    })();

    msgProto.CopyEnd = (function() {

        /**
         * Properties of a CopyEnd.
         * @memberof msgProto
         * @interface ICopyEnd
         * @property {number|null} [copyId] CopyEnd copyId
         * @property {string|null} [fightData] CopyEnd fightData
         * @property {boolean|null} [isWin] CopyEnd isWin
         */

        /**
         * Constructs a new CopyEnd.
         * @memberof msgProto
         * @classdesc Represents a CopyEnd.
         * @implements ICopyEnd
         * @constructor
         * @param {msgProto.ICopyEnd=} [properties] Properties to set
         */
        function CopyEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyEnd copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.copyId = 0;

        /**
         * CopyEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.fightData = "";

        /**
         * CopyEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.isWin = false;

        /**
         * Encodes the specified CopyEnd message. Does not implicitly {@link msgProto.CopyEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyEnd
         * @static
         * @param {msgProto.ICopyEnd} message CopyEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fightData);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            return writer;
        };

        /**
         * Decodes a CopyEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyEnd} CopyEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.fightData = reader.string();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyEnd} CopyEnd
         */
        CopyEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyEnd)
                return object;
            var message = new $root.msgProto.CopyEnd();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            return message;
        };

        /**
         * Creates a plain object from a CopyEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyEnd
         * @static
         * @param {msgProto.CopyEnd} message CopyEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.fightData = "";
                object.isWin = false;
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            return object;
        };

        /**
         * Converts this CopyEnd to JSON.
         * @function toJSON
         * @memberof msgProto.CopyEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyEnd;
    })();

    msgProto.CopyUpdateWinningStreak = (function() {

        /**
         * Properties of a CopyUpdateWinningStreak.
         * @memberof msgProto
         * @interface ICopyUpdateWinningStreak
         * @property {number|null} [copyId] CopyUpdateWinningStreak copyId
         */

        /**
         * Constructs a new CopyUpdateWinningStreak.
         * @memberof msgProto
         * @classdesc Represents a CopyUpdateWinningStreak.
         * @implements ICopyUpdateWinningStreak
         * @constructor
         * @param {msgProto.ICopyUpdateWinningStreak=} [properties] Properties to set
         */
        function CopyUpdateWinningStreak(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyUpdateWinningStreak copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyUpdateWinningStreak
         * @instance
         */
        CopyUpdateWinningStreak.prototype.copyId = 0;

        /**
         * Encodes the specified CopyUpdateWinningStreak message. Does not implicitly {@link msgProto.CopyUpdateWinningStreak.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {msgProto.ICopyUpdateWinningStreak} message CopyUpdateWinningStreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyUpdateWinningStreak.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Decodes a CopyUpdateWinningStreak message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyUpdateWinningStreak} CopyUpdateWinningStreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyUpdateWinningStreak.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyUpdateWinningStreak();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyUpdateWinningStreak message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyUpdateWinningStreak} CopyUpdateWinningStreak
         */
        CopyUpdateWinningStreak.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyUpdateWinningStreak)
                return object;
            var message = new $root.msgProto.CopyUpdateWinningStreak();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyUpdateWinningStreak message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {msgProto.CopyUpdateWinningStreak} message CopyUpdateWinningStreak
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyUpdateWinningStreak.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.copyId = 0;
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            return object;
        };

        /**
         * Converts this CopyUpdateWinningStreak to JSON.
         * @function toJSON
         * @memberof msgProto.CopyUpdateWinningStreak
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyUpdateWinningStreak.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyUpdateWinningStreak;
    })();

    msgProto.CopySetRead = (function() {

        /**
         * Properties of a CopySetRead.
         * @memberof msgProto
         * @interface ICopySetRead
         * @property {number|null} [copyId] CopySetRead copyId
         */

        /**
         * Constructs a new CopySetRead.
         * @memberof msgProto
         * @classdesc Represents a CopySetRead.
         * @implements ICopySetRead
         * @constructor
         * @param {msgProto.ICopySetRead=} [properties] Properties to set
         */
        function CopySetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopySetRead copyId.
         * @member {number} copyId
         * @memberof msgProto.CopySetRead
         * @instance
         */
        CopySetRead.prototype.copyId = 0;

        /**
         * Encodes the specified CopySetRead message. Does not implicitly {@link msgProto.CopySetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopySetRead
         * @static
         * @param {msgProto.ICopySetRead} message CopySetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopySetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Decodes a CopySetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopySetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopySetRead} CopySetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopySetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopySetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopySetRead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopySetRead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopySetRead} CopySetRead
         */
        CopySetRead.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopySetRead)
                return object;
            var message = new $root.msgProto.CopySetRead();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopySetRead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopySetRead
         * @static
         * @param {msgProto.CopySetRead} message CopySetRead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopySetRead.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.copyId = 0;
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            return object;
        };

        /**
         * Converts this CopySetRead to JSON.
         * @function toJSON
         * @memberof msgProto.CopySetRead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopySetRead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopySetRead;
    })();

    msgProto.CopyGuildStart = (function() {

        /**
         * Properties of a CopyGuildStart.
         * @memberof msgProto
         * @interface ICopyGuildStart
         * @property {number|null} [copyId] CopyGuildStart copyId
         * @property {number|null} [bossId] CopyGuildStart bossId
         */

        /**
         * Constructs a new CopyGuildStart.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildStart.
         * @implements ICopyGuildStart
         * @constructor
         * @param {msgProto.ICopyGuildStart=} [properties] Properties to set
         */
        function CopyGuildStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildStart copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyGuildStart
         * @instance
         */
        CopyGuildStart.prototype.copyId = 0;

        /**
         * CopyGuildStart bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyGuildStart
         * @instance
         */
        CopyGuildStart.prototype.bossId = 0;

        /**
         * Encodes the specified CopyGuildStart message. Does not implicitly {@link msgProto.CopyGuildStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {msgProto.ICopyGuildStart} message CopyGuildStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a CopyGuildStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildStart} CopyGuildStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyGuildStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyGuildStart} CopyGuildStart
         */
        CopyGuildStart.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyGuildStart)
                return object;
            var message = new $root.msgProto.CopyGuildStart();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyGuildStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {msgProto.CopyGuildStart} message CopyGuildStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyGuildStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.bossId = 0;
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this CopyGuildStart to JSON.
         * @function toJSON
         * @memberof msgProto.CopyGuildStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyGuildStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyGuildStart;
    })();

    msgProto.CopyGuildEnd = (function() {

        /**
         * Properties of a CopyGuildEnd.
         * @memberof msgProto
         * @interface ICopyGuildEnd
         * @property {number|null} [copyId] CopyGuildEnd copyId
         * @property {number|null} [bossId] CopyGuildEnd bossId
         * @property {boolean|null} [isWin] CopyGuildEnd isWin
         */

        /**
         * Constructs a new CopyGuildEnd.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildEnd.
         * @implements ICopyGuildEnd
         * @constructor
         * @param {msgProto.ICopyGuildEnd=} [properties] Properties to set
         */
        function CopyGuildEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildEnd copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.copyId = 0;

        /**
         * CopyGuildEnd bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.bossId = 0;

        /**
         * CopyGuildEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.isWin = false;

        /**
         * Encodes the specified CopyGuildEnd message. Does not implicitly {@link msgProto.CopyGuildEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {msgProto.ICopyGuildEnd} message CopyGuildEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bossId);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            return writer;
        };

        /**
         * Decodes a CopyGuildEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildEnd} CopyGuildEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.bossId = reader.int32();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyGuildEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyGuildEnd} CopyGuildEnd
         */
        CopyGuildEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyGuildEnd)
                return object;
            var message = new $root.msgProto.CopyGuildEnd();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            return message;
        };

        /**
         * Creates a plain object from a CopyGuildEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {msgProto.CopyGuildEnd} message CopyGuildEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyGuildEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.copyId = 0;
                object.bossId = 0;
                object.isWin = false;
            }
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            return object;
        };

        /**
         * Converts this CopyGuildEnd to JSON.
         * @function toJSON
         * @memberof msgProto.CopyGuildEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyGuildEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyGuildEnd;
    })();

    msgProto.CopyGuildCopyAward = (function() {

        /**
         * Properties of a CopyGuildCopyAward.
         * @memberof msgProto
         * @interface ICopyGuildCopyAward
         * @property {number|null} [type] CopyGuildCopyAward type
         * @property {number|null} [typeId] CopyGuildCopyAward typeId
         */

        /**
         * Constructs a new CopyGuildCopyAward.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildCopyAward.
         * @implements ICopyGuildCopyAward
         * @constructor
         * @param {msgProto.ICopyGuildCopyAward=} [properties] Properties to set
         */
        function CopyGuildCopyAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildCopyAward type.
         * @member {number} type
         * @memberof msgProto.CopyGuildCopyAward
         * @instance
         */
        CopyGuildCopyAward.prototype.type = 0;

        /**
         * CopyGuildCopyAward typeId.
         * @member {number} typeId
         * @memberof msgProto.CopyGuildCopyAward
         * @instance
         */
        CopyGuildCopyAward.prototype.typeId = 0;

        /**
         * Encodes the specified CopyGuildCopyAward message. Does not implicitly {@link msgProto.CopyGuildCopyAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {msgProto.ICopyGuildCopyAward} message CopyGuildCopyAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.typeId);
            return writer;
        };

        /**
         * Decodes a CopyGuildCopyAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildCopyAward} CopyGuildCopyAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildCopyAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.typeId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyGuildCopyAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyGuildCopyAward} CopyGuildCopyAward
         */
        CopyGuildCopyAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyGuildCopyAward)
                return object;
            var message = new $root.msgProto.CopyGuildCopyAward();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.typeId != null)
                message.typeId = object.typeId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyGuildCopyAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {msgProto.CopyGuildCopyAward} message CopyGuildCopyAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyGuildCopyAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.typeId = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                object.typeId = message.typeId;
            return object;
        };

        /**
         * Converts this CopyGuildCopyAward to JSON.
         * @function toJSON
         * @memberof msgProto.CopyGuildCopyAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyGuildCopyAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyGuildCopyAward;
    })();

    msgProto.CopyGuildCopyReset = (function() {

        /**
         * Properties of a CopyGuildCopyReset.
         * @memberof msgProto
         * @interface ICopyGuildCopyReset
         */

        /**
         * Constructs a new CopyGuildCopyReset.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildCopyReset.
         * @implements ICopyGuildCopyReset
         * @constructor
         * @param {msgProto.ICopyGuildCopyReset=} [properties] Properties to set
         */
        function CopyGuildCopyReset(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CopyGuildCopyReset message. Does not implicitly {@link msgProto.CopyGuildCopyReset.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {msgProto.ICopyGuildCopyReset} message CopyGuildCopyReset message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyReset.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CopyGuildCopyReset message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildCopyReset} CopyGuildCopyReset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyReset.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildCopyReset();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyGuildCopyReset message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyGuildCopyReset} CopyGuildCopyReset
         */
        CopyGuildCopyReset.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyGuildCopyReset)
                return object;
            return new $root.msgProto.CopyGuildCopyReset();
        };

        /**
         * Creates a plain object from a CopyGuildCopyReset message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {msgProto.CopyGuildCopyReset} message CopyGuildCopyReset
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyGuildCopyReset.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CopyGuildCopyReset to JSON.
         * @function toJSON
         * @memberof msgProto.CopyGuildCopyReset
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyGuildCopyReset.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyGuildCopyReset;
    })();

    msgProto.CopyClearGuildCopy = (function() {

        /**
         * Properties of a CopyClearGuildCopy.
         * @memberof msgProto
         * @interface ICopyClearGuildCopy
         * @property {number|null} [bossId] CopyClearGuildCopy bossId
         */

        /**
         * Constructs a new CopyClearGuildCopy.
         * @memberof msgProto
         * @classdesc Represents a CopyClearGuildCopy.
         * @implements ICopyClearGuildCopy
         * @constructor
         * @param {msgProto.ICopyClearGuildCopy=} [properties] Properties to set
         */
        function CopyClearGuildCopy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyClearGuildCopy bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyClearGuildCopy
         * @instance
         */
        CopyClearGuildCopy.prototype.bossId = 0;

        /**
         * Encodes the specified CopyClearGuildCopy message. Does not implicitly {@link msgProto.CopyClearGuildCopy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {msgProto.ICopyClearGuildCopy} message CopyClearGuildCopy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyClearGuildCopy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes a CopyClearGuildCopy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyClearGuildCopy} CopyClearGuildCopy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyClearGuildCopy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyClearGuildCopy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyClearGuildCopy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyClearGuildCopy} CopyClearGuildCopy
         */
        CopyClearGuildCopy.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyClearGuildCopy)
                return object;
            var message = new $root.msgProto.CopyClearGuildCopy();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyClearGuildCopy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {msgProto.CopyClearGuildCopy} message CopyClearGuildCopy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyClearGuildCopy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this CopyClearGuildCopy to JSON.
         * @function toJSON
         * @memberof msgProto.CopyClearGuildCopy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyClearGuildCopy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyClearGuildCopy;
    })();

    msgProto.CopyPaTaAward = (function() {

        /**
         * Properties of a CopyPaTaAward.
         * @memberof msgProto
         * @interface ICopyPaTaAward
         * @property {number|null} [copyId] CopyPaTaAward copyId
         */

        /**
         * Constructs a new CopyPaTaAward.
         * @memberof msgProto
         * @classdesc Represents a CopyPaTaAward.
         * @implements ICopyPaTaAward
         * @constructor
         * @param {msgProto.ICopyPaTaAward=} [properties] Properties to set
         */
        function CopyPaTaAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyPaTaAward copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyPaTaAward
         * @instance
         */
        CopyPaTaAward.prototype.copyId = 0;

        /**
         * Encodes the specified CopyPaTaAward message. Does not implicitly {@link msgProto.CopyPaTaAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {msgProto.ICopyPaTaAward} message CopyPaTaAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Decodes a CopyPaTaAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyPaTaAward} CopyPaTaAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyPaTaAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyPaTaAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyPaTaAward} CopyPaTaAward
         */
        CopyPaTaAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyPaTaAward)
                return object;
            var message = new $root.msgProto.CopyPaTaAward();
            if (object.copyId != null)
                message.copyId = object.copyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CopyPaTaAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {msgProto.CopyPaTaAward} message CopyPaTaAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyPaTaAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.copyId = 0;
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                object.copyId = message.copyId;
            return object;
        };

        /**
         * Converts this CopyPaTaAward to JSON.
         * @function toJSON
         * @memberof msgProto.CopyPaTaAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyPaTaAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyPaTaAward;
    })();

    msgProto.CopyPaTaTreasury = (function() {

        /**
         * Properties of a CopyPaTaTreasury.
         * @memberof msgProto
         * @interface ICopyPaTaTreasury
         */

        /**
         * Constructs a new CopyPaTaTreasury.
         * @memberof msgProto
         * @classdesc Represents a CopyPaTaTreasury.
         * @implements ICopyPaTaTreasury
         * @constructor
         * @param {msgProto.ICopyPaTaTreasury=} [properties] Properties to set
         */
        function CopyPaTaTreasury(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CopyPaTaTreasury message. Does not implicitly {@link msgProto.CopyPaTaTreasury.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {msgProto.ICopyPaTaTreasury} message CopyPaTaTreasury message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaTreasury.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CopyPaTaTreasury message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyPaTaTreasury} CopyPaTaTreasury
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaTreasury.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyPaTaTreasury();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CopyPaTaTreasury message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CopyPaTaTreasury} CopyPaTaTreasury
         */
        CopyPaTaTreasury.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CopyPaTaTreasury)
                return object;
            return new $root.msgProto.CopyPaTaTreasury();
        };

        /**
         * Creates a plain object from a CopyPaTaTreasury message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {msgProto.CopyPaTaTreasury} message CopyPaTaTreasury
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CopyPaTaTreasury.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CopyPaTaTreasury to JSON.
         * @function toJSON
         * @memberof msgProto.CopyPaTaTreasury
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CopyPaTaTreasury.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CopyPaTaTreasury;
    })();

    msgProto.ChallengeCupGetInfo = (function() {

        /**
         * Properties of a ChallengeCupGetInfo.
         * @memberof msgProto
         * @interface IChallengeCupGetInfo
         */

        /**
         * Constructs a new ChallengeCupGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetInfo.
         * @implements IChallengeCupGetInfo
         * @constructor
         * @param {msgProto.IChallengeCupGetInfo=} [properties] Properties to set
         */
        function ChallengeCupGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ChallengeCupGetInfo message. Does not implicitly {@link msgProto.ChallengeCupGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {msgProto.IChallengeCupGetInfo} message ChallengeCupGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ChallengeCupGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetInfo} ChallengeCupGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupGetInfo} ChallengeCupGetInfo
         */
        ChallengeCupGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupGetInfo)
                return object;
            return new $root.msgProto.ChallengeCupGetInfo();
        };

        /**
         * Creates a plain object from a ChallengeCupGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {msgProto.ChallengeCupGetInfo} message ChallengeCupGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChallengeCupGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupGetInfo;
    })();

    msgProto.ChallengeCupStartFight = (function() {

        /**
         * Properties of a ChallengeCupStartFight.
         * @memberof msgProto
         * @interface IChallengeCupStartFight
         * @property {number|Long|null} [championUserId] ChallengeCupStartFight championUserId
         */

        /**
         * Constructs a new ChallengeCupStartFight.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupStartFight.
         * @implements IChallengeCupStartFight
         * @constructor
         * @param {msgProto.IChallengeCupStartFight=} [properties] Properties to set
         */
        function ChallengeCupStartFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupStartFight championUserId.
         * @member {number|Long} championUserId
         * @memberof msgProto.ChallengeCupStartFight
         * @instance
         */
        ChallengeCupStartFight.prototype.championUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified ChallengeCupStartFight message. Does not implicitly {@link msgProto.ChallengeCupStartFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {msgProto.IChallengeCupStartFight} message ChallengeCupStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupStartFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.championUserId != null && message.hasOwnProperty("championUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.championUserId);
            return writer;
        };

        /**
         * Decodes a ChallengeCupStartFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupStartFight} ChallengeCupStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupStartFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupStartFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.championUserId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupStartFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupStartFight} ChallengeCupStartFight
         */
        ChallengeCupStartFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupStartFight)
                return object;
            var message = new $root.msgProto.ChallengeCupStartFight();
            if (object.championUserId != null)
                if ($util.Long)
                    (message.championUserId = $util.Long.fromValue(object.championUserId)).unsigned = true;
                else if (typeof object.championUserId === "string")
                    message.championUserId = parseInt(object.championUserId, 10);
                else if (typeof object.championUserId === "number")
                    message.championUserId = object.championUserId;
                else if (typeof object.championUserId === "object")
                    message.championUserId = new $util.LongBits(object.championUserId.low >>> 0, object.championUserId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChallengeCupStartFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {msgProto.ChallengeCupStartFight} message ChallengeCupStartFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupStartFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.championUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.championUserId = options.longs === String ? "0" : 0;
            if (message.championUserId != null && message.hasOwnProperty("championUserId"))
                if (typeof message.championUserId === "number")
                    object.championUserId = options.longs === String ? String(message.championUserId) : message.championUserId;
                else
                    object.championUserId = options.longs === String ? $util.Long.prototype.toString.call(message.championUserId) : options.longs === Number ? new $util.LongBits(message.championUserId.low >>> 0, message.championUserId.high >>> 0).toNumber(true) : message.championUserId;
            return object;
        };

        /**
         * Converts this ChallengeCupStartFight to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupStartFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupStartFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupStartFight;
    })();

    msgProto.ChallengeCupEndFight = (function() {

        /**
         * Properties of a ChallengeCupEndFight.
         * @memberof msgProto
         * @interface IChallengeCupEndFight
         * @property {boolean|null} [isWin] ChallengeCupEndFight isWin
         */

        /**
         * Constructs a new ChallengeCupEndFight.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupEndFight.
         * @implements IChallengeCupEndFight
         * @constructor
         * @param {msgProto.IChallengeCupEndFight=} [properties] Properties to set
         */
        function ChallengeCupEndFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupEndFight isWin.
         * @member {boolean} isWin
         * @memberof msgProto.ChallengeCupEndFight
         * @instance
         */
        ChallengeCupEndFight.prototype.isWin = false;

        /**
         * Encodes the specified ChallengeCupEndFight message. Does not implicitly {@link msgProto.ChallengeCupEndFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {msgProto.IChallengeCupEndFight} message ChallengeCupEndFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupEndFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            return writer;
        };

        /**
         * Decodes a ChallengeCupEndFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupEndFight} ChallengeCupEndFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupEndFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupEndFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupEndFight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupEndFight} ChallengeCupEndFight
         */
        ChallengeCupEndFight.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupEndFight)
                return object;
            var message = new $root.msgProto.ChallengeCupEndFight();
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            return message;
        };

        /**
         * Creates a plain object from a ChallengeCupEndFight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {msgProto.ChallengeCupEndFight} message ChallengeCupEndFight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupEndFight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isWin = false;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            return object;
        };

        /**
         * Converts this ChallengeCupEndFight to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupEndFight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupEndFight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupEndFight;
    })();

    msgProto.ChallengeCupClearCd = (function() {

        /**
         * Properties of a ChallengeCupClearCd.
         * @memberof msgProto
         * @interface IChallengeCupClearCd
         */

        /**
         * Constructs a new ChallengeCupClearCd.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupClearCd.
         * @implements IChallengeCupClearCd
         * @constructor
         * @param {msgProto.IChallengeCupClearCd=} [properties] Properties to set
         */
        function ChallengeCupClearCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ChallengeCupClearCd message. Does not implicitly {@link msgProto.ChallengeCupClearCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {msgProto.IChallengeCupClearCd} message ChallengeCupClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupClearCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ChallengeCupClearCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupClearCd} ChallengeCupClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupClearCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupClearCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupClearCd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupClearCd} ChallengeCupClearCd
         */
        ChallengeCupClearCd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupClearCd)
                return object;
            return new $root.msgProto.ChallengeCupClearCd();
        };

        /**
         * Creates a plain object from a ChallengeCupClearCd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {msgProto.ChallengeCupClearCd} message ChallengeCupClearCd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupClearCd.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChallengeCupClearCd to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupClearCd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupClearCd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupClearCd;
    })();

    msgProto.ChallengeCupToBeChampion = (function() {

        /**
         * Properties of a ChallengeCupToBeChampion.
         * @memberof msgProto
         * @interface IChallengeCupToBeChampion
         */

        /**
         * Constructs a new ChallengeCupToBeChampion.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupToBeChampion.
         * @implements IChallengeCupToBeChampion
         * @constructor
         * @param {msgProto.IChallengeCupToBeChampion=} [properties] Properties to set
         */
        function ChallengeCupToBeChampion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ChallengeCupToBeChampion message. Does not implicitly {@link msgProto.ChallengeCupToBeChampion.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {msgProto.IChallengeCupToBeChampion} message ChallengeCupToBeChampion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupToBeChampion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ChallengeCupToBeChampion message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupToBeChampion} ChallengeCupToBeChampion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupToBeChampion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupToBeChampion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupToBeChampion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupToBeChampion} ChallengeCupToBeChampion
         */
        ChallengeCupToBeChampion.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupToBeChampion)
                return object;
            return new $root.msgProto.ChallengeCupToBeChampion();
        };

        /**
         * Creates a plain object from a ChallengeCupToBeChampion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {msgProto.ChallengeCupToBeChampion} message ChallengeCupToBeChampion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupToBeChampion.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChallengeCupToBeChampion to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupToBeChampion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupToBeChampion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupToBeChampion;
    })();

    msgProto.ChallengeCupGetDurationTimeRankList = (function() {

        /**
         * Properties of a ChallengeCupGetDurationTimeRankList.
         * @memberof msgProto
         * @interface IChallengeCupGetDurationTimeRankList
         */

        /**
         * Constructs a new ChallengeCupGetDurationTimeRankList.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetDurationTimeRankList.
         * @implements IChallengeCupGetDurationTimeRankList
         * @constructor
         * @param {msgProto.IChallengeCupGetDurationTimeRankList=} [properties] Properties to set
         */
        function ChallengeCupGetDurationTimeRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ChallengeCupGetDurationTimeRankList message. Does not implicitly {@link msgProto.ChallengeCupGetDurationTimeRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {msgProto.IChallengeCupGetDurationTimeRankList} message ChallengeCupGetDurationTimeRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetDurationTimeRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ChallengeCupGetDurationTimeRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetDurationTimeRankList} ChallengeCupGetDurationTimeRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetDurationTimeRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetDurationTimeRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupGetDurationTimeRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupGetDurationTimeRankList} ChallengeCupGetDurationTimeRankList
         */
        ChallengeCupGetDurationTimeRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupGetDurationTimeRankList)
                return object;
            return new $root.msgProto.ChallengeCupGetDurationTimeRankList();
        };

        /**
         * Creates a plain object from a ChallengeCupGetDurationTimeRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {msgProto.ChallengeCupGetDurationTimeRankList} message ChallengeCupGetDurationTimeRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupGetDurationTimeRankList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChallengeCupGetDurationTimeRankList to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupGetDurationTimeRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupGetDurationTimeRankList;
    })();

    msgProto.ChallengeCupGetIsOpen = (function() {

        /**
         * Properties of a ChallengeCupGetIsOpen.
         * @memberof msgProto
         * @interface IChallengeCupGetIsOpen
         */

        /**
         * Constructs a new ChallengeCupGetIsOpen.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetIsOpen.
         * @implements IChallengeCupGetIsOpen
         * @constructor
         * @param {msgProto.IChallengeCupGetIsOpen=} [properties] Properties to set
         */
        function ChallengeCupGetIsOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ChallengeCupGetIsOpen message. Does not implicitly {@link msgProto.ChallengeCupGetIsOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {msgProto.IChallengeCupGetIsOpen} message ChallengeCupGetIsOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetIsOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ChallengeCupGetIsOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetIsOpen} ChallengeCupGetIsOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetIsOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetIsOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupGetIsOpen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupGetIsOpen} ChallengeCupGetIsOpen
         */
        ChallengeCupGetIsOpen.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupGetIsOpen)
                return object;
            return new $root.msgProto.ChallengeCupGetIsOpen();
        };

        /**
         * Creates a plain object from a ChallengeCupGetIsOpen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {msgProto.ChallengeCupGetIsOpen} message ChallengeCupGetIsOpen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupGetIsOpen.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChallengeCupGetIsOpen to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupGetIsOpen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupGetIsOpen;
    })();

    msgProto.ChallengeCupOp = (function() {

        /**
         * Properties of a ChallengeCupOp.
         * @memberof msgProto
         * @interface IChallengeCupOp
         * @property {number|null} [op] ChallengeCupOp op
         */

        /**
         * Constructs a new ChallengeCupOp.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupOp.
         * @implements IChallengeCupOp
         * @constructor
         * @param {msgProto.IChallengeCupOp=} [properties] Properties to set
         */
        function ChallengeCupOp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupOp op.
         * @member {number} op
         * @memberof msgProto.ChallengeCupOp
         * @instance
         */
        ChallengeCupOp.prototype.op = 0;

        /**
         * Encodes the specified ChallengeCupOp message. Does not implicitly {@link msgProto.ChallengeCupOp.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {msgProto.IChallengeCupOp} message ChallengeCupOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupOp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.op != null && message.hasOwnProperty("op"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.op);
            return writer;
        };

        /**
         * Decodes a ChallengeCupOp message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupOp} ChallengeCupOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupOp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupOp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChallengeCupOp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChallengeCupOp} ChallengeCupOp
         */
        ChallengeCupOp.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChallengeCupOp)
                return object;
            var message = new $root.msgProto.ChallengeCupOp();
            if (object.op != null)
                message.op = object.op | 0;
            return message;
        };

        /**
         * Creates a plain object from a ChallengeCupOp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {msgProto.ChallengeCupOp} message ChallengeCupOp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChallengeCupOp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.op = 0;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            return object;
        };

        /**
         * Converts this ChallengeCupOp to JSON.
         * @function toJSON
         * @memberof msgProto.ChallengeCupOp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChallengeCupOp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChallengeCupOp;
    })();

    msgProto.CrystalGetInfo = (function() {

        /**
         * Properties of a CrystalGetInfo.
         * @memberof msgProto
         * @interface ICrystalGetInfo
         */

        /**
         * Constructs a new CrystalGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CrystalGetInfo.
         * @implements ICrystalGetInfo
         * @constructor
         * @param {msgProto.ICrystalGetInfo=} [properties] Properties to set
         */
        function CrystalGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CrystalGetInfo message. Does not implicitly {@link msgProto.CrystalGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {msgProto.ICrystalGetInfo} message CrystalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CrystalGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalGetInfo} CrystalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalGetInfo} CrystalGetInfo
         */
        CrystalGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalGetInfo)
                return object;
            return new $root.msgProto.CrystalGetInfo();
        };

        /**
         * Creates a plain object from a CrystalGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {msgProto.CrystalGetInfo} message CrystalGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CrystalGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalGetInfo;
    })();

    msgProto.CrystalSaveProgress = (function() {

        /**
         * Properties of a CrystalSaveProgress.
         * @memberof msgProto
         * @interface ICrystalSaveProgress
         * @property {number|null} [hp] CrystalSaveProgress hp
         * @property {number|null} [hpNum] CrystalSaveProgress hpNum
         * @property {number|null} [nextReplayTime] CrystalSaveProgress nextReplayTime
         */

        /**
         * Constructs a new CrystalSaveProgress.
         * @memberof msgProto
         * @classdesc Represents a CrystalSaveProgress.
         * @implements ICrystalSaveProgress
         * @constructor
         * @param {msgProto.ICrystalSaveProgress=} [properties] Properties to set
         */
        function CrystalSaveProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalSaveProgress hp.
         * @member {number} hp
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.hp = 0;

        /**
         * CrystalSaveProgress hpNum.
         * @member {number} hpNum
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.hpNum = 0;

        /**
         * CrystalSaveProgress nextReplayTime.
         * @member {number} nextReplayTime
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.nextReplayTime = 0;

        /**
         * Encodes the specified CrystalSaveProgress message. Does not implicitly {@link msgProto.CrystalSaveProgress.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {msgProto.ICrystalSaveProgress} message CrystalSaveProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalSaveProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hp != null && message.hasOwnProperty("hp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hp);
            if (message.hpNum != null && message.hasOwnProperty("hpNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hpNum);
            if (message.nextReplayTime != null && message.hasOwnProperty("nextReplayTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nextReplayTime);
            return writer;
        };

        /**
         * Decodes a CrystalSaveProgress message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalSaveProgress} CrystalSaveProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalSaveProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalSaveProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hp = reader.int32();
                    break;
                case 2:
                    message.hpNum = reader.int32();
                    break;
                case 3:
                    message.nextReplayTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalSaveProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalSaveProgress} CrystalSaveProgress
         */
        CrystalSaveProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalSaveProgress)
                return object;
            var message = new $root.msgProto.CrystalSaveProgress();
            if (object.hp != null)
                message.hp = object.hp | 0;
            if (object.hpNum != null)
                message.hpNum = object.hpNum | 0;
            if (object.nextReplayTime != null)
                message.nextReplayTime = object.nextReplayTime | 0;
            return message;
        };

        /**
         * Creates a plain object from a CrystalSaveProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {msgProto.CrystalSaveProgress} message CrystalSaveProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalSaveProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hp = 0;
                object.hpNum = 0;
                object.nextReplayTime = 0;
            }
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.hpNum != null && message.hasOwnProperty("hpNum"))
                object.hpNum = message.hpNum;
            if (message.nextReplayTime != null && message.hasOwnProperty("nextReplayTime"))
                object.nextReplayTime = message.nextReplayTime;
            return object;
        };

        /**
         * Converts this CrystalSaveProgress to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalSaveProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalSaveProgress;
    })();

    msgProto.CrystalFinish = (function() {

        /**
         * Properties of a CrystalFinish.
         * @memberof msgProto
         * @interface ICrystalFinish
         * @property {number|null} [crystalId] CrystalFinish crystalId
         */

        /**
         * Constructs a new CrystalFinish.
         * @memberof msgProto
         * @classdesc Represents a CrystalFinish.
         * @implements ICrystalFinish
         * @constructor
         * @param {msgProto.ICrystalFinish=} [properties] Properties to set
         */
        function CrystalFinish(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalFinish crystalId.
         * @member {number} crystalId
         * @memberof msgProto.CrystalFinish
         * @instance
         */
        CrystalFinish.prototype.crystalId = 0;

        /**
         * Encodes the specified CrystalFinish message. Does not implicitly {@link msgProto.CrystalFinish.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {msgProto.ICrystalFinish} message CrystalFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalFinish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.crystalId);
            return writer;
        };

        /**
         * Decodes a CrystalFinish message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalFinish} CrystalFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalFinish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalFinish();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.crystalId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalFinish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalFinish} CrystalFinish
         */
        CrystalFinish.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalFinish)
                return object;
            var message = new $root.msgProto.CrystalFinish();
            if (object.crystalId != null)
                message.crystalId = object.crystalId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CrystalFinish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {msgProto.CrystalFinish} message CrystalFinish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalFinish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.crystalId = 0;
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                object.crystalId = message.crystalId;
            return object;
        };

        /**
         * Converts this CrystalFinish to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalFinish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalFinish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalFinish;
    })();

    msgProto.CrystalPickAward = (function() {

        /**
         * Properties of a CrystalPickAward.
         * @memberof msgProto
         * @interface ICrystalPickAward
         * @property {number|null} [crystalId] CrystalPickAward crystalId
         */

        /**
         * Constructs a new CrystalPickAward.
         * @memberof msgProto
         * @classdesc Represents a CrystalPickAward.
         * @implements ICrystalPickAward
         * @constructor
         * @param {msgProto.ICrystalPickAward=} [properties] Properties to set
         */
        function CrystalPickAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalPickAward crystalId.
         * @member {number} crystalId
         * @memberof msgProto.CrystalPickAward
         * @instance
         */
        CrystalPickAward.prototype.crystalId = 0;

        /**
         * Encodes the specified CrystalPickAward message. Does not implicitly {@link msgProto.CrystalPickAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {msgProto.ICrystalPickAward} message CrystalPickAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalPickAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.crystalId);
            return writer;
        };

        /**
         * Decodes a CrystalPickAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalPickAward} CrystalPickAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalPickAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalPickAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.crystalId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalPickAward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalPickAward} CrystalPickAward
         */
        CrystalPickAward.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalPickAward)
                return object;
            var message = new $root.msgProto.CrystalPickAward();
            if (object.crystalId != null)
                message.crystalId = object.crystalId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CrystalPickAward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {msgProto.CrystalPickAward} message CrystalPickAward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalPickAward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.crystalId = 0;
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                object.crystalId = message.crystalId;
            return object;
        };

        /**
         * Converts this CrystalPickAward to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalPickAward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalPickAward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalPickAward;
    })();

    msgProto.CrystalUseSkill = (function() {

        /**
         * Properties of a CrystalUseSkill.
         * @memberof msgProto
         * @interface ICrystalUseSkill
         * @property {number|null} [index] CrystalUseSkill index
         */

        /**
         * Constructs a new CrystalUseSkill.
         * @memberof msgProto
         * @classdesc Represents a CrystalUseSkill.
         * @implements ICrystalUseSkill
         * @constructor
         * @param {msgProto.ICrystalUseSkill=} [properties] Properties to set
         */
        function CrystalUseSkill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalUseSkill index.
         * @member {number} index
         * @memberof msgProto.CrystalUseSkill
         * @instance
         */
        CrystalUseSkill.prototype.index = 0;

        /**
         * Encodes the specified CrystalUseSkill message. Does not implicitly {@link msgProto.CrystalUseSkill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {msgProto.ICrystalUseSkill} message CrystalUseSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalUseSkill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Decodes a CrystalUseSkill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalUseSkill} CrystalUseSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalUseSkill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalUseSkill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalUseSkill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalUseSkill} CrystalUseSkill
         */
        CrystalUseSkill.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalUseSkill)
                return object;
            var message = new $root.msgProto.CrystalUseSkill();
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a CrystalUseSkill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {msgProto.CrystalUseSkill} message CrystalUseSkill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalUseSkill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this CrystalUseSkill to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalUseSkill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalUseSkill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalUseSkill;
    })();

    msgProto.CrystalRefreshSkillCd = (function() {

        /**
         * Properties of a CrystalRefreshSkillCd.
         * @memberof msgProto
         * @interface ICrystalRefreshSkillCd
         * @property {number|null} [index] CrystalRefreshSkillCd index
         */

        /**
         * Constructs a new CrystalRefreshSkillCd.
         * @memberof msgProto
         * @classdesc Represents a CrystalRefreshSkillCd.
         * @implements ICrystalRefreshSkillCd
         * @constructor
         * @param {msgProto.ICrystalRefreshSkillCd=} [properties] Properties to set
         */
        function CrystalRefreshSkillCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalRefreshSkillCd index.
         * @member {number} index
         * @memberof msgProto.CrystalRefreshSkillCd
         * @instance
         */
        CrystalRefreshSkillCd.prototype.index = 0;

        /**
         * Encodes the specified CrystalRefreshSkillCd message. Does not implicitly {@link msgProto.CrystalRefreshSkillCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {msgProto.ICrystalRefreshSkillCd} message CrystalRefreshSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalRefreshSkillCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Decodes a CrystalRefreshSkillCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalRefreshSkillCd} CrystalRefreshSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalRefreshSkillCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalRefreshSkillCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CrystalRefreshSkillCd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CrystalRefreshSkillCd} CrystalRefreshSkillCd
         */
        CrystalRefreshSkillCd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CrystalRefreshSkillCd)
                return object;
            var message = new $root.msgProto.CrystalRefreshSkillCd();
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };

        /**
         * Creates a plain object from a CrystalRefreshSkillCd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {msgProto.CrystalRefreshSkillCd} message CrystalRefreshSkillCd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CrystalRefreshSkillCd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this CrystalRefreshSkillCd to JSON.
         * @function toJSON
         * @memberof msgProto.CrystalRefreshSkillCd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CrystalRefreshSkillCd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CrystalRefreshSkillCd;
    })();

    msgProto.RankGetRankList = (function() {

        /**
         * Properties of a RankGetRankList.
         * @memberof msgProto
         * @interface IRankGetRankList
         * @property {number|null} [rankType] RankGetRankList rankType
         */

        /**
         * Constructs a new RankGetRankList.
         * @memberof msgProto
         * @classdesc Represents a RankGetRankList.
         * @implements IRankGetRankList
         * @constructor
         * @param {msgProto.IRankGetRankList=} [properties] Properties to set
         */
        function RankGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetRankList rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetRankList
         * @instance
         */
        RankGetRankList.prototype.rankType = 0;

        /**
         * Encodes the specified RankGetRankList message. Does not implicitly {@link msgProto.RankGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {msgProto.IRankGetRankList} message RankGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Decodes a RankGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetRankList} RankGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RankGetRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RankGetRankList} RankGetRankList
         */
        RankGetRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RankGetRankList)
                return object;
            var message = new $root.msgProto.RankGetRankList();
            if (object.rankType != null)
                message.rankType = object.rankType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RankGetRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {msgProto.RankGetRankList} message RankGetRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RankGetRankList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rankType = 0;
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = message.rankType;
            return object;
        };

        /**
         * Converts this RankGetRankList to JSON.
         * @function toJSON
         * @memberof msgProto.RankGetRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RankGetRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RankGetRankList;
    })();

    msgProto.RankGetUserRank = (function() {

        /**
         * Properties of a RankGetUserRank.
         * @memberof msgProto
         * @interface IRankGetUserRank
         * @property {number|null} [rankType] RankGetUserRank rankType
         */

        /**
         * Constructs a new RankGetUserRank.
         * @memberof msgProto
         * @classdesc Represents a RankGetUserRank.
         * @implements IRankGetUserRank
         * @constructor
         * @param {msgProto.IRankGetUserRank=} [properties] Properties to set
         */
        function RankGetUserRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetUserRank rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetUserRank
         * @instance
         */
        RankGetUserRank.prototype.rankType = 0;

        /**
         * Encodes the specified RankGetUserRank message. Does not implicitly {@link msgProto.RankGetUserRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {msgProto.IRankGetUserRank} message RankGetUserRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetUserRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Decodes a RankGetUserRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetUserRank} RankGetUserRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetUserRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetUserRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RankGetUserRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RankGetUserRank} RankGetUserRank
         */
        RankGetUserRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RankGetUserRank)
                return object;
            var message = new $root.msgProto.RankGetUserRank();
            if (object.rankType != null)
                message.rankType = object.rankType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RankGetUserRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {msgProto.RankGetUserRank} message RankGetUserRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RankGetUserRank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rankType = 0;
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = message.rankType;
            return object;
        };

        /**
         * Converts this RankGetUserRank to JSON.
         * @function toJSON
         * @memberof msgProto.RankGetUserRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RankGetUserRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RankGetUserRank;
    })();

    msgProto.RankAllRankArr = (function() {

        /**
         * Properties of a RankAllRankArr.
         * @memberof msgProto
         * @interface IRankAllRankArr
         * @property {number|null} [rankType] RankAllRankArr rankType
         */

        /**
         * Constructs a new RankAllRankArr.
         * @memberof msgProto
         * @classdesc Represents a RankAllRankArr.
         * @implements IRankAllRankArr
         * @constructor
         * @param {msgProto.IRankAllRankArr=} [properties] Properties to set
         */
        function RankAllRankArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankAllRankArr rankType.
         * @member {number} rankType
         * @memberof msgProto.RankAllRankArr
         * @instance
         */
        RankAllRankArr.prototype.rankType = 0;

        /**
         * Encodes the specified RankAllRankArr message. Does not implicitly {@link msgProto.RankAllRankArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {msgProto.IRankAllRankArr} message RankAllRankArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankAllRankArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Decodes a RankAllRankArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankAllRankArr} RankAllRankArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankAllRankArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankAllRankArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RankAllRankArr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RankAllRankArr} RankAllRankArr
         */
        RankAllRankArr.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RankAllRankArr)
                return object;
            var message = new $root.msgProto.RankAllRankArr();
            if (object.rankType != null)
                message.rankType = object.rankType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RankAllRankArr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {msgProto.RankAllRankArr} message RankAllRankArr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RankAllRankArr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rankType = 0;
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = message.rankType;
            return object;
        };

        /**
         * Converts this RankAllRankArr to JSON.
         * @function toJSON
         * @memberof msgProto.RankAllRankArr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RankAllRankArr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RankAllRankArr;
    })();

    msgProto.RankGetGuildRank = (function() {

        /**
         * Properties of a RankGetGuildRank.
         * @memberof msgProto
         * @interface IRankGetGuildRank
         * @property {number|null} [rankType] RankGetGuildRank rankType
         */

        /**
         * Constructs a new RankGetGuildRank.
         * @memberof msgProto
         * @classdesc Represents a RankGetGuildRank.
         * @implements IRankGetGuildRank
         * @constructor
         * @param {msgProto.IRankGetGuildRank=} [properties] Properties to set
         */
        function RankGetGuildRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetGuildRank rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetGuildRank
         * @instance
         */
        RankGetGuildRank.prototype.rankType = 0;

        /**
         * Encodes the specified RankGetGuildRank message. Does not implicitly {@link msgProto.RankGetGuildRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {msgProto.IRankGetGuildRank} message RankGetGuildRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetGuildRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Decodes a RankGetGuildRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetGuildRank} RankGetGuildRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetGuildRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetGuildRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RankGetGuildRank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RankGetGuildRank} RankGetGuildRank
         */
        RankGetGuildRank.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RankGetGuildRank)
                return object;
            var message = new $root.msgProto.RankGetGuildRank();
            if (object.rankType != null)
                message.rankType = object.rankType | 0;
            return message;
        };

        /**
         * Creates a plain object from a RankGetGuildRank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {msgProto.RankGetGuildRank} message RankGetGuildRank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RankGetGuildRank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rankType = 0;
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = message.rankType;
            return object;
        };

        /**
         * Converts this RankGetGuildRank to JSON.
         * @function toJSON
         * @memberof msgProto.RankGetGuildRank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RankGetGuildRank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RankGetGuildRank;
    })();

    msgProto.RebirthRebirth = (function() {

        /**
         * Properties of a RebirthRebirth.
         * @memberof msgProto
         * @interface IRebirthRebirth
         */

        /**
         * Constructs a new RebirthRebirth.
         * @memberof msgProto
         * @classdesc Represents a RebirthRebirth.
         * @implements IRebirthRebirth
         * @constructor
         * @param {msgProto.IRebirthRebirth=} [properties] Properties to set
         */
        function RebirthRebirth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RebirthRebirth message. Does not implicitly {@link msgProto.RebirthRebirth.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {msgProto.IRebirthRebirth} message RebirthRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthRebirth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RebirthRebirth message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RebirthRebirth} RebirthRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthRebirth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RebirthRebirth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RebirthRebirth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RebirthRebirth} RebirthRebirth
         */
        RebirthRebirth.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RebirthRebirth)
                return object;
            return new $root.msgProto.RebirthRebirth();
        };

        /**
         * Creates a plain object from a RebirthRebirth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {msgProto.RebirthRebirth} message RebirthRebirth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RebirthRebirth.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RebirthRebirth to JSON.
         * @function toJSON
         * @memberof msgProto.RebirthRebirth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RebirthRebirth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RebirthRebirth;
    })();

    msgProto.RebirthBuyRebirth = (function() {

        /**
         * Properties of a RebirthBuyRebirth.
         * @memberof msgProto
         * @interface IRebirthBuyRebirth
         * @property {number|null} [index] RebirthBuyRebirth index
         * @property {number|null} [num] RebirthBuyRebirth num
         */

        /**
         * Constructs a new RebirthBuyRebirth.
         * @memberof msgProto
         * @classdesc Represents a RebirthBuyRebirth.
         * @implements IRebirthBuyRebirth
         * @constructor
         * @param {msgProto.IRebirthBuyRebirth=} [properties] Properties to set
         */
        function RebirthBuyRebirth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RebirthBuyRebirth index.
         * @member {number} index
         * @memberof msgProto.RebirthBuyRebirth
         * @instance
         */
        RebirthBuyRebirth.prototype.index = 0;

        /**
         * RebirthBuyRebirth num.
         * @member {number} num
         * @memberof msgProto.RebirthBuyRebirth
         * @instance
         */
        RebirthBuyRebirth.prototype.num = 0;

        /**
         * Encodes the specified RebirthBuyRebirth message. Does not implicitly {@link msgProto.RebirthBuyRebirth.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {msgProto.IRebirthBuyRebirth} message RebirthBuyRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthBuyRebirth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.num != null && message.hasOwnProperty("num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };

        /**
         * Decodes a RebirthBuyRebirth message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RebirthBuyRebirth} RebirthBuyRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthBuyRebirth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RebirthBuyRebirth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RebirthBuyRebirth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RebirthBuyRebirth} RebirthBuyRebirth
         */
        RebirthBuyRebirth.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RebirthBuyRebirth)
                return object;
            var message = new $root.msgProto.RebirthBuyRebirth();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };

        /**
         * Creates a plain object from a RebirthBuyRebirth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {msgProto.RebirthBuyRebirth} message RebirthBuyRebirth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RebirthBuyRebirth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.num = 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this RebirthBuyRebirth to JSON.
         * @function toJSON
         * @memberof msgProto.RebirthBuyRebirth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RebirthBuyRebirth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RebirthBuyRebirth;
    })();

    msgProto.RechargeGetInfo = (function() {

        /**
         * Properties of a RechargeGetInfo.
         * @memberof msgProto
         * @interface IRechargeGetInfo
         */

        /**
         * Constructs a new RechargeGetInfo.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetInfo.
         * @implements IRechargeGetInfo
         * @constructor
         * @param {msgProto.IRechargeGetInfo=} [properties] Properties to set
         */
        function RechargeGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RechargeGetInfo message. Does not implicitly {@link msgProto.RechargeGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {msgProto.IRechargeGetInfo} message RechargeGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RechargeGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetInfo} RechargeGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeGetInfo} RechargeGetInfo
         */
        RechargeGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeGetInfo)
                return object;
            return new $root.msgProto.RechargeGetInfo();
        };

        /**
         * Creates a plain object from a RechargeGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {msgProto.RechargeGetInfo} message RechargeGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RechargeGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeGetInfo;
    })();

    msgProto.RechargeRecharge = (function() {

        /**
         * Properties of a RechargeRecharge.
         * @memberof msgProto
         * @interface IRechargeRecharge
         * @property {number|null} [rechargeId] RechargeRecharge rechargeId
         * @property {number|null} [channelId] RechargeRecharge channelId
         * @property {string|null} [receiptData] RechargeRecharge receiptData
         */

        /**
         * Constructs a new RechargeRecharge.
         * @memberof msgProto
         * @classdesc Represents a RechargeRecharge.
         * @implements IRechargeRecharge
         * @constructor
         * @param {msgProto.IRechargeRecharge=} [properties] Properties to set
         */
        function RechargeRecharge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeRecharge rechargeId.
         * @member {number} rechargeId
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.rechargeId = 0;

        /**
         * RechargeRecharge channelId.
         * @member {number} channelId
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.channelId = 0;

        /**
         * RechargeRecharge receiptData.
         * @member {string} receiptData
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.receiptData = "";

        /**
         * Encodes the specified RechargeRecharge message. Does not implicitly {@link msgProto.RechargeRecharge.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {msgProto.IRechargeRecharge} message RechargeRecharge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeRecharge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeId);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelId);
            if (message.receiptData != null && message.hasOwnProperty("receiptData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.receiptData);
            return writer;
        };

        /**
         * Decodes a RechargeRecharge message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeRecharge} RechargeRecharge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeRecharge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeRecharge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rechargeId = reader.int32();
                    break;
                case 2:
                    message.channelId = reader.int32();
                    break;
                case 3:
                    message.receiptData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeRecharge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeRecharge} RechargeRecharge
         */
        RechargeRecharge.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeRecharge)
                return object;
            var message = new $root.msgProto.RechargeRecharge();
            if (object.rechargeId != null)
                message.rechargeId = object.rechargeId | 0;
            if (object.channelId != null)
                message.channelId = object.channelId | 0;
            if (object.receiptData != null)
                message.receiptData = String(object.receiptData);
            return message;
        };

        /**
         * Creates a plain object from a RechargeRecharge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {msgProto.RechargeRecharge} message RechargeRecharge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeRecharge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rechargeId = 0;
                object.channelId = 0;
                object.receiptData = "";
            }
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                object.rechargeId = message.rechargeId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            if (message.receiptData != null && message.hasOwnProperty("receiptData"))
                object.receiptData = message.receiptData;
            return object;
        };

        /**
         * Converts this RechargeRecharge to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeRecharge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeRecharge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeRecharge;
    })();

    msgProto.RechargeGetTodayCount = (function() {

        /**
         * Properties of a RechargeGetTodayCount.
         * @memberof msgProto
         * @interface IRechargeGetTodayCount
         */

        /**
         * Constructs a new RechargeGetTodayCount.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetTodayCount.
         * @implements IRechargeGetTodayCount
         * @constructor
         * @param {msgProto.IRechargeGetTodayCount=} [properties] Properties to set
         */
        function RechargeGetTodayCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RechargeGetTodayCount message. Does not implicitly {@link msgProto.RechargeGetTodayCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {msgProto.IRechargeGetTodayCount} message RechargeGetTodayCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetTodayCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RechargeGetTodayCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetTodayCount} RechargeGetTodayCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetTodayCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetTodayCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeGetTodayCount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeGetTodayCount} RechargeGetTodayCount
         */
        RechargeGetTodayCount.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeGetTodayCount)
                return object;
            return new $root.msgProto.RechargeGetTodayCount();
        };

        /**
         * Creates a plain object from a RechargeGetTodayCount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {msgProto.RechargeGetTodayCount} message RechargeGetTodayCount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeGetTodayCount.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RechargeGetTodayCount to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeGetTodayCount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeGetTodayCount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeGetTodayCount;
    })();

    msgProto.RechargeGetAllCount = (function() {

        /**
         * Properties of a RechargeGetAllCount.
         * @memberof msgProto
         * @interface IRechargeGetAllCount
         */

        /**
         * Constructs a new RechargeGetAllCount.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetAllCount.
         * @implements IRechargeGetAllCount
         * @constructor
         * @param {msgProto.IRechargeGetAllCount=} [properties] Properties to set
         */
        function RechargeGetAllCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RechargeGetAllCount message. Does not implicitly {@link msgProto.RechargeGetAllCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {msgProto.IRechargeGetAllCount} message RechargeGetAllCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetAllCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RechargeGetAllCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetAllCount} RechargeGetAllCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetAllCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetAllCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeGetAllCount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeGetAllCount} RechargeGetAllCount
         */
        RechargeGetAllCount.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeGetAllCount)
                return object;
            return new $root.msgProto.RechargeGetAllCount();
        };

        /**
         * Creates a plain object from a RechargeGetAllCount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {msgProto.RechargeGetAllCount} message RechargeGetAllCount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeGetAllCount.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RechargeGetAllCount to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeGetAllCount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeGetAllCount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeGetAllCount;
    })();

    msgProto.RechargeGetRequest = (function() {

        /**
         * Properties of a RechargeGetRequest.
         * @memberof msgProto
         * @interface IRechargeGetRequest
         * @property {number|null} [rechargeId] RechargeGetRequest rechargeId
         * @property {number|null} [goodsId] RechargeGetRequest goodsId
         */

        /**
         * Constructs a new RechargeGetRequest.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetRequest.
         * @implements IRechargeGetRequest
         * @constructor
         * @param {msgProto.IRechargeGetRequest=} [properties] Properties to set
         */
        function RechargeGetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeGetRequest rechargeId.
         * @member {number} rechargeId
         * @memberof msgProto.RechargeGetRequest
         * @instance
         */
        RechargeGetRequest.prototype.rechargeId = 0;

        /**
         * RechargeGetRequest goodsId.
         * @member {number} goodsId
         * @memberof msgProto.RechargeGetRequest
         * @instance
         */
        RechargeGetRequest.prototype.goodsId = 0;

        /**
         * Encodes the specified RechargeGetRequest message. Does not implicitly {@link msgProto.RechargeGetRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {msgProto.IRechargeGetRequest} message RechargeGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeId);
            if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
            return writer;
        };

        /**
         * Decodes a RechargeGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetRequest} RechargeGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rechargeId = reader.int32();
                    break;
                case 2:
                    message.goodsId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeGetRequest} RechargeGetRequest
         */
        RechargeGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeGetRequest)
                return object;
            var message = new $root.msgProto.RechargeGetRequest();
            if (object.rechargeId != null)
                message.rechargeId = object.rechargeId | 0;
            if (object.goodsId != null)
                message.goodsId = object.goodsId | 0;
            return message;
        };

        /**
         * Creates a plain object from a RechargeGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {msgProto.RechargeGetRequest} message RechargeGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rechargeId = 0;
                object.goodsId = 0;
            }
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                object.rechargeId = message.rechargeId;
            if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                object.goodsId = message.goodsId;
            return object;
        };

        /**
         * Converts this RechargeGetRequest to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeGetRequest;
    })();

    msgProto.RechargeHandleRequest = (function() {

        /**
         * Properties of a RechargeHandleRequest.
         * @memberof msgProto
         * @interface IRechargeHandleRequest
         */

        /**
         * Constructs a new RechargeHandleRequest.
         * @memberof msgProto
         * @classdesc Represents a RechargeHandleRequest.
         * @implements IRechargeHandleRequest
         * @constructor
         * @param {msgProto.IRechargeHandleRequest=} [properties] Properties to set
         */
        function RechargeHandleRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RechargeHandleRequest message. Does not implicitly {@link msgProto.RechargeHandleRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {msgProto.IRechargeHandleRequest} message RechargeHandleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeHandleRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RechargeHandleRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeHandleRequest} RechargeHandleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeHandleRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeHandleRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RechargeHandleRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RechargeHandleRequest} RechargeHandleRequest
         */
        RechargeHandleRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RechargeHandleRequest)
                return object;
            return new $root.msgProto.RechargeHandleRequest();
        };

        /**
         * Creates a plain object from a RechargeHandleRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {msgProto.RechargeHandleRequest} message RechargeHandleRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RechargeHandleRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RechargeHandleRequest to JSON.
         * @function toJSON
         * @memberof msgProto.RechargeHandleRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RechargeHandleRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RechargeHandleRequest;
    })();

    msgProto.RedEnvelopeGetList = (function() {

        /**
         * Properties of a RedEnvelopeGetList.
         * @memberof msgProto
         * @interface IRedEnvelopeGetList
         */

        /**
         * Constructs a new RedEnvelopeGetList.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeGetList.
         * @implements IRedEnvelopeGetList
         * @constructor
         * @param {msgProto.IRedEnvelopeGetList=} [properties] Properties to set
         */
        function RedEnvelopeGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RedEnvelopeGetList message. Does not implicitly {@link msgProto.RedEnvelopeGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {msgProto.IRedEnvelopeGetList} message RedEnvelopeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RedEnvelopeGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeGetList} RedEnvelopeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopeGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopeGetList} RedEnvelopeGetList
         */
        RedEnvelopeGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopeGetList)
                return object;
            return new $root.msgProto.RedEnvelopeGetList();
        };

        /**
         * Creates a plain object from a RedEnvelopeGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {msgProto.RedEnvelopeGetList} message RedEnvelopeGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopeGetList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RedEnvelopeGetList to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopeGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopeGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopeGetList;
    })();

    msgProto.RedEnvelopeSendRedEnvelope = (function() {

        /**
         * Properties of a RedEnvelopeSendRedEnvelope.
         * @memberof msgProto
         * @interface IRedEnvelopeSendRedEnvelope
         * @property {number|null} [type] RedEnvelopeSendRedEnvelope type
         * @property {number|null} [spItemId] RedEnvelopeSendRedEnvelope spItemId
         * @property {number|null} [amount] RedEnvelopeSendRedEnvelope amount
         * @property {number|null} [personNum] RedEnvelopeSendRedEnvelope personNum
         * @property {string|null} [wish] RedEnvelopeSendRedEnvelope wish
         */

        /**
         * Constructs a new RedEnvelopeSendRedEnvelope.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeSendRedEnvelope.
         * @implements IRedEnvelopeSendRedEnvelope
         * @constructor
         * @param {msgProto.IRedEnvelopeSendRedEnvelope=} [properties] Properties to set
         */
        function RedEnvelopeSendRedEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeSendRedEnvelope type.
         * @member {number} type
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.type = 0;

        /**
         * RedEnvelopeSendRedEnvelope spItemId.
         * @member {number} spItemId
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.spItemId = 0;

        /**
         * RedEnvelopeSendRedEnvelope amount.
         * @member {number} amount
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.amount = 0;

        /**
         * RedEnvelopeSendRedEnvelope personNum.
         * @member {number} personNum
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.personNum = 0;

        /**
         * RedEnvelopeSendRedEnvelope wish.
         * @member {string} wish
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.wish = "";

        /**
         * Encodes the specified RedEnvelopeSendRedEnvelope message. Does not implicitly {@link msgProto.RedEnvelopeSendRedEnvelope.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSendRedEnvelope} message RedEnvelopeSendRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSendRedEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.spItemId != null && message.hasOwnProperty("spItemId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.spItemId);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.amount);
            if (message.personNum != null && message.hasOwnProperty("personNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.personNum);
            if (message.wish != null && message.hasOwnProperty("wish"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.wish);
            return writer;
        };

        /**
         * Decodes a RedEnvelopeSendRedEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeSendRedEnvelope} RedEnvelopeSendRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSendRedEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeSendRedEnvelope();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.spItemId = reader.int32();
                    break;
                case 3:
                    message.amount = reader.int32();
                    break;
                case 4:
                    message.personNum = reader.int32();
                    break;
                case 5:
                    message.wish = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopeSendRedEnvelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopeSendRedEnvelope} RedEnvelopeSendRedEnvelope
         */
        RedEnvelopeSendRedEnvelope.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopeSendRedEnvelope)
                return object;
            var message = new $root.msgProto.RedEnvelopeSendRedEnvelope();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.spItemId != null)
                message.spItemId = object.spItemId | 0;
            if (object.amount != null)
                message.amount = object.amount | 0;
            if (object.personNum != null)
                message.personNum = object.personNum | 0;
            if (object.wish != null)
                message.wish = String(object.wish);
            return message;
        };

        /**
         * Creates a plain object from a RedEnvelopeSendRedEnvelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {msgProto.RedEnvelopeSendRedEnvelope} message RedEnvelopeSendRedEnvelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopeSendRedEnvelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.spItemId = 0;
                object.amount = 0;
                object.personNum = 0;
                object.wish = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.spItemId != null && message.hasOwnProperty("spItemId"))
                object.spItemId = message.spItemId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.personNum != null && message.hasOwnProperty("personNum"))
                object.personNum = message.personNum;
            if (message.wish != null && message.hasOwnProperty("wish"))
                object.wish = message.wish;
            return object;
        };

        /**
         * Converts this RedEnvelopeSendRedEnvelope to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopeSendRedEnvelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopeSendRedEnvelope;
    })();

    msgProto.RedEnvelopeSyncRedEnvelope = (function() {

        /**
         * Properties of a RedEnvelopeSyncRedEnvelope.
         * @memberof msgProto
         * @interface IRedEnvelopeSyncRedEnvelope
         */

        /**
         * Constructs a new RedEnvelopeSyncRedEnvelope.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeSyncRedEnvelope.
         * @implements IRedEnvelopeSyncRedEnvelope
         * @constructor
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope=} [properties] Properties to set
         */
        function RedEnvelopeSyncRedEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RedEnvelopeSyncRedEnvelope message. Does not implicitly {@link msgProto.RedEnvelopeSyncRedEnvelope.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope} message RedEnvelopeSyncRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSyncRedEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RedEnvelopeSyncRedEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeSyncRedEnvelope} RedEnvelopeSyncRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSyncRedEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeSyncRedEnvelope();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopeSyncRedEnvelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopeSyncRedEnvelope} RedEnvelopeSyncRedEnvelope
         */
        RedEnvelopeSyncRedEnvelope.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopeSyncRedEnvelope)
                return object;
            return new $root.msgProto.RedEnvelopeSyncRedEnvelope();
        };

        /**
         * Creates a plain object from a RedEnvelopeSyncRedEnvelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {msgProto.RedEnvelopeSyncRedEnvelope} message RedEnvelopeSyncRedEnvelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopeSyncRedEnvelope.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RedEnvelopeSyncRedEnvelope to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopeSyncRedEnvelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopeSyncRedEnvelope;
    })();

    msgProto.RedEnvelopeGetNewList = (function() {

        /**
         * Properties of a RedEnvelopeGetNewList.
         * @memberof msgProto
         * @interface IRedEnvelopeGetNewList
         * @property {number|null} [lastId] RedEnvelopeGetNewList lastId
         */

        /**
         * Constructs a new RedEnvelopeGetNewList.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeGetNewList.
         * @implements IRedEnvelopeGetNewList
         * @constructor
         * @param {msgProto.IRedEnvelopeGetNewList=} [properties] Properties to set
         */
        function RedEnvelopeGetNewList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeGetNewList lastId.
         * @member {number} lastId
         * @memberof msgProto.RedEnvelopeGetNewList
         * @instance
         */
        RedEnvelopeGetNewList.prototype.lastId = 0;

        /**
         * Encodes the specified RedEnvelopeGetNewList message. Does not implicitly {@link msgProto.RedEnvelopeGetNewList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {msgProto.IRedEnvelopeGetNewList} message RedEnvelopeGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetNewList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Decodes a RedEnvelopeGetNewList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeGetNewList} RedEnvelopeGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetNewList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeGetNewList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopeGetNewList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopeGetNewList} RedEnvelopeGetNewList
         */
        RedEnvelopeGetNewList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopeGetNewList)
                return object;
            var message = new $root.msgProto.RedEnvelopeGetNewList();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            return message;
        };

        /**
         * Creates a plain object from a RedEnvelopeGetNewList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {msgProto.RedEnvelopeGetNewList} message RedEnvelopeGetNewList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopeGetNewList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.lastId = 0;
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            return object;
        };

        /**
         * Converts this RedEnvelopeGetNewList to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopeGetNewList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopeGetNewList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopeGetNewList;
    })();

    msgProto.RedEnvelopeReceiveBonus = (function() {

        /**
         * Properties of a RedEnvelopeReceiveBonus.
         * @memberof msgProto
         * @interface IRedEnvelopeReceiveBonus
         * @property {number|null} [redEnvelopeId] RedEnvelopeReceiveBonus redEnvelopeId
         */

        /**
         * Constructs a new RedEnvelopeReceiveBonus.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeReceiveBonus.
         * @implements IRedEnvelopeReceiveBonus
         * @constructor
         * @param {msgProto.IRedEnvelopeReceiveBonus=} [properties] Properties to set
         */
        function RedEnvelopeReceiveBonus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeReceiveBonus redEnvelopeId.
         * @member {number} redEnvelopeId
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @instance
         */
        RedEnvelopeReceiveBonus.prototype.redEnvelopeId = 0;

        /**
         * Encodes the specified RedEnvelopeReceiveBonus message. Does not implicitly {@link msgProto.RedEnvelopeReceiveBonus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {msgProto.IRedEnvelopeReceiveBonus} message RedEnvelopeReceiveBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeReceiveBonus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.redEnvelopeId != null && message.hasOwnProperty("redEnvelopeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.redEnvelopeId);
            return writer;
        };

        /**
         * Decodes a RedEnvelopeReceiveBonus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeReceiveBonus} RedEnvelopeReceiveBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeReceiveBonus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeReceiveBonus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.redEnvelopeId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopeReceiveBonus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopeReceiveBonus} RedEnvelopeReceiveBonus
         */
        RedEnvelopeReceiveBonus.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopeReceiveBonus)
                return object;
            var message = new $root.msgProto.RedEnvelopeReceiveBonus();
            if (object.redEnvelopeId != null)
                message.redEnvelopeId = object.redEnvelopeId | 0;
            return message;
        };

        /**
         * Creates a plain object from a RedEnvelopeReceiveBonus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {msgProto.RedEnvelopeReceiveBonus} message RedEnvelopeReceiveBonus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopeReceiveBonus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.redEnvelopeId = 0;
            if (message.redEnvelopeId != null && message.hasOwnProperty("redEnvelopeId"))
                object.redEnvelopeId = message.redEnvelopeId;
            return object;
        };

        /**
         * Converts this RedEnvelopeReceiveBonus to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopeReceiveBonus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopeReceiveBonus;
    })();

    msgProto.RedEnvelopePersonalGetInfo = (function() {

        /**
         * Properties of a RedEnvelopePersonalGetInfo.
         * @memberof msgProto
         * @interface IRedEnvelopePersonalGetInfo
         */

        /**
         * Constructs a new RedEnvelopePersonalGetInfo.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopePersonalGetInfo.
         * @implements IRedEnvelopePersonalGetInfo
         * @constructor
         * @param {msgProto.IRedEnvelopePersonalGetInfo=} [properties] Properties to set
         */
        function RedEnvelopePersonalGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified RedEnvelopePersonalGetInfo message. Does not implicitly {@link msgProto.RedEnvelopePersonalGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {msgProto.IRedEnvelopePersonalGetInfo} message RedEnvelopePersonalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopePersonalGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a RedEnvelopePersonalGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopePersonalGetInfo} RedEnvelopePersonalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopePersonalGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopePersonalGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a RedEnvelopePersonalGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.RedEnvelopePersonalGetInfo} RedEnvelopePersonalGetInfo
         */
        RedEnvelopePersonalGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.RedEnvelopePersonalGetInfo)
                return object;
            return new $root.msgProto.RedEnvelopePersonalGetInfo();
        };

        /**
         * Creates a plain object from a RedEnvelopePersonalGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {msgProto.RedEnvelopePersonalGetInfo} message RedEnvelopePersonalGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedEnvelopePersonalGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RedEnvelopePersonalGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedEnvelopePersonalGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedEnvelopePersonalGetInfo;
    })();

    msgProto.ChatGetNewList = (function() {

        /**
         * Properties of a ChatGetNewList.
         * @memberof msgProto
         * @interface IChatGetNewList
         * @property {number|null} [lastId] ChatGetNewList lastId
         * @property {number|null} [guildId] ChatGetNewList guildId
         * @property {number|null} [guildLastId] ChatGetNewList guildLastId
         */

        /**
         * Constructs a new ChatGetNewList.
         * @memberof msgProto
         * @classdesc Represents a ChatGetNewList.
         * @implements IChatGetNewList
         * @constructor
         * @param {msgProto.IChatGetNewList=} [properties] Properties to set
         */
        function ChatGetNewList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatGetNewList lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.lastId = 0;

        /**
         * ChatGetNewList guildId.
         * @member {number} guildId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.guildId = 0;

        /**
         * ChatGetNewList guildLastId.
         * @member {number} guildLastId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.guildLastId = 0;

        /**
         * Encodes the specified ChatGetNewList message. Does not implicitly {@link msgProto.ChatGetNewList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {msgProto.IChatGetNewList} message ChatGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.guildLastId);
            return writer;
        };

        /**
         * Decodes a ChatGetNewList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatGetNewList} ChatGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatGetNewList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.guildLastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChatGetNewList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChatGetNewList} ChatGetNewList
         */
        ChatGetNewList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChatGetNewList)
                return object;
            var message = new $root.msgProto.ChatGetNewList();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            if (object.guildLastId != null)
                message.guildLastId = object.guildLastId | 0;
            return message;
        };

        /**
         * Creates a plain object from a ChatGetNewList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {msgProto.ChatGetNewList} message ChatGetNewList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatGetNewList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastId = 0;
                object.guildId = 0;
                object.guildLastId = 0;
            }
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                object.guildLastId = message.guildLastId;
            return object;
        };

        /**
         * Converts this ChatGetNewList to JSON.
         * @function toJSON
         * @memberof msgProto.ChatGetNewList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatGetNewList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatGetNewList;
    })();

    msgProto.ChatGetNewSysMsgList = (function() {

        /**
         * Properties of a ChatGetNewSysMsgList.
         * @memberof msgProto
         * @interface IChatGetNewSysMsgList
         * @property {number|null} [lastId] ChatGetNewSysMsgList lastId
         */

        /**
         * Constructs a new ChatGetNewSysMsgList.
         * @memberof msgProto
         * @classdesc Represents a ChatGetNewSysMsgList.
         * @implements IChatGetNewSysMsgList
         * @constructor
         * @param {msgProto.IChatGetNewSysMsgList=} [properties] Properties to set
         */
        function ChatGetNewSysMsgList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatGetNewSysMsgList lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatGetNewSysMsgList
         * @instance
         */
        ChatGetNewSysMsgList.prototype.lastId = 0;

        /**
         * Encodes the specified ChatGetNewSysMsgList message. Does not implicitly {@link msgProto.ChatGetNewSysMsgList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {msgProto.IChatGetNewSysMsgList} message ChatGetNewSysMsgList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewSysMsgList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Decodes a ChatGetNewSysMsgList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatGetNewSysMsgList} ChatGetNewSysMsgList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewSysMsgList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatGetNewSysMsgList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChatGetNewSysMsgList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChatGetNewSysMsgList} ChatGetNewSysMsgList
         */
        ChatGetNewSysMsgList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChatGetNewSysMsgList)
                return object;
            var message = new $root.msgProto.ChatGetNewSysMsgList();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            return message;
        };

        /**
         * Creates a plain object from a ChatGetNewSysMsgList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {msgProto.ChatGetNewSysMsgList} message ChatGetNewSysMsgList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatGetNewSysMsgList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.lastId = 0;
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            return object;
        };

        /**
         * Converts this ChatGetNewSysMsgList to JSON.
         * @function toJSON
         * @memberof msgProto.ChatGetNewSysMsgList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatGetNewSysMsgList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatGetNewSysMsgList;
    })();

    msgProto.ChatSendData = (function() {

        /**
         * Properties of a ChatSendData.
         * @memberof msgProto
         * @interface IChatSendData
         * @property {string|null} [content] ChatSendData content
         * @property {number|null} [lastId] ChatSendData lastId
         * @property {number|null} [type] ChatSendData type
         * @property {number|null} [guildId] ChatSendData guildId
         * @property {number|null} [guildLastId] ChatSendData guildLastId
         * @property {boolean|null} [isLittleHorn] ChatSendData isLittleHorn
         */

        /**
         * Constructs a new ChatSendData.
         * @memberof msgProto
         * @classdesc Represents a ChatSendData.
         * @implements IChatSendData
         * @constructor
         * @param {msgProto.IChatSendData=} [properties] Properties to set
         */
        function ChatSendData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatSendData content.
         * @member {string} content
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.content = "";

        /**
         * ChatSendData lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.lastId = 0;

        /**
         * ChatSendData type.
         * @member {number} type
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.type = 0;

        /**
         * ChatSendData guildId.
         * @member {number} guildId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.guildId = 0;

        /**
         * ChatSendData guildLastId.
         * @member {number} guildLastId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.guildLastId = 0;

        /**
         * ChatSendData isLittleHorn.
         * @member {boolean} isLittleHorn
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.isLittleHorn = false;

        /**
         * Encodes the specified ChatSendData message. Does not implicitly {@link msgProto.ChatSendData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatSendData
         * @static
         * @param {msgProto.IChatSendData} message ChatSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatSendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lastId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.guildId);
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.guildLastId);
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLittleHorn);
            return writer;
        };

        /**
         * Decodes a ChatSendData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatSendData} ChatSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatSendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatSendData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.lastId = reader.int32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.guildId = reader.int32();
                    break;
                case 5:
                    message.guildLastId = reader.int32();
                    break;
                case 6:
                    message.isLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ChatSendData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ChatSendData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ChatSendData} ChatSendData
         */
        ChatSendData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ChatSendData)
                return object;
            var message = new $root.msgProto.ChatSendData();
            if (object.content != null)
                message.content = String(object.content);
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            if (object.guildLastId != null)
                message.guildLastId = object.guildLastId | 0;
            if (object.isLittleHorn != null)
                message.isLittleHorn = Boolean(object.isLittleHorn);
            return message;
        };

        /**
         * Creates a plain object from a ChatSendData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ChatSendData
         * @static
         * @param {msgProto.ChatSendData} message ChatSendData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatSendData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.content = "";
                object.lastId = 0;
                object.type = 0;
                object.guildId = 0;
                object.guildLastId = 0;
                object.isLittleHorn = false;
            }
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                object.guildLastId = message.guildLastId;
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                object.isLittleHorn = message.isLittleHorn;
            return object;
        };

        /**
         * Converts this ChatSendData to JSON.
         * @function toJSON
         * @memberof msgProto.ChatSendData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatSendData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatSendData;
    })();

    msgProto.CouponUse = (function() {

        /**
         * Properties of a CouponUse.
         * @memberof msgProto
         * @interface ICouponUse
         * @property {string|null} [code] CouponUse code
         */

        /**
         * Constructs a new CouponUse.
         * @memberof msgProto
         * @classdesc Represents a CouponUse.
         * @implements ICouponUse
         * @constructor
         * @param {msgProto.ICouponUse=} [properties] Properties to set
         */
        function CouponUse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CouponUse code.
         * @member {string} code
         * @memberof msgProto.CouponUse
         * @instance
         */
        CouponUse.prototype.code = "";

        /**
         * Encodes the specified CouponUse message. Does not implicitly {@link msgProto.CouponUse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CouponUse
         * @static
         * @param {msgProto.ICouponUse} message CouponUse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CouponUse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
            return writer;
        };

        /**
         * Decodes a CouponUse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CouponUse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CouponUse} CouponUse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CouponUse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CouponUse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CouponUse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CouponUse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CouponUse} CouponUse
         */
        CouponUse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CouponUse)
                return object;
            var message = new $root.msgProto.CouponUse();
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a CouponUse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CouponUse
         * @static
         * @param {msgProto.CouponUse} message CouponUse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CouponUse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.code = "";
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this CouponUse to JSON.
         * @function toJSON
         * @memberof msgProto.CouponUse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CouponUse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CouponUse;
    })();

    msgProto.CoffersGetInfo = (function() {

        /**
         * Properties of a CoffersGetInfo.
         * @memberof msgProto
         * @interface ICoffersGetInfo
         */

        /**
         * Constructs a new CoffersGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetInfo.
         * @implements ICoffersGetInfo
         * @constructor
         * @param {msgProto.ICoffersGetInfo=} [properties] Properties to set
         */
        function CoffersGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersGetInfo message. Does not implicitly {@link msgProto.CoffersGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {msgProto.ICoffersGetInfo} message CoffersGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetInfo} CoffersGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetInfo} CoffersGetInfo
         */
        CoffersGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetInfo)
                return object;
            return new $root.msgProto.CoffersGetInfo();
        };

        /**
         * Creates a plain object from a CoffersGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {msgProto.CoffersGetInfo} message CoffersGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetInfo;
    })();

    msgProto.CoffersBuild = (function() {

        /**
         * Properties of a CoffersBuild.
         * @memberof msgProto
         * @interface ICoffersBuild
         */

        /**
         * Constructs a new CoffersBuild.
         * @memberof msgProto
         * @classdesc Represents a CoffersBuild.
         * @implements ICoffersBuild
         * @constructor
         * @param {msgProto.ICoffersBuild=} [properties] Properties to set
         */
        function CoffersBuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersBuild message. Does not implicitly {@link msgProto.CoffersBuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {msgProto.ICoffersBuild} message CoffersBuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersBuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersBuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersBuild} CoffersBuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersBuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersBuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersBuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersBuild} CoffersBuild
         */
        CoffersBuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersBuild)
                return object;
            return new $root.msgProto.CoffersBuild();
        };

        /**
         * Creates a plain object from a CoffersBuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {msgProto.CoffersBuild} message CoffersBuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersBuild.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersBuild to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersBuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersBuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersBuild;
    })();

    msgProto.CoffersAddBuff = (function() {

        /**
         * Properties of a CoffersAddBuff.
         * @memberof msgProto
         * @interface ICoffersAddBuff
         */

        /**
         * Constructs a new CoffersAddBuff.
         * @memberof msgProto
         * @classdesc Represents a CoffersAddBuff.
         * @implements ICoffersAddBuff
         * @constructor
         * @param {msgProto.ICoffersAddBuff=} [properties] Properties to set
         */
        function CoffersAddBuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersAddBuff message. Does not implicitly {@link msgProto.CoffersAddBuff.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {msgProto.ICoffersAddBuff} message CoffersAddBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersAddBuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersAddBuff message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersAddBuff} CoffersAddBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersAddBuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersAddBuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersAddBuff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersAddBuff} CoffersAddBuff
         */
        CoffersAddBuff.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersAddBuff)
                return object;
            return new $root.msgProto.CoffersAddBuff();
        };

        /**
         * Creates a plain object from a CoffersAddBuff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {msgProto.CoffersAddBuff} message CoffersAddBuff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersAddBuff.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersAddBuff to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersAddBuff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersAddBuff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersAddBuff;
    })();

    msgProto.CoffersGetLootRecordArr = (function() {

        /**
         * Properties of a CoffersGetLootRecordArr.
         * @memberof msgProto
         * @interface ICoffersGetLootRecordArr
         */

        /**
         * Constructs a new CoffersGetLootRecordArr.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetLootRecordArr.
         * @implements ICoffersGetLootRecordArr
         * @constructor
         * @param {msgProto.ICoffersGetLootRecordArr=} [properties] Properties to set
         */
        function CoffersGetLootRecordArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersGetLootRecordArr message. Does not implicitly {@link msgProto.CoffersGetLootRecordArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {msgProto.ICoffersGetLootRecordArr} message CoffersGetLootRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetLootRecordArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersGetLootRecordArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetLootRecordArr} CoffersGetLootRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetLootRecordArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetLootRecordArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetLootRecordArr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetLootRecordArr} CoffersGetLootRecordArr
         */
        CoffersGetLootRecordArr.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetLootRecordArr)
                return object;
            return new $root.msgProto.CoffersGetLootRecordArr();
        };

        /**
         * Creates a plain object from a CoffersGetLootRecordArr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {msgProto.CoffersGetLootRecordArr} message CoffersGetLootRecordArr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetLootRecordArr.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersGetLootRecordArr to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetLootRecordArr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetLootRecordArr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetLootRecordArr;
    })();

    msgProto.CoffersGetDefeseRecord = (function() {

        /**
         * Properties of a CoffersGetDefeseRecord.
         * @memberof msgProto
         * @interface ICoffersGetDefeseRecord
         */

        /**
         * Constructs a new CoffersGetDefeseRecord.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetDefeseRecord.
         * @implements ICoffersGetDefeseRecord
         * @constructor
         * @param {msgProto.ICoffersGetDefeseRecord=} [properties] Properties to set
         */
        function CoffersGetDefeseRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersGetDefeseRecord message. Does not implicitly {@link msgProto.CoffersGetDefeseRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {msgProto.ICoffersGetDefeseRecord} message CoffersGetDefeseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersGetDefeseRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetDefeseRecord} CoffersGetDefeseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetDefeseRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetDefeseRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetDefeseRecord} CoffersGetDefeseRecord
         */
        CoffersGetDefeseRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetDefeseRecord)
                return object;
            return new $root.msgProto.CoffersGetDefeseRecord();
        };

        /**
         * Creates a plain object from a CoffersGetDefeseRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {msgProto.CoffersGetDefeseRecord} message CoffersGetDefeseRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetDefeseRecord.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersGetDefeseRecord to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetDefeseRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetDefeseRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetDefeseRecord;
    })();

    msgProto.CoffersGetDefeseData = (function() {

        /**
         * Properties of a CoffersGetDefeseData.
         * @memberof msgProto
         * @interface ICoffersGetDefeseData
         */

        /**
         * Constructs a new CoffersGetDefeseData.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetDefeseData.
         * @implements ICoffersGetDefeseData
         * @constructor
         * @param {msgProto.ICoffersGetDefeseData=} [properties] Properties to set
         */
        function CoffersGetDefeseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersGetDefeseData message. Does not implicitly {@link msgProto.CoffersGetDefeseData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {msgProto.ICoffersGetDefeseData} message CoffersGetDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersGetDefeseData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetDefeseData} CoffersGetDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetDefeseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetDefeseData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetDefeseData} CoffersGetDefeseData
         */
        CoffersGetDefeseData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetDefeseData)
                return object;
            return new $root.msgProto.CoffersGetDefeseData();
        };

        /**
         * Creates a plain object from a CoffersGetDefeseData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {msgProto.CoffersGetDefeseData} message CoffersGetDefeseData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetDefeseData.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersGetDefeseData to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetDefeseData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetDefeseData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetDefeseData;
    })();

    msgProto.CoffersGetEnemyDefeseData = (function() {

        /**
         * Properties of a CoffersGetEnemyDefeseData.
         * @memberof msgProto
         * @interface ICoffersGetEnemyDefeseData
         * @property {number|null} [serverId] CoffersGetEnemyDefeseData serverId
         */

        /**
         * Constructs a new CoffersGetEnemyDefeseData.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetEnemyDefeseData.
         * @implements ICoffersGetEnemyDefeseData
         * @constructor
         * @param {msgProto.ICoffersGetEnemyDefeseData=} [properties] Properties to set
         */
        function CoffersGetEnemyDefeseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersGetEnemyDefeseData serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @instance
         */
        CoffersGetEnemyDefeseData.prototype.serverId = 0;

        /**
         * Encodes the specified CoffersGetEnemyDefeseData message. Does not implicitly {@link msgProto.CoffersGetEnemyDefeseData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {msgProto.ICoffersGetEnemyDefeseData} message CoffersGetEnemyDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetEnemyDefeseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            return writer;
        };

        /**
         * Decodes a CoffersGetEnemyDefeseData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetEnemyDefeseData} CoffersGetEnemyDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetEnemyDefeseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetEnemyDefeseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetEnemyDefeseData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetEnemyDefeseData} CoffersGetEnemyDefeseData
         */
        CoffersGetEnemyDefeseData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetEnemyDefeseData)
                return object;
            var message = new $root.msgProto.CoffersGetEnemyDefeseData();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CoffersGetEnemyDefeseData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {msgProto.CoffersGetEnemyDefeseData} message CoffersGetEnemyDefeseData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetEnemyDefeseData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverId = 0;
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            return object;
        };

        /**
         * Converts this CoffersGetEnemyDefeseData to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetEnemyDefeseData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetEnemyDefeseData;
    })();

    msgProto.CoffersGetServerArr = (function() {

        /**
         * Properties of a CoffersGetServerArr.
         * @memberof msgProto
         * @interface ICoffersGetServerArr
         */

        /**
         * Constructs a new CoffersGetServerArr.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetServerArr.
         * @implements ICoffersGetServerArr
         * @constructor
         * @param {msgProto.ICoffersGetServerArr=} [properties] Properties to set
         */
        function CoffersGetServerArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified CoffersGetServerArr message. Does not implicitly {@link msgProto.CoffersGetServerArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {msgProto.ICoffersGetServerArr} message CoffersGetServerArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetServerArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a CoffersGetServerArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetServerArr} CoffersGetServerArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetServerArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetServerArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersGetServerArr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersGetServerArr} CoffersGetServerArr
         */
        CoffersGetServerArr.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersGetServerArr)
                return object;
            return new $root.msgProto.CoffersGetServerArr();
        };

        /**
         * Creates a plain object from a CoffersGetServerArr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {msgProto.CoffersGetServerArr} message CoffersGetServerArr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersGetServerArr.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CoffersGetServerArr to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersGetServerArr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersGetServerArr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersGetServerArr;
    })();

    msgProto.CoffersFightStart = (function() {

        /**
         * Properties of a CoffersFightStart.
         * @memberof msgProto
         * @interface ICoffersFightStart
         * @property {number|null} [serverId] CoffersFightStart serverId
         * @property {number|null} [door] CoffersFightStart door
         */

        /**
         * Constructs a new CoffersFightStart.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightStart.
         * @implements ICoffersFightStart
         * @constructor
         * @param {msgProto.ICoffersFightStart=} [properties] Properties to set
         */
        function CoffersFightStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightStart serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightStart
         * @instance
         */
        CoffersFightStart.prototype.serverId = 0;

        /**
         * CoffersFightStart door.
         * @member {number} door
         * @memberof msgProto.CoffersFightStart
         * @instance
         */
        CoffersFightStart.prototype.door = 0;

        /**
         * Encodes the specified CoffersFightStart message. Does not implicitly {@link msgProto.CoffersFightStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {msgProto.ICoffersFightStart} message CoffersFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            return writer;
        };

        /**
         * Decodes a CoffersFightStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightStart} CoffersFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersFightStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersFightStart} CoffersFightStart
         */
        CoffersFightStart.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersFightStart)
                return object;
            var message = new $root.msgProto.CoffersFightStart();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.door != null)
                message.door = object.door | 0;
            return message;
        };

        /**
         * Creates a plain object from a CoffersFightStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {msgProto.CoffersFightStart} message CoffersFightStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersFightStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverId = 0;
                object.door = 0;
            }
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            return object;
        };

        /**
         * Converts this CoffersFightStart to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersFightStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersFightStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersFightStart;
    })();

    msgProto.CoffersFightEnd = (function() {

        /**
         * Properties of a CoffersFightEnd.
         * @memberof msgProto
         * @interface ICoffersFightEnd
         * @property {number|null} [serverId] CoffersFightEnd serverId
         * @property {number|null} [door] CoffersFightEnd door
         * @property {boolean|null} [isWin] CoffersFightEnd isWin
         * @property {string|null} [fightData] CoffersFightEnd fightData
         */

        /**
         * Constructs a new CoffersFightEnd.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightEnd.
         * @implements ICoffersFightEnd
         * @constructor
         * @param {msgProto.ICoffersFightEnd=} [properties] Properties to set
         */
        function CoffersFightEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightEnd serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.serverId = 0;

        /**
         * CoffersFightEnd door.
         * @member {number} door
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.door = 0;

        /**
         * CoffersFightEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.isWin = false;

        /**
         * CoffersFightEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.fightData = "";

        /**
         * Encodes the specified CoffersFightEnd message. Does not implicitly {@link msgProto.CoffersFightEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {msgProto.ICoffersFightEnd} message CoffersFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fightData);
            return writer;
        };

        /**
         * Decodes a CoffersFightEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightEnd} CoffersFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                case 4:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersFightEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersFightEnd} CoffersFightEnd
         */
        CoffersFightEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersFightEnd)
                return object;
            var message = new $root.msgProto.CoffersFightEnd();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.door != null)
                message.door = object.door | 0;
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            return message;
        };

        /**
         * Creates a plain object from a CoffersFightEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {msgProto.CoffersFightEnd} message CoffersFightEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersFightEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverId = 0;
                object.door = 0;
                object.isWin = false;
                object.fightData = "";
            }
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            return object;
        };

        /**
         * Converts this CoffersFightEnd to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersFightEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersFightEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersFightEnd;
    })();

    msgProto.CoffersFightCoffersStart = (function() {

        /**
         * Properties of a CoffersFightCoffersStart.
         * @memberof msgProto
         * @interface ICoffersFightCoffersStart
         * @property {number|null} [serverId] CoffersFightCoffersStart serverId
         */

        /**
         * Constructs a new CoffersFightCoffersStart.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightCoffersStart.
         * @implements ICoffersFightCoffersStart
         * @constructor
         * @param {msgProto.ICoffersFightCoffersStart=} [properties] Properties to set
         */
        function CoffersFightCoffersStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightCoffersStart serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightCoffersStart
         * @instance
         */
        CoffersFightCoffersStart.prototype.serverId = 0;

        /**
         * Encodes the specified CoffersFightCoffersStart message. Does not implicitly {@link msgProto.CoffersFightCoffersStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {msgProto.ICoffersFightCoffersStart} message CoffersFightCoffersStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            return writer;
        };

        /**
         * Decodes a CoffersFightCoffersStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightCoffersStart} CoffersFightCoffersStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightCoffersStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersFightCoffersStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersFightCoffersStart} CoffersFightCoffersStart
         */
        CoffersFightCoffersStart.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersFightCoffersStart)
                return object;
            var message = new $root.msgProto.CoffersFightCoffersStart();
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            return message;
        };

        /**
         * Creates a plain object from a CoffersFightCoffersStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {msgProto.CoffersFightCoffersStart} message CoffersFightCoffersStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersFightCoffersStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverId = 0;
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            return object;
        };

        /**
         * Converts this CoffersFightCoffersStart to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersFightCoffersStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersFightCoffersStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersFightCoffersStart;
    })();

    msgProto.CoffersFightCoffersEnd = (function() {

        /**
         * Properties of a CoffersFightCoffersEnd.
         * @memberof msgProto
         * @interface ICoffersFightCoffersEnd
         * @property {number|null} [hurt] CoffersFightCoffersEnd hurt
         * @property {number|null} [serverId] CoffersFightCoffersEnd serverId
         * @property {string|null} [fightData] CoffersFightCoffersEnd fightData
         */

        /**
         * Constructs a new CoffersFightCoffersEnd.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightCoffersEnd.
         * @implements ICoffersFightCoffersEnd
         * @constructor
         * @param {msgProto.ICoffersFightCoffersEnd=} [properties] Properties to set
         */
        function CoffersFightCoffersEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightCoffersEnd hurt.
         * @member {number} hurt
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.hurt = 0;

        /**
         * CoffersFightCoffersEnd serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.serverId = 0;

        /**
         * CoffersFightCoffersEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.fightData = "";

        /**
         * Encodes the specified CoffersFightCoffersEnd message. Does not implicitly {@link msgProto.CoffersFightCoffersEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {msgProto.ICoffersFightCoffersEnd} message CoffersFightCoffersEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hurt);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serverId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Decodes a CoffersFightCoffersEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightCoffersEnd} CoffersFightCoffersEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightCoffersEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hurt = reader.int32();
                    break;
                case 2:
                    message.serverId = reader.int32();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a CoffersFightCoffersEnd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.CoffersFightCoffersEnd} CoffersFightCoffersEnd
         */
        CoffersFightCoffersEnd.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.CoffersFightCoffersEnd)
                return object;
            var message = new $root.msgProto.CoffersFightCoffersEnd();
            if (object.hurt != null)
                message.hurt = object.hurt | 0;
            if (object.serverId != null)
                message.serverId = object.serverId | 0;
            if (object.fightData != null)
                message.fightData = String(object.fightData);
            return message;
        };

        /**
         * Creates a plain object from a CoffersFightCoffersEnd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {msgProto.CoffersFightCoffersEnd} message CoffersFightCoffersEnd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoffersFightCoffersEnd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hurt = 0;
                object.serverId = 0;
                object.fightData = "";
            }
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                object.hurt = message.hurt;
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                object.serverId = message.serverId;
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                object.fightData = message.fightData;
            return object;
        };

        /**
         * Converts this CoffersFightCoffersEnd to JSON.
         * @function toJSON
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoffersFightCoffersEnd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoffersFightCoffersEnd;
    })();

    msgProto.SdkGetVip = (function() {

        /**
         * Properties of a SdkGetVip.
         * @memberof msgProto
         * @interface ISdkGetVip
         */

        /**
         * Constructs a new SdkGetVip.
         * @memberof msgProto
         * @classdesc Represents a SdkGetVip.
         * @implements ISdkGetVip
         * @constructor
         * @param {msgProto.ISdkGetVip=} [properties] Properties to set
         */
        function SdkGetVip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified SdkGetVip message. Does not implicitly {@link msgProto.SdkGetVip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {msgProto.ISdkGetVip} message SdkGetVip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkGetVip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a SdkGetVip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SdkGetVip} SdkGetVip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkGetVip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SdkGetVip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SdkGetVip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SdkGetVip} SdkGetVip
         */
        SdkGetVip.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SdkGetVip)
                return object;
            return new $root.msgProto.SdkGetVip();
        };

        /**
         * Creates a plain object from a SdkGetVip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {msgProto.SdkGetVip} message SdkGetVip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SdkGetVip.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SdkGetVip to JSON.
         * @function toJSON
         * @memberof msgProto.SdkGetVip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SdkGetVip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SdkGetVip;
    })();

    msgProto.SmeltSmelt = (function() {

        /**
         * Properties of a SmeltSmelt.
         * @memberof msgProto
         * @interface ISmeltSmelt
         * @property {string|null} [equipArr] SmeltSmelt equipArr
         * @property {number|null} [choColor] SmeltSmelt choColor
         */

        /**
         * Constructs a new SmeltSmelt.
         * @memberof msgProto
         * @classdesc Represents a SmeltSmelt.
         * @implements ISmeltSmelt
         * @constructor
         * @param {msgProto.ISmeltSmelt=} [properties] Properties to set
         */
        function SmeltSmelt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltSmelt equipArr.
         * @member {string} equipArr
         * @memberof msgProto.SmeltSmelt
         * @instance
         */
        SmeltSmelt.prototype.equipArr = "";

        /**
         * SmeltSmelt choColor.
         * @member {number} choColor
         * @memberof msgProto.SmeltSmelt
         * @instance
         */
        SmeltSmelt.prototype.choColor = 0;

        /**
         * Encodes the specified SmeltSmelt message. Does not implicitly {@link msgProto.SmeltSmelt.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {msgProto.ISmeltSmelt} message SmeltSmelt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltSmelt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipArr != null && message.hasOwnProperty("equipArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.equipArr);
            if (message.choColor != null && message.hasOwnProperty("choColor"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.choColor);
            return writer;
        };

        /**
         * Decodes a SmeltSmelt message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltSmelt} SmeltSmelt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltSmelt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltSmelt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipArr = reader.string();
                    break;
                case 2:
                    message.choColor = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SmeltSmelt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SmeltSmelt} SmeltSmelt
         */
        SmeltSmelt.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SmeltSmelt)
                return object;
            var message = new $root.msgProto.SmeltSmelt();
            if (object.equipArr != null)
                message.equipArr = String(object.equipArr);
            if (object.choColor != null)
                message.choColor = object.choColor | 0;
            return message;
        };

        /**
         * Creates a plain object from a SmeltSmelt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {msgProto.SmeltSmelt} message SmeltSmelt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmeltSmelt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.equipArr = "";
                object.choColor = 0;
            }
            if (message.equipArr != null && message.hasOwnProperty("equipArr"))
                object.equipArr = message.equipArr;
            if (message.choColor != null && message.hasOwnProperty("choColor"))
                object.choColor = message.choColor;
            return object;
        };

        /**
         * Converts this SmeltSmelt to JSON.
         * @function toJSON
         * @memberof msgProto.SmeltSmelt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmeltSmelt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SmeltSmelt;
    })();

    msgProto.SmeltCompound = (function() {

        /**
         * Properties of a SmeltCompound.
         * @memberof msgProto
         * @interface ISmeltCompound
         * @property {number|null} [compoundId] SmeltCompound compoundId
         */

        /**
         * Constructs a new SmeltCompound.
         * @memberof msgProto
         * @classdesc Represents a SmeltCompound.
         * @implements ISmeltCompound
         * @constructor
         * @param {msgProto.ISmeltCompound=} [properties] Properties to set
         */
        function SmeltCompound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltCompound compoundId.
         * @member {number} compoundId
         * @memberof msgProto.SmeltCompound
         * @instance
         */
        SmeltCompound.prototype.compoundId = 0;

        /**
         * Encodes the specified SmeltCompound message. Does not implicitly {@link msgProto.SmeltCompound.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {msgProto.ISmeltCompound} message SmeltCompound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltCompound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compoundId != null && message.hasOwnProperty("compoundId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.compoundId);
            return writer;
        };

        /**
         * Decodes a SmeltCompound message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltCompound} SmeltCompound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltCompound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltCompound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.compoundId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SmeltCompound message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SmeltCompound} SmeltCompound
         */
        SmeltCompound.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SmeltCompound)
                return object;
            var message = new $root.msgProto.SmeltCompound();
            if (object.compoundId != null)
                message.compoundId = object.compoundId | 0;
            return message;
        };

        /**
         * Creates a plain object from a SmeltCompound message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {msgProto.SmeltCompound} message SmeltCompound
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmeltCompound.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.compoundId = 0;
            if (message.compoundId != null && message.hasOwnProperty("compoundId"))
                object.compoundId = message.compoundId;
            return object;
        };

        /**
         * Converts this SmeltCompound to JSON.
         * @function toJSON
         * @memberof msgProto.SmeltCompound
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmeltCompound.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SmeltCompound;
    })();

    msgProto.SmeltWearParRing = (function() {

        /**
         * Properties of a SmeltWearParRing.
         * @memberof msgProto
         * @interface ISmeltWearParRing
         * @property {number|null} [tempId] SmeltWearParRing tempId
         * @property {number|null} [breakId] SmeltWearParRing breakId
         */

        /**
         * Constructs a new SmeltWearParRing.
         * @memberof msgProto
         * @classdesc Represents a SmeltWearParRing.
         * @implements ISmeltWearParRing
         * @constructor
         * @param {msgProto.ISmeltWearParRing=} [properties] Properties to set
         */
        function SmeltWearParRing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltWearParRing tempId.
         * @member {number} tempId
         * @memberof msgProto.SmeltWearParRing
         * @instance
         */
        SmeltWearParRing.prototype.tempId = 0;

        /**
         * SmeltWearParRing breakId.
         * @member {number} breakId
         * @memberof msgProto.SmeltWearParRing
         * @instance
         */
        SmeltWearParRing.prototype.breakId = 0;

        /**
         * Encodes the specified SmeltWearParRing message. Does not implicitly {@link msgProto.SmeltWearParRing.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {msgProto.ISmeltWearParRing} message SmeltWearParRing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltWearParRing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakId);
            return writer;
        };

        /**
         * Decodes a SmeltWearParRing message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltWearParRing} SmeltWearParRing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltWearParRing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltWearParRing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.breakId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SmeltWearParRing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SmeltWearParRing} SmeltWearParRing
         */
        SmeltWearParRing.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SmeltWearParRing)
                return object;
            var message = new $root.msgProto.SmeltWearParRing();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.breakId != null)
                message.breakId = object.breakId | 0;
            return message;
        };

        /**
         * Creates a plain object from a SmeltWearParRing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {msgProto.SmeltWearParRing} message SmeltWearParRing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmeltWearParRing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.breakId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                object.breakId = message.breakId;
            return object;
        };

        /**
         * Converts this SmeltWearParRing to JSON.
         * @function toJSON
         * @memberof msgProto.SmeltWearParRing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmeltWearParRing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SmeltWearParRing;
    })();

    msgProto.SmeltRingBreak = (function() {

        /**
         * Properties of a SmeltRingBreak.
         * @memberof msgProto
         * @interface ISmeltRingBreak
         * @property {number|null} [tempId] SmeltRingBreak tempId
         * @property {number|null} [breakId] SmeltRingBreak breakId
         */

        /**
         * Constructs a new SmeltRingBreak.
         * @memberof msgProto
         * @classdesc Represents a SmeltRingBreak.
         * @implements ISmeltRingBreak
         * @constructor
         * @param {msgProto.ISmeltRingBreak=} [properties] Properties to set
         */
        function SmeltRingBreak(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltRingBreak tempId.
         * @member {number} tempId
         * @memberof msgProto.SmeltRingBreak
         * @instance
         */
        SmeltRingBreak.prototype.tempId = 0;

        /**
         * SmeltRingBreak breakId.
         * @member {number} breakId
         * @memberof msgProto.SmeltRingBreak
         * @instance
         */
        SmeltRingBreak.prototype.breakId = 0;

        /**
         * Encodes the specified SmeltRingBreak message. Does not implicitly {@link msgProto.SmeltRingBreak.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {msgProto.ISmeltRingBreak} message SmeltRingBreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltRingBreak.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakId);
            return writer;
        };

        /**
         * Decodes a SmeltRingBreak message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltRingBreak} SmeltRingBreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltRingBreak.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltRingBreak();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.breakId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SmeltRingBreak message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SmeltRingBreak} SmeltRingBreak
         */
        SmeltRingBreak.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SmeltRingBreak)
                return object;
            var message = new $root.msgProto.SmeltRingBreak();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.breakId != null)
                message.breakId = object.breakId | 0;
            return message;
        };

        /**
         * Creates a plain object from a SmeltRingBreak message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {msgProto.SmeltRingBreak} message SmeltRingBreak
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmeltRingBreak.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.breakId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                object.breakId = message.breakId;
            return object;
        };

        /**
         * Converts this SmeltRingBreak to JSON.
         * @function toJSON
         * @memberof msgProto.SmeltRingBreak
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmeltRingBreak.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SmeltRingBreak;
    })();

    msgProto.KingGetInfo = (function() {

        /**
         * Properties of a KingGetInfo.
         * @memberof msgProto
         * @interface IKingGetInfo
         */

        /**
         * Constructs a new KingGetInfo.
         * @memberof msgProto
         * @classdesc Represents a KingGetInfo.
         * @implements IKingGetInfo
         * @constructor
         * @param {msgProto.IKingGetInfo=} [properties] Properties to set
         */
        function KingGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified KingGetInfo message. Does not implicitly {@link msgProto.KingGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {msgProto.IKingGetInfo} message KingGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a KingGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingGetInfo} KingGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KingGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KingGetInfo} KingGetInfo
         */
        KingGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KingGetInfo)
                return object;
            return new $root.msgProto.KingGetInfo();
        };

        /**
         * Creates a plain object from a KingGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {msgProto.KingGetInfo} message KingGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KingGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this KingGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.KingGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KingGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KingGetInfo;
    })();

    msgProto.KingWorship = (function() {

        /**
         * Properties of a KingWorship.
         * @memberof msgProto
         * @interface IKingWorship
         */

        /**
         * Constructs a new KingWorship.
         * @memberof msgProto
         * @classdesc Represents a KingWorship.
         * @implements IKingWorship
         * @constructor
         * @param {msgProto.IKingWorship=} [properties] Properties to set
         */
        function KingWorship(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified KingWorship message. Does not implicitly {@link msgProto.KingWorship.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingWorship
         * @static
         * @param {msgProto.IKingWorship} message KingWorship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingWorship.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a KingWorship message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingWorship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingWorship} KingWorship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingWorship.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingWorship();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KingWorship message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KingWorship
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KingWorship} KingWorship
         */
        KingWorship.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KingWorship)
                return object;
            return new $root.msgProto.KingWorship();
        };

        /**
         * Creates a plain object from a KingWorship message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KingWorship
         * @static
         * @param {msgProto.KingWorship} message KingWorship
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KingWorship.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this KingWorship to JSON.
         * @function toJSON
         * @memberof msgProto.KingWorship
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KingWorship.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KingWorship;
    })();

    msgProto.KingReceiveWelfare = (function() {

        /**
         * Properties of a KingReceiveWelfare.
         * @memberof msgProto
         * @interface IKingReceiveWelfare
         */

        /**
         * Constructs a new KingReceiveWelfare.
         * @memberof msgProto
         * @classdesc Represents a KingReceiveWelfare.
         * @implements IKingReceiveWelfare
         * @constructor
         * @param {msgProto.IKingReceiveWelfare=} [properties] Properties to set
         */
        function KingReceiveWelfare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified KingReceiveWelfare message. Does not implicitly {@link msgProto.KingReceiveWelfare.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {msgProto.IKingReceiveWelfare} message KingReceiveWelfare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingReceiveWelfare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a KingReceiveWelfare message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingReceiveWelfare} KingReceiveWelfare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingReceiveWelfare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingReceiveWelfare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KingReceiveWelfare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KingReceiveWelfare} KingReceiveWelfare
         */
        KingReceiveWelfare.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KingReceiveWelfare)
                return object;
            return new $root.msgProto.KingReceiveWelfare();
        };

        /**
         * Creates a plain object from a KingReceiveWelfare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {msgProto.KingReceiveWelfare} message KingReceiveWelfare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KingReceiveWelfare.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this KingReceiveWelfare to JSON.
         * @function toJSON
         * @memberof msgProto.KingReceiveWelfare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KingReceiveWelfare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KingReceiveWelfare;
    })();

    msgProto.KingOpenBuff = (function() {

        /**
         * Properties of a KingOpenBuff.
         * @memberof msgProto
         * @interface IKingOpenBuff
         */

        /**
         * Constructs a new KingOpenBuff.
         * @memberof msgProto
         * @classdesc Represents a KingOpenBuff.
         * @implements IKingOpenBuff
         * @constructor
         * @param {msgProto.IKingOpenBuff=} [properties] Properties to set
         */
        function KingOpenBuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified KingOpenBuff message. Does not implicitly {@link msgProto.KingOpenBuff.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {msgProto.IKingOpenBuff} message KingOpenBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingOpenBuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a KingOpenBuff message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingOpenBuff} KingOpenBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingOpenBuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingOpenBuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KingOpenBuff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KingOpenBuff} KingOpenBuff
         */
        KingOpenBuff.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KingOpenBuff)
                return object;
            return new $root.msgProto.KingOpenBuff();
        };

        /**
         * Creates a plain object from a KingOpenBuff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {msgProto.KingOpenBuff} message KingOpenBuff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KingOpenBuff.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this KingOpenBuff to JSON.
         * @function toJSON
         * @memberof msgProto.KingOpenBuff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KingOpenBuff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KingOpenBuff;
    })();

    msgProto.ItemSellItems = (function() {

        /**
         * Properties of an ItemSellItems.
         * @memberof msgProto
         * @interface IItemSellItems
         * @property {number|null} [itemId] ItemSellItems itemId
         * @property {number|null} [itemNum] ItemSellItems itemNum
         */

        /**
         * Constructs a new ItemSellItems.
         * @memberof msgProto
         * @classdesc Represents an ItemSellItems.
         * @implements IItemSellItems
         * @constructor
         * @param {msgProto.IItemSellItems=} [properties] Properties to set
         */
        function ItemSellItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemSellItems itemId.
         * @member {number} itemId
         * @memberof msgProto.ItemSellItems
         * @instance
         */
        ItemSellItems.prototype.itemId = 0;

        /**
         * ItemSellItems itemNum.
         * @member {number} itemNum
         * @memberof msgProto.ItemSellItems
         * @instance
         */
        ItemSellItems.prototype.itemNum = 0;

        /**
         * Encodes the specified ItemSellItems message. Does not implicitly {@link msgProto.ItemSellItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {msgProto.IItemSellItems} message ItemSellItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemSellItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum);
            return writer;
        };

        /**
         * Decodes an ItemSellItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ItemSellItems} ItemSellItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemSellItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ItemSellItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.itemNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ItemSellItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ItemSellItems} ItemSellItems
         */
        ItemSellItems.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ItemSellItems)
                return object;
            var message = new $root.msgProto.ItemSellItems();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            if (object.itemNum != null)
                message.itemNum = object.itemNum | 0;
            return message;
        };

        /**
         * Creates a plain object from an ItemSellItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {msgProto.ItemSellItems} message ItemSellItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemSellItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.itemNum = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                object.itemNum = message.itemNum;
            return object;
        };

        /**
         * Converts this ItemSellItems to JSON.
         * @function toJSON
         * @memberof msgProto.ItemSellItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemSellItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ItemSellItems;
    })();

    msgProto.TreasureSpies = (function() {

        /**
         * Properties of a TreasureSpies.
         * @memberof msgProto
         * @interface ITreasureSpies
         */

        /**
         * Constructs a new TreasureSpies.
         * @memberof msgProto
         * @classdesc Represents a TreasureSpies.
         * @implements ITreasureSpies
         * @constructor
         * @param {msgProto.ITreasureSpies=} [properties] Properties to set
         */
        function TreasureSpies(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified TreasureSpies message. Does not implicitly {@link msgProto.TreasureSpies.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {msgProto.ITreasureSpies} message TreasureSpies message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureSpies.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a TreasureSpies message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureSpies} TreasureSpies
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureSpies.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureSpies();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TreasureSpies message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TreasureSpies} TreasureSpies
         */
        TreasureSpies.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TreasureSpies)
                return object;
            return new $root.msgProto.TreasureSpies();
        };

        /**
         * Creates a plain object from a TreasureSpies message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {msgProto.TreasureSpies} message TreasureSpies
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreasureSpies.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TreasureSpies to JSON.
         * @function toJSON
         * @memberof msgProto.TreasureSpies
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreasureSpies.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreasureSpies;
    })();

    msgProto.TreasureGetExPkOutInfo = (function() {

        /**
         * Properties of a TreasureGetExPkOutInfo.
         * @memberof msgProto
         * @interface ITreasureGetExPkOutInfo
         */

        /**
         * Constructs a new TreasureGetExPkOutInfo.
         * @memberof msgProto
         * @classdesc Represents a TreasureGetExPkOutInfo.
         * @implements ITreasureGetExPkOutInfo
         * @constructor
         * @param {msgProto.ITreasureGetExPkOutInfo=} [properties] Properties to set
         */
        function TreasureGetExPkOutInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified TreasureGetExPkOutInfo message. Does not implicitly {@link msgProto.TreasureGetExPkOutInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {msgProto.ITreasureGetExPkOutInfo} message TreasureGetExPkOutInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureGetExPkOutInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a TreasureGetExPkOutInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureGetExPkOutInfo} TreasureGetExPkOutInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureGetExPkOutInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureGetExPkOutInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TreasureGetExPkOutInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TreasureGetExPkOutInfo} TreasureGetExPkOutInfo
         */
        TreasureGetExPkOutInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TreasureGetExPkOutInfo)
                return object;
            return new $root.msgProto.TreasureGetExPkOutInfo();
        };

        /**
         * Creates a plain object from a TreasureGetExPkOutInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {msgProto.TreasureGetExPkOutInfo} message TreasureGetExPkOutInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreasureGetExPkOutInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TreasureGetExPkOutInfo to JSON.
         * @function toJSON
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreasureGetExPkOutInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreasureGetExPkOutInfo;
    })();

    msgProto.TreasureOpen = (function() {

        /**
         * Properties of a TreasureOpen.
         * @memberof msgProto
         * @interface ITreasureOpen
         * @property {number|null} [id] TreasureOpen id
         */

        /**
         * Constructs a new TreasureOpen.
         * @memberof msgProto
         * @classdesc Represents a TreasureOpen.
         * @implements ITreasureOpen
         * @constructor
         * @param {msgProto.ITreasureOpen=} [properties] Properties to set
         */
        function TreasureOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureOpen id.
         * @member {number} id
         * @memberof msgProto.TreasureOpen
         * @instance
         */
        TreasureOpen.prototype.id = 0;

        /**
         * Encodes the specified TreasureOpen message. Does not implicitly {@link msgProto.TreasureOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {msgProto.ITreasureOpen} message TreasureOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Decodes a TreasureOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureOpen} TreasureOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TreasureOpen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TreasureOpen} TreasureOpen
         */
        TreasureOpen.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TreasureOpen)
                return object;
            var message = new $root.msgProto.TreasureOpen();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from a TreasureOpen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {msgProto.TreasureOpen} message TreasureOpen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreasureOpen.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this TreasureOpen to JSON.
         * @function toJSON
         * @memberof msgProto.TreasureOpen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreasureOpen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreasureOpen;
    })();

    msgProto.TreasureCompose = (function() {

        /**
         * Properties of a TreasureCompose.
         * @memberof msgProto
         * @interface ITreasureCompose
         * @property {number|null} [itemId] TreasureCompose itemId
         */

        /**
         * Constructs a new TreasureCompose.
         * @memberof msgProto
         * @classdesc Represents a TreasureCompose.
         * @implements ITreasureCompose
         * @constructor
         * @param {msgProto.ITreasureCompose=} [properties] Properties to set
         */
        function TreasureCompose(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureCompose itemId.
         * @member {number} itemId
         * @memberof msgProto.TreasureCompose
         * @instance
         */
        TreasureCompose.prototype.itemId = 0;

        /**
         * Encodes the specified TreasureCompose message. Does not implicitly {@link msgProto.TreasureCompose.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {msgProto.ITreasureCompose} message TreasureCompose message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureCompose.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Decodes a TreasureCompose message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureCompose} TreasureCompose
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureCompose.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureCompose();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TreasureCompose message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TreasureCompose} TreasureCompose
         */
        TreasureCompose.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TreasureCompose)
                return object;
            var message = new $root.msgProto.TreasureCompose();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TreasureCompose message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {msgProto.TreasureCompose} message TreasureCompose
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TreasureCompose.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemId = 0;
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            return object;
        };

        /**
         * Converts this TreasureCompose to JSON.
         * @function toJSON
         * @memberof msgProto.TreasureCompose
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TreasureCompose.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TreasureCompose;
    })();

    msgProto.TalismanUseTrumpItem = (function() {

        /**
         * Properties of a TalismanUseTrumpItem.
         * @memberof msgProto
         * @interface ITalismanUseTrumpItem
         * @property {number|null} [itemId] TalismanUseTrumpItem itemId
         */

        /**
         * Constructs a new TalismanUseTrumpItem.
         * @memberof msgProto
         * @classdesc Represents a TalismanUseTrumpItem.
         * @implements ITalismanUseTrumpItem
         * @constructor
         * @param {msgProto.ITalismanUseTrumpItem=} [properties] Properties to set
         */
        function TalismanUseTrumpItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUseTrumpItem itemId.
         * @member {number} itemId
         * @memberof msgProto.TalismanUseTrumpItem
         * @instance
         */
        TalismanUseTrumpItem.prototype.itemId = 0;

        /**
         * Encodes the specified TalismanUseTrumpItem message. Does not implicitly {@link msgProto.TalismanUseTrumpItem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {msgProto.ITalismanUseTrumpItem} message TalismanUseTrumpItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUseTrumpItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Decodes a TalismanUseTrumpItem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUseTrumpItem} TalismanUseTrumpItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUseTrumpItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUseTrumpItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanUseTrumpItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanUseTrumpItem} TalismanUseTrumpItem
         */
        TalismanUseTrumpItem.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanUseTrumpItem)
                return object;
            var message = new $root.msgProto.TalismanUseTrumpItem();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanUseTrumpItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {msgProto.TalismanUseTrumpItem} message TalismanUseTrumpItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanUseTrumpItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemId = 0;
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            return object;
        };

        /**
         * Converts this TalismanUseTrumpItem to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanUseTrumpItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanUseTrumpItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanUseTrumpItem;
    })();

    msgProto.TalismanWearTrump = (function() {

        /**
         * Properties of a TalismanWearTrump.
         * @memberof msgProto
         * @interface ITalismanWearTrump
         * @property {number|null} [tempId] TalismanWearTrump tempId
         * @property {number|null} [trumpId] TalismanWearTrump trumpId
         */

        /**
         * Constructs a new TalismanWearTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanWearTrump.
         * @implements ITalismanWearTrump
         * @constructor
         * @param {msgProto.ITalismanWearTrump=} [properties] Properties to set
         */
        function TalismanWearTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanWearTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanWearTrump
         * @instance
         */
        TalismanWearTrump.prototype.tempId = 0;

        /**
         * TalismanWearTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanWearTrump
         * @instance
         */
        TalismanWearTrump.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanWearTrump message. Does not implicitly {@link msgProto.TalismanWearTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {msgProto.ITalismanWearTrump} message TalismanWearTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanWearTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanWearTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanWearTrump} TalismanWearTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanWearTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanWearTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanWearTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanWearTrump} TalismanWearTrump
         */
        TalismanWearTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanWearTrump)
                return object;
            var message = new $root.msgProto.TalismanWearTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanWearTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {msgProto.TalismanWearTrump} message TalismanWearTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanWearTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanWearTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanWearTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanWearTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanWearTrump;
    })();

    msgProto.TalismanUpTrumpLvl = (function() {

        /**
         * Properties of a TalismanUpTrumpLvl.
         * @memberof msgProto
         * @interface ITalismanUpTrumpLvl
         * @property {number|null} [tempId] TalismanUpTrumpLvl tempId
         * @property {number|null} [trumpId] TalismanUpTrumpLvl trumpId
         */

        /**
         * Constructs a new TalismanUpTrumpLvl.
         * @memberof msgProto
         * @classdesc Represents a TalismanUpTrumpLvl.
         * @implements ITalismanUpTrumpLvl
         * @constructor
         * @param {msgProto.ITalismanUpTrumpLvl=} [properties] Properties to set
         */
        function TalismanUpTrumpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUpTrumpLvl tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanUpTrumpLvl
         * @instance
         */
        TalismanUpTrumpLvl.prototype.tempId = 0;

        /**
         * TalismanUpTrumpLvl trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanUpTrumpLvl
         * @instance
         */
        TalismanUpTrumpLvl.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanUpTrumpLvl message. Does not implicitly {@link msgProto.TalismanUpTrumpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {msgProto.ITalismanUpTrumpLvl} message TalismanUpTrumpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanUpTrumpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUpTrumpLvl} TalismanUpTrumpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUpTrumpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanUpTrumpLvl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanUpTrumpLvl} TalismanUpTrumpLvl
         */
        TalismanUpTrumpLvl.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanUpTrumpLvl)
                return object;
            var message = new $root.msgProto.TalismanUpTrumpLvl();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanUpTrumpLvl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {msgProto.TalismanUpTrumpLvl} message TalismanUpTrumpLvl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanUpTrumpLvl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanUpTrumpLvl to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanUpTrumpLvl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanUpTrumpLvl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanUpTrumpLvl;
    })();

    msgProto.TalismanUpTrumpStar = (function() {

        /**
         * Properties of a TalismanUpTrumpStar.
         * @memberof msgProto
         * @interface ITalismanUpTrumpStar
         * @property {number|null} [tempId] TalismanUpTrumpStar tempId
         * @property {number|null} [trumpId] TalismanUpTrumpStar trumpId
         */

        /**
         * Constructs a new TalismanUpTrumpStar.
         * @memberof msgProto
         * @classdesc Represents a TalismanUpTrumpStar.
         * @implements ITalismanUpTrumpStar
         * @constructor
         * @param {msgProto.ITalismanUpTrumpStar=} [properties] Properties to set
         */
        function TalismanUpTrumpStar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUpTrumpStar tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanUpTrumpStar
         * @instance
         */
        TalismanUpTrumpStar.prototype.tempId = 0;

        /**
         * TalismanUpTrumpStar trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanUpTrumpStar
         * @instance
         */
        TalismanUpTrumpStar.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanUpTrumpStar message. Does not implicitly {@link msgProto.TalismanUpTrumpStar.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {msgProto.ITalismanUpTrumpStar} message TalismanUpTrumpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpStar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanUpTrumpStar message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUpTrumpStar} TalismanUpTrumpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpStar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUpTrumpStar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanUpTrumpStar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanUpTrumpStar} TalismanUpTrumpStar
         */
        TalismanUpTrumpStar.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanUpTrumpStar)
                return object;
            var message = new $root.msgProto.TalismanUpTrumpStar();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanUpTrumpStar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {msgProto.TalismanUpTrumpStar} message TalismanUpTrumpStar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanUpTrumpStar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanUpTrumpStar to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanUpTrumpStar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanUpTrumpStar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanUpTrumpStar;
    })();

    msgProto.TalismanRecastTrump = (function() {

        /**
         * Properties of a TalismanRecastTrump.
         * @memberof msgProto
         * @interface ITalismanRecastTrump
         * @property {number|null} [tempId] TalismanRecastTrump tempId
         * @property {number|null} [trumpId] TalismanRecastTrump trumpId
         */

        /**
         * Constructs a new TalismanRecastTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanRecastTrump.
         * @implements ITalismanRecastTrump
         * @constructor
         * @param {msgProto.ITalismanRecastTrump=} [properties] Properties to set
         */
        function TalismanRecastTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanRecastTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanRecastTrump
         * @instance
         */
        TalismanRecastTrump.prototype.tempId = 0;

        /**
         * TalismanRecastTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanRecastTrump
         * @instance
         */
        TalismanRecastTrump.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanRecastTrump message. Does not implicitly {@link msgProto.TalismanRecastTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {msgProto.ITalismanRecastTrump} message TalismanRecastTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanRecastTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanRecastTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanRecastTrump} TalismanRecastTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanRecastTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanRecastTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanRecastTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanRecastTrump} TalismanRecastTrump
         */
        TalismanRecastTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanRecastTrump)
                return object;
            var message = new $root.msgProto.TalismanRecastTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanRecastTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {msgProto.TalismanRecastTrump} message TalismanRecastTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanRecastTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanRecastTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanRecastTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanRecastTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanRecastTrump;
    })();

    msgProto.TalismanCompoundTrump = (function() {

        /**
         * Properties of a TalismanCompoundTrump.
         * @memberof msgProto
         * @interface ITalismanCompoundTrump
         * @property {number|null} [tempId] TalismanCompoundTrump tempId
         * @property {number|null} [trumpId] TalismanCompoundTrump trumpId
         */

        /**
         * Constructs a new TalismanCompoundTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanCompoundTrump.
         * @implements ITalismanCompoundTrump
         * @constructor
         * @param {msgProto.ITalismanCompoundTrump=} [properties] Properties to set
         */
        function TalismanCompoundTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanCompoundTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanCompoundTrump
         * @instance
         */
        TalismanCompoundTrump.prototype.tempId = 0;

        /**
         * TalismanCompoundTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanCompoundTrump
         * @instance
         */
        TalismanCompoundTrump.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanCompoundTrump message. Does not implicitly {@link msgProto.TalismanCompoundTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {msgProto.ITalismanCompoundTrump} message TalismanCompoundTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCompoundTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanCompoundTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanCompoundTrump} TalismanCompoundTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCompoundTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanCompoundTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanCompoundTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanCompoundTrump} TalismanCompoundTrump
         */
        TalismanCompoundTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanCompoundTrump)
                return object;
            var message = new $root.msgProto.TalismanCompoundTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanCompoundTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {msgProto.TalismanCompoundTrump} message TalismanCompoundTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanCompoundTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanCompoundTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanCompoundTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanCompoundTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanCompoundTrump;
    })();

    msgProto.TalismanBaptizeTrump = (function() {

        /**
         * Properties of a TalismanBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanBaptizeTrump
         * @property {number|null} [tempId] TalismanBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanBaptizeTrump trumpId
         * @property {boolean|null} [isCheck] TalismanBaptizeTrump isCheck
         */

        /**
         * Constructs a new TalismanBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanBaptizeTrump.
         * @implements ITalismanBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanBaptizeTrump=} [properties] Properties to set
         */
        function TalismanBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.trumpId = 0;

        /**
         * TalismanBaptizeTrump isCheck.
         * @member {boolean} isCheck
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.isCheck = false;

        /**
         * Encodes the specified TalismanBaptizeTrump message. Does not implicitly {@link msgProto.TalismanBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {msgProto.ITalismanBaptizeTrump} message TalismanBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            if (message.isCheck != null && message.hasOwnProperty("isCheck"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isCheck);
            return writer;
        };

        /**
         * Decodes a TalismanBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanBaptizeTrump} TalismanBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                case 3:
                    message.isCheck = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanBaptizeTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanBaptizeTrump} TalismanBaptizeTrump
         */
        TalismanBaptizeTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanBaptizeTrump)
                return object;
            var message = new $root.msgProto.TalismanBaptizeTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            if (object.isCheck != null)
                message.isCheck = Boolean(object.isCheck);
            return message;
        };

        /**
         * Creates a plain object from a TalismanBaptizeTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {msgProto.TalismanBaptizeTrump} message TalismanBaptizeTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanBaptizeTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
                object.isCheck = false;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            if (message.isCheck != null && message.hasOwnProperty("isCheck"))
                object.isCheck = message.isCheck;
            return object;
        };

        /**
         * Converts this TalismanBaptizeTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanBaptizeTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanBaptizeTrump;
    })();

    msgProto.TalismanConfirmBaptizeTrump = (function() {

        /**
         * Properties of a TalismanConfirmBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanConfirmBaptizeTrump
         * @property {number|null} [tempId] TalismanConfirmBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanConfirmBaptizeTrump trumpId
         */

        /**
         * Constructs a new TalismanConfirmBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanConfirmBaptizeTrump.
         * @implements ITalismanConfirmBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanConfirmBaptizeTrump=} [properties] Properties to set
         */
        function TalismanConfirmBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanConfirmBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @instance
         */
        TalismanConfirmBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanConfirmBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @instance
         */
        TalismanConfirmBaptizeTrump.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanConfirmBaptizeTrump message. Does not implicitly {@link msgProto.TalismanConfirmBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {msgProto.ITalismanConfirmBaptizeTrump} message TalismanConfirmBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanConfirmBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanConfirmBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanConfirmBaptizeTrump} TalismanConfirmBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanConfirmBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanConfirmBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanConfirmBaptizeTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanConfirmBaptizeTrump} TalismanConfirmBaptizeTrump
         */
        TalismanConfirmBaptizeTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanConfirmBaptizeTrump)
                return object;
            var message = new $root.msgProto.TalismanConfirmBaptizeTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanConfirmBaptizeTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {msgProto.TalismanConfirmBaptizeTrump} message TalismanConfirmBaptizeTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanConfirmBaptizeTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanConfirmBaptizeTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanConfirmBaptizeTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanConfirmBaptizeTrump;
    })();

    msgProto.TalismanCancelBaptizeTrump = (function() {

        /**
         * Properties of a TalismanCancelBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanCancelBaptizeTrump
         * @property {number|null} [tempId] TalismanCancelBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanCancelBaptizeTrump trumpId
         */

        /**
         * Constructs a new TalismanCancelBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanCancelBaptizeTrump.
         * @implements ITalismanCancelBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanCancelBaptizeTrump=} [properties] Properties to set
         */
        function TalismanCancelBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanCancelBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @instance
         */
        TalismanCancelBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanCancelBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @instance
         */
        TalismanCancelBaptizeTrump.prototype.trumpId = 0;

        /**
         * Encodes the specified TalismanCancelBaptizeTrump message. Does not implicitly {@link msgProto.TalismanCancelBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {msgProto.ITalismanCancelBaptizeTrump} message TalismanCancelBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCancelBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Decodes a TalismanCancelBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanCancelBaptizeTrump} TalismanCancelBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCancelBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanCancelBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a TalismanCancelBaptizeTrump message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.TalismanCancelBaptizeTrump} TalismanCancelBaptizeTrump
         */
        TalismanCancelBaptizeTrump.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.TalismanCancelBaptizeTrump)
                return object;
            var message = new $root.msgProto.TalismanCancelBaptizeTrump();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.trumpId != null)
                message.trumpId = object.trumpId | 0;
            return message;
        };

        /**
         * Creates a plain object from a TalismanCancelBaptizeTrump message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {msgProto.TalismanCancelBaptizeTrump} message TalismanCancelBaptizeTrump
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TalismanCancelBaptizeTrump.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.trumpId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                object.trumpId = message.trumpId;
            return object;
        };

        /**
         * Converts this TalismanCancelBaptizeTrump to JSON.
         * @function toJSON
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TalismanCancelBaptizeTrump.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TalismanCancelBaptizeTrump;
    })();

    msgProto.ExpeditionGetInfo = (function() {

        /**
         * Properties of an ExpeditionGetInfo.
         * @memberof msgProto
         * @interface IExpeditionGetInfo
         */

        /**
         * Constructs a new ExpeditionGetInfo.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionGetInfo.
         * @implements IExpeditionGetInfo
         * @constructor
         * @param {msgProto.IExpeditionGetInfo=} [properties] Properties to set
         */
        function ExpeditionGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ExpeditionGetInfo message. Does not implicitly {@link msgProto.ExpeditionGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {msgProto.IExpeditionGetInfo} message ExpeditionGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an ExpeditionGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionGetInfo} ExpeditionGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ExpeditionGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ExpeditionGetInfo} ExpeditionGetInfo
         */
        ExpeditionGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ExpeditionGetInfo)
                return object;
            return new $root.msgProto.ExpeditionGetInfo();
        };

        /**
         * Creates a plain object from an ExpeditionGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {msgProto.ExpeditionGetInfo} message ExpeditionGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpeditionGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ExpeditionGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ExpeditionGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpeditionGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExpeditionGetInfo;
    })();

    msgProto.ExpeditionWearSoul = (function() {

        /**
         * Properties of an ExpeditionWearSoul.
         * @memberof msgProto
         * @interface IExpeditionWearSoul
         * @property {number|null} [tempId] ExpeditionWearSoul tempId
         * @property {number|null} [soulId] ExpeditionWearSoul soulId
         */

        /**
         * Constructs a new ExpeditionWearSoul.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionWearSoul.
         * @implements IExpeditionWearSoul
         * @constructor
         * @param {msgProto.IExpeditionWearSoul=} [properties] Properties to set
         */
        function ExpeditionWearSoul(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionWearSoul tempId.
         * @member {number} tempId
         * @memberof msgProto.ExpeditionWearSoul
         * @instance
         */
        ExpeditionWearSoul.prototype.tempId = 0;

        /**
         * ExpeditionWearSoul soulId.
         * @member {number} soulId
         * @memberof msgProto.ExpeditionWearSoul
         * @instance
         */
        ExpeditionWearSoul.prototype.soulId = 0;

        /**
         * Encodes the specified ExpeditionWearSoul message. Does not implicitly {@link msgProto.ExpeditionWearSoul.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {msgProto.IExpeditionWearSoul} message ExpeditionWearSoul message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionWearSoul.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.soulId != null && message.hasOwnProperty("soulId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.soulId);
            return writer;
        };

        /**
         * Decodes an ExpeditionWearSoul message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionWearSoul} ExpeditionWearSoul
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionWearSoul.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionWearSoul();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.soulId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ExpeditionWearSoul message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ExpeditionWearSoul} ExpeditionWearSoul
         */
        ExpeditionWearSoul.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ExpeditionWearSoul)
                return object;
            var message = new $root.msgProto.ExpeditionWearSoul();
            if (object.tempId != null)
                message.tempId = object.tempId | 0;
            if (object.soulId != null)
                message.soulId = object.soulId | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExpeditionWearSoul message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {msgProto.ExpeditionWearSoul} message ExpeditionWearSoul
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpeditionWearSoul.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempId = 0;
                object.soulId = 0;
            }
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                object.tempId = message.tempId;
            if (message.soulId != null && message.hasOwnProperty("soulId"))
                object.soulId = message.soulId;
            return object;
        };

        /**
         * Converts this ExpeditionWearSoul to JSON.
         * @function toJSON
         * @memberof msgProto.ExpeditionWearSoul
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpeditionWearSoul.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExpeditionWearSoul;
    })();

    msgProto.ExpeditionStartBattle = (function() {

        /**
         * Properties of an ExpeditionStartBattle.
         * @memberof msgProto
         * @interface IExpeditionStartBattle
         * @property {number|null} [stageId] ExpeditionStartBattle stageId
         */

        /**
         * Constructs a new ExpeditionStartBattle.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionStartBattle.
         * @implements IExpeditionStartBattle
         * @constructor
         * @param {msgProto.IExpeditionStartBattle=} [properties] Properties to set
         */
        function ExpeditionStartBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionStartBattle stageId.
         * @member {number} stageId
         * @memberof msgProto.ExpeditionStartBattle
         * @instance
         */
        ExpeditionStartBattle.prototype.stageId = 0;

        /**
         * Encodes the specified ExpeditionStartBattle message. Does not implicitly {@link msgProto.ExpeditionStartBattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {msgProto.IExpeditionStartBattle} message ExpeditionStartBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionStartBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stageId != null && message.hasOwnProperty("stageId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stageId);
            return writer;
        };

        /**
         * Decodes an ExpeditionStartBattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionStartBattle} ExpeditionStartBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionStartBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionStartBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stageId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ExpeditionStartBattle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ExpeditionStartBattle} ExpeditionStartBattle
         */
        ExpeditionStartBattle.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ExpeditionStartBattle)
                return object;
            var message = new $root.msgProto.ExpeditionStartBattle();
            if (object.stageId != null)
                message.stageId = object.stageId | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExpeditionStartBattle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {msgProto.ExpeditionStartBattle} message ExpeditionStartBattle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpeditionStartBattle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.stageId = 0;
            if (message.stageId != null && message.hasOwnProperty("stageId"))
                object.stageId = message.stageId;
            return object;
        };

        /**
         * Converts this ExpeditionStartBattle to JSON.
         * @function toJSON
         * @memberof msgProto.ExpeditionStartBattle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpeditionStartBattle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExpeditionStartBattle;
    })();

    msgProto.ExpeditionEndBattle = (function() {

        /**
         * Properties of an ExpeditionEndBattle.
         * @memberof msgProto
         * @interface IExpeditionEndBattle
         * @property {boolean|null} [isWin] ExpeditionEndBattle isWin
         * @property {number|null} [herosHp] ExpeditionEndBattle herosHp
         */

        /**
         * Constructs a new ExpeditionEndBattle.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionEndBattle.
         * @implements IExpeditionEndBattle
         * @constructor
         * @param {msgProto.IExpeditionEndBattle=} [properties] Properties to set
         */
        function ExpeditionEndBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionEndBattle isWin.
         * @member {boolean} isWin
         * @memberof msgProto.ExpeditionEndBattle
         * @instance
         */
        ExpeditionEndBattle.prototype.isWin = false;

        /**
         * ExpeditionEndBattle herosHp.
         * @member {number} herosHp
         * @memberof msgProto.ExpeditionEndBattle
         * @instance
         */
        ExpeditionEndBattle.prototype.herosHp = 0;

        /**
         * Encodes the specified ExpeditionEndBattle message. Does not implicitly {@link msgProto.ExpeditionEndBattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {msgProto.IExpeditionEndBattle} message ExpeditionEndBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionEndBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            if (message.herosHp != null && message.hasOwnProperty("herosHp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.herosHp);
            return writer;
        };

        /**
         * Decodes an ExpeditionEndBattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionEndBattle} ExpeditionEndBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionEndBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionEndBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                case 2:
                    message.herosHp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ExpeditionEndBattle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ExpeditionEndBattle} ExpeditionEndBattle
         */
        ExpeditionEndBattle.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ExpeditionEndBattle)
                return object;
            var message = new $root.msgProto.ExpeditionEndBattle();
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.herosHp != null)
                message.herosHp = object.herosHp | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExpeditionEndBattle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {msgProto.ExpeditionEndBattle} message ExpeditionEndBattle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpeditionEndBattle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isWin = false;
                object.herosHp = 0;
            }
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.herosHp != null && message.hasOwnProperty("herosHp"))
                object.herosHp = message.herosHp;
            return object;
        };

        /**
         * Converts this ExpeditionEndBattle to JSON.
         * @function toJSON
         * @memberof msgProto.ExpeditionEndBattle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpeditionEndBattle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExpeditionEndBattle;
    })();

    msgProto.ExpeditionBuyBlackItem = (function() {

        /**
         * Properties of an ExpeditionBuyBlackItem.
         * @memberof msgProto
         * @interface IExpeditionBuyBlackItem
         * @property {number|null} [itemId] ExpeditionBuyBlackItem itemId
         */

        /**
         * Constructs a new ExpeditionBuyBlackItem.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionBuyBlackItem.
         * @implements IExpeditionBuyBlackItem
         * @constructor
         * @param {msgProto.IExpeditionBuyBlackItem=} [properties] Properties to set
         */
        function ExpeditionBuyBlackItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionBuyBlackItem itemId.
         * @member {number} itemId
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @instance
         */
        ExpeditionBuyBlackItem.prototype.itemId = 0;

        /**
         * Encodes the specified ExpeditionBuyBlackItem message. Does not implicitly {@link msgProto.ExpeditionBuyBlackItem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {msgProto.IExpeditionBuyBlackItem} message ExpeditionBuyBlackItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionBuyBlackItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Decodes an ExpeditionBuyBlackItem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionBuyBlackItem} ExpeditionBuyBlackItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionBuyBlackItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionBuyBlackItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an ExpeditionBuyBlackItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ExpeditionBuyBlackItem} ExpeditionBuyBlackItem
         */
        ExpeditionBuyBlackItem.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ExpeditionBuyBlackItem)
                return object;
            var message = new $root.msgProto.ExpeditionBuyBlackItem();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            return message;
        };

        /**
         * Creates a plain object from an ExpeditionBuyBlackItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {msgProto.ExpeditionBuyBlackItem} message ExpeditionBuyBlackItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpeditionBuyBlackItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemId = 0;
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            return object;
        };

        /**
         * Converts this ExpeditionBuyBlackItem to JSON.
         * @function toJSON
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpeditionBuyBlackItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExpeditionBuyBlackItem;
    })();

    msgProto.UserCreate = (function() {

        /**
         * Properties of a UserCreate.
         * @memberof msgProto
         * @interface IUserCreate
         * @property {string|null} [name] UserCreate name
         * @property {number|null} [heroTempId] UserCreate heroTempId
         * @property {number|null} [sex] UserCreate sex
         * @property {number|null} [serverIndexId] UserCreate serverIndexId
         * @property {string|null} [shareKey] UserCreate shareKey
         */

        /**
         * Constructs a new UserCreate.
         * @memberof msgProto
         * @classdesc Represents a UserCreate.
         * @implements IUserCreate
         * @constructor
         * @param {msgProto.IUserCreate=} [properties] Properties to set
         */
        function UserCreate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCreate name.
         * @member {string} name
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.name = "";

        /**
         * UserCreate heroTempId.
         * @member {number} heroTempId
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.heroTempId = 0;

        /**
         * UserCreate sex.
         * @member {number} sex
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.sex = 0;

        /**
         * UserCreate serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.serverIndexId = 0;

        /**
         * UserCreate shareKey.
         * @member {string} shareKey
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.shareKey = "";

        /**
         * Encodes the specified UserCreate message. Does not implicitly {@link msgProto.UserCreate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserCreate
         * @static
         * @param {msgProto.IUserCreate} message UserCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroTempId);
            if (message.sex != null && message.hasOwnProperty("sex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sex);
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.serverIndexId);
            if (message.shareKey != null && message.hasOwnProperty("shareKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.shareKey);
            return writer;
        };

        /**
         * Decodes a UserCreate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserCreate} UserCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserCreate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.heroTempId = reader.int32();
                    break;
                case 3:
                    message.sex = reader.int32();
                    break;
                case 4:
                    message.serverIndexId = reader.int32();
                    break;
                case 5:
                    message.shareKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserCreate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserCreate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserCreate} UserCreate
         */
        UserCreate.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserCreate)
                return object;
            var message = new $root.msgProto.UserCreate();
            if (object.name != null)
                message.name = String(object.name);
            if (object.heroTempId != null)
                message.heroTempId = object.heroTempId | 0;
            if (object.sex != null)
                message.sex = object.sex | 0;
            if (object.serverIndexId != null)
                message.serverIndexId = object.serverIndexId | 0;
            if (object.shareKey != null)
                message.shareKey = String(object.shareKey);
            return message;
        };

        /**
         * Creates a plain object from a UserCreate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserCreate
         * @static
         * @param {msgProto.UserCreate} message UserCreate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserCreate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.heroTempId = 0;
                object.sex = 0;
                object.serverIndexId = 0;
                object.shareKey = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                object.heroTempId = message.heroTempId;
            if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex = message.sex;
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                object.serverIndexId = message.serverIndexId;
            if (message.shareKey != null && message.hasOwnProperty("shareKey"))
                object.shareKey = message.shareKey;
            return object;
        };

        /**
         * Converts this UserCreate to JSON.
         * @function toJSON
         * @memberof msgProto.UserCreate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserCreate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserCreate;
    })();

    msgProto.UserCreateResponse = (function() {

        /**
         * Properties of a UserCreateResponse.
         * @memberof msgProto
         * @interface IUserCreateResponse
         * @property {number|null} [retCode] UserCreateResponse retCode
         */

        /**
         * Constructs a new UserCreateResponse.
         * @memberof msgProto
         * @classdesc Represents a UserCreateResponse.
         * @implements IUserCreateResponse
         * @constructor
         * @param {msgProto.IUserCreateResponse=} [properties] Properties to set
         */
        function UserCreateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCreateResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.UserCreateResponse
         * @instance
         */
        UserCreateResponse.prototype.retCode = 0;

        /**
         * Encodes the specified UserCreateResponse message. Does not implicitly {@link msgProto.UserCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {msgProto.IUserCreateResponse} message UserCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            return writer;
        };

        /**
         * Decodes a UserCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserCreateResponse} UserCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserCreateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserCreateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserCreateResponse} UserCreateResponse
         */
        UserCreateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserCreateResponse)
                return object;
            var message = new $root.msgProto.UserCreateResponse();
            if (object.retCode != null)
                message.retCode = object.retCode | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserCreateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {msgProto.UserCreateResponse} message UserCreateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserCreateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.retCode = 0;
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                object.retCode = message.retCode;
            return object;
        };

        /**
         * Converts this UserCreateResponse to JSON.
         * @function toJSON
         * @memberof msgProto.UserCreateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserCreateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserCreateResponse;
    })();

    msgProto.GameEnter = (function() {

        /**
         * Properties of a GameEnter.
         * @memberof msgProto
         * @interface IGameEnter
         * @property {number|Long|null} [accId] GameEnter accId
         * @property {string|null} [loginKey] GameEnter loginKey
         * @property {number|null} [serverIndexId] GameEnter serverIndexId
         */

        /**
         * Constructs a new GameEnter.
         * @memberof msgProto
         * @classdesc Represents a GameEnter.
         * @implements IGameEnter
         * @constructor
         * @param {msgProto.IGameEnter=} [properties] Properties to set
         */
        function GameEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEnter accId.
         * @member {number|Long} accId
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GameEnter loginKey.
         * @member {string} loginKey
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.loginKey = "";

        /**
         * GameEnter serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.serverIndexId = 0;

        /**
         * Encodes the specified GameEnter message. Does not implicitly {@link msgProto.GameEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GameEnter
         * @static
         * @param {msgProto.IGameEnter} message GameEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.accId);
            if (message.loginKey != null && message.hasOwnProperty("loginKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.loginKey);
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.serverIndexId);
            return writer;
        };

        /**
         * Decodes a GameEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GameEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GameEnter} GameEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GameEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accId = reader.int64();
                    break;
                case 2:
                    message.loginKey = reader.string();
                    break;
                case 3:
                    message.serverIndexId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GameEnter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GameEnter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GameEnter} GameEnter
         */
        GameEnter.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GameEnter)
                return object;
            var message = new $root.msgProto.GameEnter();
            if (object.accId != null)
                if ($util.Long)
                    (message.accId = $util.Long.fromValue(object.accId)).unsigned = false;
                else if (typeof object.accId === "string")
                    message.accId = parseInt(object.accId, 10);
                else if (typeof object.accId === "number")
                    message.accId = object.accId;
                else if (typeof object.accId === "object")
                    message.accId = new $util.LongBits(object.accId.low >>> 0, object.accId.high >>> 0).toNumber();
            if (object.loginKey != null)
                message.loginKey = String(object.loginKey);
            if (object.serverIndexId != null)
                message.serverIndexId = object.serverIndexId | 0;
            return message;
        };

        /**
         * Creates a plain object from a GameEnter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GameEnter
         * @static
         * @param {msgProto.GameEnter} message GameEnter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameEnter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accId = options.longs === String ? "0" : 0;
                object.loginKey = "";
                object.serverIndexId = 0;
            }
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (typeof message.accId === "number")
                    object.accId = options.longs === String ? String(message.accId) : message.accId;
                else
                    object.accId = options.longs === String ? $util.Long.prototype.toString.call(message.accId) : options.longs === Number ? new $util.LongBits(message.accId.low >>> 0, message.accId.high >>> 0).toNumber() : message.accId;
            if (message.loginKey != null && message.hasOwnProperty("loginKey"))
                object.loginKey = message.loginKey;
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                object.serverIndexId = message.serverIndexId;
            return object;
        };

        /**
         * Converts this GameEnter to JSON.
         * @function toJSON
         * @memberof msgProto.GameEnter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameEnter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameEnter;
    })();

    msgProto.GameEnterResponse = (function() {

        /**
         * Properties of a GameEnterResponse.
         * @memberof msgProto
         * @interface IGameEnterResponse
         * @property {number|null} [retCode] GameEnterResponse retCode
         * @property {string|null} [nickName] GameEnterResponse nickName
         * @property {number|Long|null} [userId] GameEnterResponse userId
         */

        /**
         * Constructs a new GameEnterResponse.
         * @memberof msgProto
         * @classdesc Represents a GameEnterResponse.
         * @implements IGameEnterResponse
         * @constructor
         * @param {msgProto.IGameEnterResponse=} [properties] Properties to set
         */
        function GameEnterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEnterResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.retCode = 0;

        /**
         * GameEnterResponse nickName.
         * @member {string} nickName
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.nickName = "";

        /**
         * GameEnterResponse userId.
         * @member {number|Long} userId
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified GameEnterResponse message. Does not implicitly {@link msgProto.GameEnterResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {msgProto.IGameEnterResponse} message GameEnterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickName);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.userId);
            return writer;
        };

        /**
         * Decodes a GameEnterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GameEnterResponse} GameEnterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GameEnterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.userId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a GameEnterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.GameEnterResponse} GameEnterResponse
         */
        GameEnterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.GameEnterResponse)
                return object;
            var message = new $root.msgProto.GameEnterResponse();
            if (object.retCode != null)
                message.retCode = object.retCode | 0;
            if (object.nickName != null)
                message.nickName = String(object.nickName);
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = false;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GameEnterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {msgProto.GameEnterResponse} message GameEnterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameEnterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retCode = 0;
                object.nickName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
            }
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                object.retCode = message.retCode;
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                object.nickName = message.nickName;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber() : message.userId;
            return object;
        };

        /**
         * Converts this GameEnterResponse to JSON.
         * @function toJSON
         * @memberof msgProto.GameEnterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameEnterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GameEnterResponse;
    })();

    msgProto.AccountGetThirdUserInfo = (function() {

        /**
         * Properties of an AccountGetThirdUserInfo.
         * @memberof msgProto
         * @interface IAccountGetThirdUserInfo
         */

        /**
         * Constructs a new AccountGetThirdUserInfo.
         * @memberof msgProto
         * @classdesc Represents an AccountGetThirdUserInfo.
         * @implements IAccountGetThirdUserInfo
         * @constructor
         * @param {msgProto.IAccountGetThirdUserInfo=} [properties] Properties to set
         */
        function AccountGetThirdUserInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AccountGetThirdUserInfo message. Does not implicitly {@link msgProto.AccountGetThirdUserInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {msgProto.IAccountGetThirdUserInfo} message AccountGetThirdUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountGetThirdUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AccountGetThirdUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountGetThirdUserInfo} AccountGetThirdUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountGetThirdUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountGetThirdUserInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AccountGetThirdUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AccountGetThirdUserInfo} AccountGetThirdUserInfo
         */
        AccountGetThirdUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AccountGetThirdUserInfo)
                return object;
            return new $root.msgProto.AccountGetThirdUserInfo();
        };

        /**
         * Creates a plain object from an AccountGetThirdUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {msgProto.AccountGetThirdUserInfo} message AccountGetThirdUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountGetThirdUserInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AccountGetThirdUserInfo to JSON.
         * @function toJSON
         * @memberof msgProto.AccountGetThirdUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountGetThirdUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountGetThirdUserInfo;
    })();

    msgProto.NetConnect = (function() {

        /**
         * Properties of a NetConnect.
         * @memberof msgProto
         * @interface INetConnect
         */

        /**
         * Constructs a new NetConnect.
         * @memberof msgProto
         * @classdesc Represents a NetConnect.
         * @implements INetConnect
         * @constructor
         * @param {msgProto.INetConnect=} [properties] Properties to set
         */
        function NetConnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified NetConnect message. Does not implicitly {@link msgProto.NetConnect.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetConnect
         * @static
         * @param {msgProto.INetConnect} message NetConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a NetConnect message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetConnect} NetConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetConnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a NetConnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.NetConnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.NetConnect} NetConnect
         */
        NetConnect.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.NetConnect)
                return object;
            return new $root.msgProto.NetConnect();
        };

        /**
         * Creates a plain object from a NetConnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.NetConnect
         * @static
         * @param {msgProto.NetConnect} message NetConnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetConnect.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NetConnect to JSON.
         * @function toJSON
         * @memberof msgProto.NetConnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetConnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetConnect;
    })();

    msgProto.NetDisconnect = (function() {

        /**
         * Properties of a NetDisconnect.
         * @memberof msgProto
         * @interface INetDisconnect
         * @property {string|null} [sessionId] NetDisconnect sessionId
         */

        /**
         * Constructs a new NetDisconnect.
         * @memberof msgProto
         * @classdesc Represents a NetDisconnect.
         * @implements INetDisconnect
         * @constructor
         * @param {msgProto.INetDisconnect=} [properties] Properties to set
         */
        function NetDisconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetDisconnect sessionId.
         * @member {string} sessionId
         * @memberof msgProto.NetDisconnect
         * @instance
         */
        NetDisconnect.prototype.sessionId = "";

        /**
         * Encodes the specified NetDisconnect message. Does not implicitly {@link msgProto.NetDisconnect.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {msgProto.INetDisconnect} message NetDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetDisconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
            return writer;
        };

        /**
         * Decodes a NetDisconnect message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetDisconnect} NetDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetDisconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetDisconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a NetDisconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.NetDisconnect} NetDisconnect
         */
        NetDisconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.NetDisconnect)
                return object;
            var message = new $root.msgProto.NetDisconnect();
            if (object.sessionId != null)
                message.sessionId = String(object.sessionId);
            return message;
        };

        /**
         * Creates a plain object from a NetDisconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {msgProto.NetDisconnect} message NetDisconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetDisconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sessionId = "";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            return object;
        };

        /**
         * Converts this NetDisconnect to JSON.
         * @function toJSON
         * @memberof msgProto.NetDisconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetDisconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetDisconnect;
    })();

    msgProto.NetGetServerDate = (function() {

        /**
         * Properties of a NetGetServerDate.
         * @memberof msgProto
         * @interface INetGetServerDate
         */

        /**
         * Constructs a new NetGetServerDate.
         * @memberof msgProto
         * @classdesc Represents a NetGetServerDate.
         * @implements INetGetServerDate
         * @constructor
         * @param {msgProto.INetGetServerDate=} [properties] Properties to set
         */
        function NetGetServerDate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified NetGetServerDate message. Does not implicitly {@link msgProto.NetGetServerDate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {msgProto.INetGetServerDate} message NetGetServerDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetGetServerDate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a NetGetServerDate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetGetServerDate} NetGetServerDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetGetServerDate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetGetServerDate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a NetGetServerDate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.NetGetServerDate} NetGetServerDate
         */
        NetGetServerDate.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.NetGetServerDate)
                return object;
            return new $root.msgProto.NetGetServerDate();
        };

        /**
         * Creates a plain object from a NetGetServerDate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {msgProto.NetGetServerDate} message NetGetServerDate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetGetServerDate.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NetGetServerDate to JSON.
         * @function toJSON
         * @memberof msgProto.NetGetServerDate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetGetServerDate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetGetServerDate;
    })();

    msgProto.AccountLogin = (function() {

        /**
         * Properties of an AccountLogin.
         * @memberof msgProto
         * @interface IAccountLogin
         * @property {string|null} [account] AccountLogin account
         * @property {string|null} [pwd] AccountLogin pwd
         * @property {number|null} [channelId] AccountLogin channelId
         */

        /**
         * Constructs a new AccountLogin.
         * @memberof msgProto
         * @classdesc Represents an AccountLogin.
         * @implements IAccountLogin
         * @constructor
         * @param {msgProto.IAccountLogin=} [properties] Properties to set
         */
        function AccountLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountLogin account.
         * @member {string} account
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.account = "";

        /**
         * AccountLogin pwd.
         * @member {string} pwd
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.pwd = "";

        /**
         * AccountLogin channelId.
         * @member {number} channelId
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.channelId = 0;

        /**
         * Encodes the specified AccountLogin message. Does not implicitly {@link msgProto.AccountLogin.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountLogin
         * @static
         * @param {msgProto.IAccountLogin} message AccountLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelId);
            return writer;
        };

        /**
         * Decodes an AccountLogin message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountLogin} AccountLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.channelId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AccountLogin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AccountLogin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AccountLogin} AccountLogin
         */
        AccountLogin.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AccountLogin)
                return object;
            var message = new $root.msgProto.AccountLogin();
            if (object.account != null)
                message.account = String(object.account);
            if (object.pwd != null)
                message.pwd = String(object.pwd);
            if (object.channelId != null)
                message.channelId = object.channelId | 0;
            return message;
        };

        /**
         * Creates a plain object from an AccountLogin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AccountLogin
         * @static
         * @param {msgProto.AccountLogin} message AccountLogin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountLogin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = "";
                object.pwd = "";
                object.channelId = 0;
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                object.pwd = message.pwd;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            return object;
        };

        /**
         * Converts this AccountLogin to JSON.
         * @function toJSON
         * @memberof msgProto.AccountLogin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountLogin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountLogin;
    })();

    msgProto.LoginResponse = (function() {

        /**
         * Properties of a LoginResponse.
         * @memberof msgProto
         * @interface ILoginResponse
         * @property {number|null} [retCode] LoginResponse retCode
         * @property {number|Long|null} [accId] LoginResponse accId
         * @property {string|null} [account] LoginResponse account
         * @property {string|null} [Email] LoginResponse Email
         * @property {string|null} [DeviceId] LoginResponse DeviceId
         * @property {number|null} [Status] LoginResponse Status
         * @property {string|null} [SdkData] LoginResponse SdkData
         * @property {string|null} [ExData] LoginResponse ExData
         * @property {number|null} [LoginCount] LoginResponse LoginCount
         * @property {string|null} [LoginKey] LoginResponse LoginKey
         * @property {string|null} [UserServers] LoginResponse UserServers
         * @property {string|null} [RechargeCom] LoginResponse RechargeCom
         * @property {string|null} [SdkChannelId] LoginResponse SdkChannelId
         * @property {number|Long|null} [BendExpireAt] LoginResponse BendExpireAt
         * @property {number|null} [BendType] LoginResponse BendType
         */

        /**
         * Constructs a new LoginResponse.
         * @memberof msgProto
         * @classdesc Represents a LoginResponse.
         * @implements ILoginResponse
         * @constructor
         * @param {msgProto.ILoginResponse=} [properties] Properties to set
         */
        function LoginResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.retCode = 0;

        /**
         * LoginResponse accId.
         * @member {number|Long} accId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginResponse account.
         * @member {string} account
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.account = "";

        /**
         * LoginResponse Email.
         * @member {string} Email
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.Email = "";

        /**
         * LoginResponse DeviceId.
         * @member {string} DeviceId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.DeviceId = "";

        /**
         * LoginResponse Status.
         * @member {number} Status
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.Status = 0;

        /**
         * LoginResponse SdkData.
         * @member {string} SdkData
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.SdkData = "";

        /**
         * LoginResponse ExData.
         * @member {string} ExData
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.ExData = "";

        /**
         * LoginResponse LoginCount.
         * @member {number} LoginCount
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.LoginCount = 0;

        /**
         * LoginResponse LoginKey.
         * @member {string} LoginKey
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.LoginKey = "";

        /**
         * LoginResponse UserServers.
         * @member {string} UserServers
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.UserServers = "";

        /**
         * LoginResponse RechargeCom.
         * @member {string} RechargeCom
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.RechargeCom = "";

        /**
         * LoginResponse SdkChannelId.
         * @member {string} SdkChannelId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.SdkChannelId = "";

        /**
         * LoginResponse BendExpireAt.
         * @member {number|Long} BendExpireAt
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.BendExpireAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginResponse BendType.
         * @member {number} BendType
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.BendType = 0;

        /**
         * Encodes the specified LoginResponse message. Does not implicitly {@link msgProto.LoginResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginResponse
         * @static
         * @param {msgProto.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accId);
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.account);
            if (message.Email != null && message.hasOwnProperty("Email"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Email);
            if (message.DeviceId != null && message.hasOwnProperty("DeviceId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.DeviceId);
            if (message.Status != null && message.hasOwnProperty("Status"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Status);
            if (message.SdkData != null && message.hasOwnProperty("SdkData"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.SdkData);
            if (message.ExData != null && message.hasOwnProperty("ExData"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.ExData);
            if (message.LoginCount != null && message.hasOwnProperty("LoginCount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.LoginCount);
            if (message.LoginKey != null && message.hasOwnProperty("LoginKey"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.LoginKey);
            if (message.UserServers != null && message.hasOwnProperty("UserServers"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.UserServers);
            if (message.RechargeCom != null && message.hasOwnProperty("RechargeCom"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.RechargeCom);
            if (message.SdkChannelId != null && message.hasOwnProperty("SdkChannelId"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.SdkChannelId);
            if (message.BendExpireAt != null && message.hasOwnProperty("BendExpireAt"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.BendExpireAt);
            if (message.BendType != null && message.hasOwnProperty("BendType"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.BendType);
            return writer;
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.accId = reader.int64();
                    break;
                case 3:
                    message.account = reader.string();
                    break;
                case 4:
                    message.Email = reader.string();
                    break;
                case 5:
                    message.DeviceId = reader.string();
                    break;
                case 6:
                    message.Status = reader.int32();
                    break;
                case 8:
                    message.SdkData = reader.string();
                    break;
                case 9:
                    message.ExData = reader.string();
                    break;
                case 10:
                    message.LoginCount = reader.int32();
                    break;
                case 11:
                    message.LoginKey = reader.string();
                    break;
                case 12:
                    message.UserServers = reader.string();
                    break;
                case 13:
                    message.RechargeCom = reader.string();
                    break;
                case 14:
                    message.SdkChannelId = reader.string();
                    break;
                case 15:
                    message.BendExpireAt = reader.int64();
                    break;
                case 16:
                    message.BendType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LoginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LoginResponse} LoginResponse
         */
        LoginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LoginResponse)
                return object;
            var message = new $root.msgProto.LoginResponse();
            if (object.retCode != null)
                message.retCode = object.retCode | 0;
            if (object.accId != null)
                if ($util.Long)
                    (message.accId = $util.Long.fromValue(object.accId)).unsigned = false;
                else if (typeof object.accId === "string")
                    message.accId = parseInt(object.accId, 10);
                else if (typeof object.accId === "number")
                    message.accId = object.accId;
                else if (typeof object.accId === "object")
                    message.accId = new $util.LongBits(object.accId.low >>> 0, object.accId.high >>> 0).toNumber();
            if (object.account != null)
                message.account = String(object.account);
            if (object.Email != null)
                message.Email = String(object.Email);
            if (object.DeviceId != null)
                message.DeviceId = String(object.DeviceId);
            if (object.Status != null)
                message.Status = object.Status | 0;
            if (object.SdkData != null)
                message.SdkData = String(object.SdkData);
            if (object.ExData != null)
                message.ExData = String(object.ExData);
            if (object.LoginCount != null)
                message.LoginCount = object.LoginCount | 0;
            if (object.LoginKey != null)
                message.LoginKey = String(object.LoginKey);
            if (object.UserServers != null)
                message.UserServers = String(object.UserServers);
            if (object.RechargeCom != null)
                message.RechargeCom = String(object.RechargeCom);
            if (object.SdkChannelId != null)
                message.SdkChannelId = String(object.SdkChannelId);
            if (object.BendExpireAt != null)
                if ($util.Long)
                    (message.BendExpireAt = $util.Long.fromValue(object.BendExpireAt)).unsigned = false;
                else if (typeof object.BendExpireAt === "string")
                    message.BendExpireAt = parseInt(object.BendExpireAt, 10);
                else if (typeof object.BendExpireAt === "number")
                    message.BendExpireAt = object.BendExpireAt;
                else if (typeof object.BendExpireAt === "object")
                    message.BendExpireAt = new $util.LongBits(object.BendExpireAt.low >>> 0, object.BendExpireAt.high >>> 0).toNumber();
            if (object.BendType != null)
                message.BendType = object.BendType | 0;
            return message;
        };

        /**
         * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LoginResponse
         * @static
         * @param {msgProto.LoginResponse} message LoginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retCode = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accId = options.longs === String ? "0" : 0;
                object.account = "";
                object.Email = "";
                object.DeviceId = "";
                object.Status = 0;
                object.SdkData = "";
                object.ExData = "";
                object.LoginCount = 0;
                object.LoginKey = "";
                object.UserServers = "";
                object.RechargeCom = "";
                object.SdkChannelId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.BendExpireAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.BendExpireAt = options.longs === String ? "0" : 0;
                object.BendType = 0;
            }
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                object.retCode = message.retCode;
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (typeof message.accId === "number")
                    object.accId = options.longs === String ? String(message.accId) : message.accId;
                else
                    object.accId = options.longs === String ? $util.Long.prototype.toString.call(message.accId) : options.longs === Number ? new $util.LongBits(message.accId.low >>> 0, message.accId.high >>> 0).toNumber() : message.accId;
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.Email != null && message.hasOwnProperty("Email"))
                object.Email = message.Email;
            if (message.DeviceId != null && message.hasOwnProperty("DeviceId"))
                object.DeviceId = message.DeviceId;
            if (message.Status != null && message.hasOwnProperty("Status"))
                object.Status = message.Status;
            if (message.SdkData != null && message.hasOwnProperty("SdkData"))
                object.SdkData = message.SdkData;
            if (message.ExData != null && message.hasOwnProperty("ExData"))
                object.ExData = message.ExData;
            if (message.LoginCount != null && message.hasOwnProperty("LoginCount"))
                object.LoginCount = message.LoginCount;
            if (message.LoginKey != null && message.hasOwnProperty("LoginKey"))
                object.LoginKey = message.LoginKey;
            if (message.UserServers != null && message.hasOwnProperty("UserServers"))
                object.UserServers = message.UserServers;
            if (message.RechargeCom != null && message.hasOwnProperty("RechargeCom"))
                object.RechargeCom = message.RechargeCom;
            if (message.SdkChannelId != null && message.hasOwnProperty("SdkChannelId"))
                object.SdkChannelId = message.SdkChannelId;
            if (message.BendExpireAt != null && message.hasOwnProperty("BendExpireAt"))
                if (typeof message.BendExpireAt === "number")
                    object.BendExpireAt = options.longs === String ? String(message.BendExpireAt) : message.BendExpireAt;
                else
                    object.BendExpireAt = options.longs === String ? $util.Long.prototype.toString.call(message.BendExpireAt) : options.longs === Number ? new $util.LongBits(message.BendExpireAt.low >>> 0, message.BendExpireAt.high >>> 0).toNumber() : message.BendExpireAt;
            if (message.BendType != null && message.hasOwnProperty("BendType"))
                object.BendType = message.BendType;
            return object;
        };

        /**
         * Converts this LoginResponse to JSON.
         * @function toJSON
         * @memberof msgProto.LoginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginResponse;
    })();

    msgProto.AccountLoginBySdk = (function() {

        /**
         * Properties of an AccountLoginBySdk.
         * @memberof msgProto
         * @interface IAccountLoginBySdk
         * @property {string|null} [channelId] AccountLoginBySdk channelId
         * @property {string|null} [sdkData] AccountLoginBySdk sdkData
         * @property {string|null} [deviceId] AccountLoginBySdk deviceId
         */

        /**
         * Constructs a new AccountLoginBySdk.
         * @memberof msgProto
         * @classdesc Represents an AccountLoginBySdk.
         * @implements IAccountLoginBySdk
         * @constructor
         * @param {msgProto.IAccountLoginBySdk=} [properties] Properties to set
         */
        function AccountLoginBySdk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountLoginBySdk channelId.
         * @member {string} channelId
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.channelId = "";

        /**
         * AccountLoginBySdk sdkData.
         * @member {string} sdkData
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.sdkData = "";

        /**
         * AccountLoginBySdk deviceId.
         * @member {string} deviceId
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.deviceId = "";

        /**
         * Encodes the specified AccountLoginBySdk message. Does not implicitly {@link msgProto.AccountLoginBySdk.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {msgProto.IAccountLoginBySdk} message AccountLoginBySdk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginBySdk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
            if (message.sdkData != null && message.hasOwnProperty("sdkData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdkData);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceId);
            return writer;
        };

        /**
         * Decodes an AccountLoginBySdk message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountLoginBySdk} AccountLoginBySdk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginBySdk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountLoginBySdk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.string();
                    break;
                case 2:
                    message.sdkData = reader.string();
                    break;
                case 3:
                    message.deviceId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AccountLoginBySdk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AccountLoginBySdk} AccountLoginBySdk
         */
        AccountLoginBySdk.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AccountLoginBySdk)
                return object;
            var message = new $root.msgProto.AccountLoginBySdk();
            if (object.channelId != null)
                message.channelId = String(object.channelId);
            if (object.sdkData != null)
                message.sdkData = String(object.sdkData);
            if (object.deviceId != null)
                message.deviceId = String(object.deviceId);
            return message;
        };

        /**
         * Creates a plain object from an AccountLoginBySdk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {msgProto.AccountLoginBySdk} message AccountLoginBySdk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountLoginBySdk.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channelId = "";
                object.sdkData = "";
                object.deviceId = "";
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            if (message.sdkData != null && message.hasOwnProperty("sdkData"))
                object.sdkData = message.sdkData;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = message.deviceId;
            return object;
        };

        /**
         * Converts this AccountLoginBySdk to JSON.
         * @function toJSON
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountLoginBySdk.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountLoginBySdk;
    })();

    msgProto.AccountRegister = (function() {

        /**
         * Properties of an AccountRegister.
         * @memberof msgProto
         * @interface IAccountRegister
         * @property {string|null} [account] AccountRegister account
         * @property {string|null} [pwd] AccountRegister pwd
         * @property {number|null} [channelId] AccountRegister channelId
         * @property {string|null} [deviceId] AccountRegister deviceId
         */

        /**
         * Constructs a new AccountRegister.
         * @memberof msgProto
         * @classdesc Represents an AccountRegister.
         * @implements IAccountRegister
         * @constructor
         * @param {msgProto.IAccountRegister=} [properties] Properties to set
         */
        function AccountRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountRegister account.
         * @member {string} account
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.account = "";

        /**
         * AccountRegister pwd.
         * @member {string} pwd
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.pwd = "";

        /**
         * AccountRegister channelId.
         * @member {number} channelId
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.channelId = 0;

        /**
         * AccountRegister deviceId.
         * @member {string} deviceId
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.deviceId = "";

        /**
         * Encodes the specified AccountRegister message. Does not implicitly {@link msgProto.AccountRegister.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountRegister
         * @static
         * @param {msgProto.IAccountRegister} message AccountRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelId);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceId);
            return writer;
        };

        /**
         * Decodes an AccountRegister message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountRegister} AccountRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.channelId = reader.int32();
                    break;
                case 4:
                    message.deviceId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AccountRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AccountRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AccountRegister} AccountRegister
         */
        AccountRegister.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AccountRegister)
                return object;
            var message = new $root.msgProto.AccountRegister();
            if (object.account != null)
                message.account = String(object.account);
            if (object.pwd != null)
                message.pwd = String(object.pwd);
            if (object.channelId != null)
                message.channelId = object.channelId | 0;
            if (object.deviceId != null)
                message.deviceId = String(object.deviceId);
            return message;
        };

        /**
         * Creates a plain object from an AccountRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AccountRegister
         * @static
         * @param {msgProto.AccountRegister} message AccountRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountRegister.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = "";
                object.pwd = "";
                object.channelId = 0;
                object.deviceId = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                object.pwd = message.pwd;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = message.deviceId;
            return object;
        };

        /**
         * Converts this AccountRegister to JSON.
         * @function toJSON
         * @memberof msgProto.AccountRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountRegister.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountRegister;
    })();

    msgProto.NoticeGetNewOne = (function() {

        /**
         * Properties of a NoticeGetNewOne.
         * @memberof msgProto
         * @interface INoticeGetNewOne
         */

        /**
         * Constructs a new NoticeGetNewOne.
         * @memberof msgProto
         * @classdesc Represents a NoticeGetNewOne.
         * @implements INoticeGetNewOne
         * @constructor
         * @param {msgProto.INoticeGetNewOne=} [properties] Properties to set
         */
        function NoticeGetNewOne(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified NoticeGetNewOne message. Does not implicitly {@link msgProto.NoticeGetNewOne.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {msgProto.INoticeGetNewOne} message NoticeGetNewOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetNewOne.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a NoticeGetNewOne message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NoticeGetNewOne} NoticeGetNewOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetNewOne.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NoticeGetNewOne();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a NoticeGetNewOne message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.NoticeGetNewOne} NoticeGetNewOne
         */
        NoticeGetNewOne.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.NoticeGetNewOne)
                return object;
            return new $root.msgProto.NoticeGetNewOne();
        };

        /**
         * Creates a plain object from a NoticeGetNewOne message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {msgProto.NoticeGetNewOne} message NoticeGetNewOne
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoticeGetNewOne.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NoticeGetNewOne to JSON.
         * @function toJSON
         * @memberof msgProto.NoticeGetNewOne
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoticeGetNewOne.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoticeGetNewOne;
    })();

    msgProto.NoticeGetList = (function() {

        /**
         * Properties of a NoticeGetList.
         * @memberof msgProto
         * @interface INoticeGetList
         */

        /**
         * Constructs a new NoticeGetList.
         * @memberof msgProto
         * @classdesc Represents a NoticeGetList.
         * @implements INoticeGetList
         * @constructor
         * @param {msgProto.INoticeGetList=} [properties] Properties to set
         */
        function NoticeGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified NoticeGetList message. Does not implicitly {@link msgProto.NoticeGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {msgProto.INoticeGetList} message NoticeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a NoticeGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NoticeGetList} NoticeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NoticeGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a NoticeGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.NoticeGetList} NoticeGetList
         */
        NoticeGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.NoticeGetList)
                return object;
            return new $root.msgProto.NoticeGetList();
        };

        /**
         * Creates a plain object from a NoticeGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {msgProto.NoticeGetList} message NoticeGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoticeGetList.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NoticeGetList to JSON.
         * @function toJSON
         * @memberof msgProto.NoticeGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoticeGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoticeGetList;
    })();

    msgProto.ProtocolContentGetInfo = (function() {

        /**
         * Properties of a ProtocolContentGetInfo.
         * @memberof msgProto
         * @interface IProtocolContentGetInfo
         */

        /**
         * Constructs a new ProtocolContentGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ProtocolContentGetInfo.
         * @implements IProtocolContentGetInfo
         * @constructor
         * @param {msgProto.IProtocolContentGetInfo=} [properties] Properties to set
         */
        function ProtocolContentGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified ProtocolContentGetInfo message. Does not implicitly {@link msgProto.ProtocolContentGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {msgProto.IProtocolContentGetInfo} message ProtocolContentGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolContentGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ProtocolContentGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ProtocolContentGetInfo} ProtocolContentGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolContentGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ProtocolContentGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ProtocolContentGetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ProtocolContentGetInfo} ProtocolContentGetInfo
         */
        ProtocolContentGetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ProtocolContentGetInfo)
                return object;
            return new $root.msgProto.ProtocolContentGetInfo();
        };

        /**
         * Creates a plain object from a ProtocolContentGetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {msgProto.ProtocolContentGetInfo} message ProtocolContentGetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtocolContentGetInfo.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ProtocolContentGetInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ProtocolContentGetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtocolContentGetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProtocolContentGetInfo;
    })();

    msgProto.SvrListGet = (function() {

        /**
         * Properties of a SvrListGet.
         * @memberof msgProto
         * @interface ISvrListGet
         * @property {boolean|null} [isTest] SvrListGet isTest
         */

        /**
         * Constructs a new SvrListGet.
         * @memberof msgProto
         * @classdesc Represents a SvrListGet.
         * @implements ISvrListGet
         * @constructor
         * @param {msgProto.ISvrListGet=} [properties] Properties to set
         */
        function SvrListGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrListGet isTest.
         * @member {boolean} isTest
         * @memberof msgProto.SvrListGet
         * @instance
         */
        SvrListGet.prototype.isTest = false;

        /**
         * Encodes the specified SvrListGet message. Does not implicitly {@link msgProto.SvrListGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrListGet
         * @static
         * @param {msgProto.ISvrListGet} message SvrListGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isTest);
            return writer;
        };

        /**
         * Decodes a SvrListGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrListGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrListGet} SvrListGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrListGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isTest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SvrListGet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SvrListGet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SvrListGet} SvrListGet
         */
        SvrListGet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SvrListGet)
                return object;
            var message = new $root.msgProto.SvrListGet();
            if (object.isTest != null)
                message.isTest = Boolean(object.isTest);
            return message;
        };

        /**
         * Creates a plain object from a SvrListGet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SvrListGet
         * @static
         * @param {msgProto.SvrListGet} message SvrListGet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SvrListGet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isTest = false;
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                object.isTest = message.isTest;
            return object;
        };

        /**
         * Converts this SvrListGet to JSON.
         * @function toJSON
         * @memberof msgProto.SvrListGet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SvrListGet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SvrListGet;
    })();

    msgProto.SvrInfoGet = (function() {

        /**
         * Properties of a SvrInfoGet.
         * @memberof msgProto
         * @interface ISvrInfoGet
         * @property {number|null} [svrId] SvrInfoGet svrId
         */

        /**
         * Constructs a new SvrInfoGet.
         * @memberof msgProto
         * @classdesc Represents a SvrInfoGet.
         * @implements ISvrInfoGet
         * @constructor
         * @param {msgProto.ISvrInfoGet=} [properties] Properties to set
         */
        function SvrInfoGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrInfoGet svrId.
         * @member {number} svrId
         * @memberof msgProto.SvrInfoGet
         * @instance
         */
        SvrInfoGet.prototype.svrId = 0;

        /**
         * Encodes the specified SvrInfoGet message. Does not implicitly {@link msgProto.SvrInfoGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {msgProto.ISvrInfoGet} message SvrInfoGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrInfoGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.svrId != null && message.hasOwnProperty("svrId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.svrId);
            return writer;
        };

        /**
         * Decodes a SvrInfoGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrInfoGet} SvrInfoGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrInfoGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrInfoGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.svrId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SvrInfoGet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SvrInfoGet} SvrInfoGet
         */
        SvrInfoGet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SvrInfoGet)
                return object;
            var message = new $root.msgProto.SvrInfoGet();
            if (object.svrId != null)
                message.svrId = object.svrId | 0;
            return message;
        };

        /**
         * Creates a plain object from a SvrInfoGet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {msgProto.SvrInfoGet} message SvrInfoGet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SvrInfoGet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.svrId = 0;
            if (message.svrId != null && message.hasOwnProperty("svrId"))
                object.svrId = message.svrId;
            return object;
        };

        /**
         * Converts this SvrInfoGet to JSON.
         * @function toJSON
         * @memberof msgProto.SvrInfoGet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SvrInfoGet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SvrInfoGet;
    })();

    msgProto.PbSvrInfo = (function() {

        /**
         * Properties of a PbSvrInfo.
         * @memberof msgProto
         * @interface IPbSvrInfo
         * @property {number|null} [Id] PbSvrInfo Id
         * @property {string|null} [Name] PbSvrInfo Name
         * @property {string|null} [MergerName]  *
         * @property {string|null} [Area] PbSvrInfo Area
         * @property {string|null} [Host] PbSvrInfo Host
         * @property {string|null} [Port] PbSvrInfo Port
         * @property {number|null} [IsNew] PbSvrInfo IsNew
         * @property {number|null} [Status] PbSvrInfo Status
         * @property {number|null} [Sort] PbSvrInfo Sort
         * @property {string|null} [AppId] PbSvrInfo AppId
         * @property {number|null} [ServerId] PbSvrInfo ServerId
         * @property {number|null} [IndexId] PbSvrInfo IndexId
         * @property {number|null} [IsClose] PbSvrInfo IsClose
         * @property {string|null} [CloseExplain]  *
         * @property {number|Long|null} [ServerDate]  *
         */

        /**
         * Constructs a new PbSvrInfo.
         * @memberof msgProto
         * @classdesc Represents a PbSvrInfo.
         * @implements IPbSvrInfo
         * @constructor
         * @param {msgProto.IPbSvrInfo=} [properties] Properties to set
         */
        function PbSvrInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbSvrInfo Id.
         * @member {number} Id
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Id = 0;

        /**
         * PbSvrInfo Name.
         * @member {string} Name
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Name = "";

        /**
         *  *
         * @member {string} MergerName
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.MergerName = "";

        /**
         * PbSvrInfo Area.
         * @member {string} Area
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Area = "";

        /**
         * PbSvrInfo Host.
         * @member {string} Host
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Host = "";

        /**
         * PbSvrInfo Port.
         * @member {string} Port
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Port = "";

        /**
         * PbSvrInfo IsNew.
         * @member {number} IsNew
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IsNew = 0;

        /**
         * PbSvrInfo Status.
         * @member {number} Status
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Status = 0;

        /**
         * PbSvrInfo Sort.
         * @member {number} Sort
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Sort = 0;

        /**
         * PbSvrInfo AppId.
         * @member {string} AppId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.AppId = "";

        /**
         * PbSvrInfo ServerId.
         * @member {number} ServerId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.ServerId = 0;

        /**
         * PbSvrInfo IndexId.
         * @member {number} IndexId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IndexId = 0;

        /**
         * PbSvrInfo IsClose.
         * @member {number} IsClose
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IsClose = 0;

        /**
         *  *
         * @member {string} CloseExplain
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.CloseExplain = "";

        /**
         *  *
         * @member {number|Long} ServerDate
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.ServerDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified PbSvrInfo message. Does not implicitly {@link msgProto.PbSvrInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {msgProto.IPbSvrInfo} message PbSvrInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSvrInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Id != null && message.hasOwnProperty("Id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Id);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
            if (message.MergerName != null && message.hasOwnProperty("MergerName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.MergerName);
            if (message.Area != null && message.hasOwnProperty("Area"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Area);
            if (message.Host != null && message.hasOwnProperty("Host"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Host);
            if (message.Port != null && message.hasOwnProperty("Port"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Port);
            if (message.IsNew != null && message.hasOwnProperty("IsNew"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.IsNew);
            if (message.Status != null && message.hasOwnProperty("Status"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Status);
            if (message.Sort != null && message.hasOwnProperty("Sort"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Sort);
            if (message.AppId != null && message.hasOwnProperty("AppId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.AppId);
            if (message.ServerId != null && message.hasOwnProperty("ServerId"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.ServerId);
            if (message.IndexId != null && message.hasOwnProperty("IndexId"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.IndexId);
            if (message.IsClose != null && message.hasOwnProperty("IsClose"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.IsClose);
            if (message.CloseExplain != null && message.hasOwnProperty("CloseExplain"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.CloseExplain);
            if (message.ServerDate != null && message.hasOwnProperty("ServerDate"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.ServerDate);
            return writer;
        };

        /**
         * Decodes a PbSvrInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PbSvrInfo} PbSvrInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSvrInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PbSvrInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.Id = reader.int32();
                    break;
                case 3:
                    message.Name = reader.string();
                    break;
                case 4:
                    message.MergerName = reader.string();
                    break;
                case 5:
                    message.Area = reader.string();
                    break;
                case 6:
                    message.Host = reader.string();
                    break;
                case 7:
                    message.Port = reader.string();
                    break;
                case 8:
                    message.IsNew = reader.int32();
                    break;
                case 9:
                    message.Status = reader.int32();
                    break;
                case 10:
                    message.Sort = reader.int32();
                    break;
                case 11:
                    message.AppId = reader.string();
                    break;
                case 12:
                    message.ServerId = reader.int32();
                    break;
                case 13:
                    message.IndexId = reader.int32();
                    break;
                case 14:
                    message.IsClose = reader.int32();
                    break;
                case 15:
                    message.CloseExplain = reader.string();
                    break;
                case 16:
                    message.ServerDate = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PbSvrInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PbSvrInfo} PbSvrInfo
         */
        PbSvrInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PbSvrInfo)
                return object;
            var message = new $root.msgProto.PbSvrInfo();
            if (object.Id != null)
                message.Id = object.Id | 0;
            if (object.Name != null)
                message.Name = String(object.Name);
            if (object.MergerName != null)
                message.MergerName = String(object.MergerName);
            if (object.Area != null)
                message.Area = String(object.Area);
            if (object.Host != null)
                message.Host = String(object.Host);
            if (object.Port != null)
                message.Port = String(object.Port);
            if (object.IsNew != null)
                message.IsNew = object.IsNew | 0;
            if (object.Status != null)
                message.Status = object.Status | 0;
            if (object.Sort != null)
                message.Sort = object.Sort | 0;
            if (object.AppId != null)
                message.AppId = String(object.AppId);
            if (object.ServerId != null)
                message.ServerId = object.ServerId | 0;
            if (object.IndexId != null)
                message.IndexId = object.IndexId | 0;
            if (object.IsClose != null)
                message.IsClose = object.IsClose | 0;
            if (object.CloseExplain != null)
                message.CloseExplain = String(object.CloseExplain);
            if (object.ServerDate != null)
                if ($util.Long)
                    (message.ServerDate = $util.Long.fromValue(object.ServerDate)).unsigned = false;
                else if (typeof object.ServerDate === "string")
                    message.ServerDate = parseInt(object.ServerDate, 10);
                else if (typeof object.ServerDate === "number")
                    message.ServerDate = object.ServerDate;
                else if (typeof object.ServerDate === "object")
                    message.ServerDate = new $util.LongBits(object.ServerDate.low >>> 0, object.ServerDate.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PbSvrInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {msgProto.PbSvrInfo} message PbSvrInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PbSvrInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Id = 0;
                object.Name = "";
                object.MergerName = "";
                object.Area = "";
                object.Host = "";
                object.Port = "";
                object.IsNew = 0;
                object.Status = 0;
                object.Sort = 0;
                object.AppId = "";
                object.ServerId = 0;
                object.IndexId = 0;
                object.IsClose = 0;
                object.CloseExplain = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ServerDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ServerDate = options.longs === String ? "0" : 0;
            }
            if (message.Id != null && message.hasOwnProperty("Id"))
                object.Id = message.Id;
            if (message.Name != null && message.hasOwnProperty("Name"))
                object.Name = message.Name;
            if (message.MergerName != null && message.hasOwnProperty("MergerName"))
                object.MergerName = message.MergerName;
            if (message.Area != null && message.hasOwnProperty("Area"))
                object.Area = message.Area;
            if (message.Host != null && message.hasOwnProperty("Host"))
                object.Host = message.Host;
            if (message.Port != null && message.hasOwnProperty("Port"))
                object.Port = message.Port;
            if (message.IsNew != null && message.hasOwnProperty("IsNew"))
                object.IsNew = message.IsNew;
            if (message.Status != null && message.hasOwnProperty("Status"))
                object.Status = message.Status;
            if (message.Sort != null && message.hasOwnProperty("Sort"))
                object.Sort = message.Sort;
            if (message.AppId != null && message.hasOwnProperty("AppId"))
                object.AppId = message.AppId;
            if (message.ServerId != null && message.hasOwnProperty("ServerId"))
                object.ServerId = message.ServerId;
            if (message.IndexId != null && message.hasOwnProperty("IndexId"))
                object.IndexId = message.IndexId;
            if (message.IsClose != null && message.hasOwnProperty("IsClose"))
                object.IsClose = message.IsClose;
            if (message.CloseExplain != null && message.hasOwnProperty("CloseExplain"))
                object.CloseExplain = message.CloseExplain;
            if (message.ServerDate != null && message.hasOwnProperty("ServerDate"))
                if (typeof message.ServerDate === "number")
                    object.ServerDate = options.longs === String ? String(message.ServerDate) : message.ServerDate;
                else
                    object.ServerDate = options.longs === String ? $util.Long.prototype.toString.call(message.ServerDate) : options.longs === Number ? new $util.LongBits(message.ServerDate.low >>> 0, message.ServerDate.high >>> 0).toNumber() : message.ServerDate;
            return object;
        };

        /**
         * Converts this PbSvrInfo to JSON.
         * @function toJSON
         * @memberof msgProto.PbSvrInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PbSvrInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PbSvrInfo;
    })();

    msgProto.SvrListResponse = (function() {

        /**
         * Properties of a SvrListResponse.
         * @memberof msgProto
         * @interface ISvrListResponse
         * @property {number|null} [retCode] SvrListResponse retCode
         * @property {number|null} [retType] SvrListResponse retType
         * @property {Array.<msgProto.IPbSvrInfo>|null} [infos] SvrListResponse infos
         */

        /**
         * Constructs a new SvrListResponse.
         * @memberof msgProto
         * @classdesc Represents a SvrListResponse.
         * @implements ISvrListResponse
         * @constructor
         * @param {msgProto.ISvrListResponse=} [properties] Properties to set
         */
        function SvrListResponse(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrListResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.retCode = 0;

        /**
         * SvrListResponse retType.
         * @member {number} retType
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.retType = 0;

        /**
         * SvrListResponse infos.
         * @member {Array.<msgProto.IPbSvrInfo>} infos
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.infos = $util.emptyArray;

        /**
         * Encodes the specified SvrListResponse message. Does not implicitly {@link msgProto.SvrListResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {msgProto.ISvrListResponse} message SvrListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.retType != null && message.hasOwnProperty("retType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.retType);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.msgProto.PbSvrInfo.encode(message.infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SvrListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrListResponse} SvrListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.retType = reader.int32();
                    break;
                case 3:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.msgProto.PbSvrInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SvrListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SvrListResponse} SvrListResponse
         */
        SvrListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SvrListResponse)
                return object;
            var message = new $root.msgProto.SvrListResponse();
            if (object.retCode != null)
                message.retCode = object.retCode | 0;
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".msgProto.SvrListResponse.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".msgProto.SvrListResponse.infos: object expected");
                    message.infos[i] = $root.msgProto.PbSvrInfo.fromObject(object.infos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SvrListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {msgProto.SvrListResponse} message SvrListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SvrListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.retCode = 0;
                object.retType = 0;
            }
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                object.retCode = message.retCode;
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.msgProto.PbSvrInfo.toObject(message.infos[j], options);
            }
            return object;
        };

        /**
         * Converts this SvrListResponse to JSON.
         * @function toJSON
         * @memberof msgProto.SvrListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SvrListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SvrListResponse;
    })();

    msgProto.SvrDateGet = (function() {

        /**
         * Properties of a SvrDateGet.
         * @memberof msgProto
         * @interface ISvrDateGet
         */

        /**
         * Constructs a new SvrDateGet.
         * @memberof msgProto
         * @classdesc Represents a SvrDateGet.
         * @implements ISvrDateGet
         * @constructor
         * @param {msgProto.ISvrDateGet=} [properties] Properties to set
         */
        function SvrDateGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified SvrDateGet message. Does not implicitly {@link msgProto.SvrDateGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {msgProto.ISvrDateGet} message SvrDateGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrDateGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a SvrDateGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrDateGet} SvrDateGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrDateGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrDateGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a SvrDateGet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.SvrDateGet} SvrDateGet
         */
        SvrDateGet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.SvrDateGet)
                return object;
            return new $root.msgProto.SvrDateGet();
        };

        /**
         * Creates a plain object from a SvrDateGet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {msgProto.SvrDateGet} message SvrDateGet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SvrDateGet.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SvrDateGet to JSON.
         * @function toJSON
         * @memberof msgProto.SvrDateGet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SvrDateGet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SvrDateGet;
    })();

    msgProto.UserSvrsGet = (function() {

        /**
         * Properties of a UserSvrsGet.
         * @memberof msgProto
         * @interface IUserSvrsGet
         * @property {number|Long|null} [accId] UserSvrsGet accId
         */

        /**
         * Constructs a new UserSvrsGet.
         * @memberof msgProto
         * @classdesc Represents a UserSvrsGet.
         * @implements IUserSvrsGet
         * @constructor
         * @param {msgProto.IUserSvrsGet=} [properties] Properties to set
         */
        function UserSvrsGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSvrsGet accId.
         * @member {number|Long} accId
         * @memberof msgProto.UserSvrsGet
         * @instance
         */
        UserSvrsGet.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified UserSvrsGet message. Does not implicitly {@link msgProto.UserSvrsGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {msgProto.IUserSvrsGet} message UserSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSvrsGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.accId);
            return writer;
        };

        /**
         * Decodes a UserSvrsGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSvrsGet} UserSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSvrsGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSvrsGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a UserSvrsGet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.UserSvrsGet} UserSvrsGet
         */
        UserSvrsGet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.UserSvrsGet)
                return object;
            var message = new $root.msgProto.UserSvrsGet();
            if (object.accId != null)
                if ($util.Long)
                    (message.accId = $util.Long.fromValue(object.accId)).unsigned = false;
                else if (typeof object.accId === "string")
                    message.accId = parseInt(object.accId, 10);
                else if (typeof object.accId === "number")
                    message.accId = object.accId;
                else if (typeof object.accId === "object")
                    message.accId = new $util.LongBits(object.accId.low >>> 0, object.accId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserSvrsGet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {msgProto.UserSvrsGet} message UserSvrsGet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSvrsGet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accId = options.longs === String ? "0" : 0;
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (typeof message.accId === "number")
                    object.accId = options.longs === String ? String(message.accId) : message.accId;
                else
                    object.accId = options.longs === String ? $util.Long.prototype.toString.call(message.accId) : options.longs === Number ? new $util.LongBits(message.accId.low >>> 0, message.accId.high >>> 0).toNumber() : message.accId;
            return object;
        };

        /**
         * Converts this UserSvrsGet to JSON.
         * @function toJSON
         * @memberof msgProto.UserSvrsGet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSvrsGet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSvrsGet;
    })();

    msgProto.AccountSvrsGet = (function() {

        /**
         * Properties of an AccountSvrsGet.
         * @memberof msgProto
         * @interface IAccountSvrsGet
         * @property {string|null} [openId] AccountSvrsGet openId
         * @property {string|null} [appId] AccountSvrsGet appId
         * @property {boolean|null} [isTest] AccountSvrsGet isTest
         */

        /**
         * Constructs a new AccountSvrsGet.
         * @memberof msgProto
         * @classdesc Represents an AccountSvrsGet.
         * @implements IAccountSvrsGet
         * @constructor
         * @param {msgProto.IAccountSvrsGet=} [properties] Properties to set
         */
        function AccountSvrsGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSvrsGet openId.
         * @member {string} openId
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.openId = "";

        /**
         * AccountSvrsGet appId.
         * @member {string} appId
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.appId = "";

        /**
         * AccountSvrsGet isTest.
         * @member {boolean} isTest
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.isTest = false;

        /**
         * Encodes the specified AccountSvrsGet message. Does not implicitly {@link msgProto.AccountSvrsGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {msgProto.IAccountSvrsGet} message AccountSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSvrsGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.openId);
            if (message.appId != null && message.hasOwnProperty("appId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.appId);
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isTest);
            return writer;
        };

        /**
         * Decodes an AccountSvrsGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountSvrsGet} AccountSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSvrsGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountSvrsGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.openId = reader.string();
                    break;
                case 2:
                    message.appId = reader.string();
                    break;
                case 3:
                    message.isTest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AccountSvrsGet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AccountSvrsGet} AccountSvrsGet
         */
        AccountSvrsGet.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AccountSvrsGet)
                return object;
            var message = new $root.msgProto.AccountSvrsGet();
            if (object.openId != null)
                message.openId = String(object.openId);
            if (object.appId != null)
                message.appId = String(object.appId);
            if (object.isTest != null)
                message.isTest = Boolean(object.isTest);
            return message;
        };

        /**
         * Creates a plain object from an AccountSvrsGet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {msgProto.AccountSvrsGet} message AccountSvrsGet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSvrsGet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.openId = "";
                object.appId = "";
                object.isTest = false;
            }
            if (message.openId != null && message.hasOwnProperty("openId"))
                object.openId = message.openId;
            if (message.appId != null && message.hasOwnProperty("appId"))
                object.appId = message.appId;
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                object.isTest = message.isTest;
            return object;
        };

        /**
         * Converts this AccountSvrsGet to JSON.
         * @function toJSON
         * @memberof msgProto.AccountSvrsGet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSvrsGet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountSvrsGet;
    })();

    msgProto.KefuGetList = (function() {

        /**
         * Properties of a KefuGetList.
         * @memberof msgProto
         * @interface IKefuGetList
         * @property {number|null} [lastId] KefuGetList lastId
         * @property {string|null} [openId] KefuGetList openId
         */

        /**
         * Constructs a new KefuGetList.
         * @memberof msgProto
         * @classdesc Represents a KefuGetList.
         * @implements IKefuGetList
         * @constructor
         * @param {msgProto.IKefuGetList=} [properties] Properties to set
         */
        function KefuGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KefuGetList lastId.
         * @member {number} lastId
         * @memberof msgProto.KefuGetList
         * @instance
         */
        KefuGetList.prototype.lastId = 0;

        /**
         * KefuGetList openId.
         * @member {string} openId
         * @memberof msgProto.KefuGetList
         * @instance
         */
        KefuGetList.prototype.openId = "";

        /**
         * Encodes the specified KefuGetList message. Does not implicitly {@link msgProto.KefuGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KefuGetList
         * @static
         * @param {msgProto.IKefuGetList} message KefuGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.openId);
            return writer;
        };

        /**
         * Decodes a KefuGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KefuGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KefuGetList} KefuGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KefuGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.openId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KefuGetList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KefuGetList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KefuGetList} KefuGetList
         */
        KefuGetList.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KefuGetList)
                return object;
            var message = new $root.msgProto.KefuGetList();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            if (object.openId != null)
                message.openId = String(object.openId);
            return message;
        };

        /**
         * Creates a plain object from a KefuGetList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KefuGetList
         * @static
         * @param {msgProto.KefuGetList} message KefuGetList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KefuGetList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastId = 0;
                object.openId = "";
            }
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            if (message.openId != null && message.hasOwnProperty("openId"))
                object.openId = message.openId;
            return object;
        };

        /**
         * Converts this KefuGetList to JSON.
         * @function toJSON
         * @memberof msgProto.KefuGetList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KefuGetList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KefuGetList;
    })();

    msgProto.KefuSendData = (function() {

        /**
         * Properties of a KefuSendData.
         * @memberof msgProto
         * @interface IKefuSendData
         * @property {number|null} [lastId] KefuSendData lastId
         * @property {string|null} [content] KefuSendData content
         * @property {string|null} [openId] KefuSendData openId
         * @property {string|null} [nickname] KefuSendData nickname
         * @property {number|null} [vipLevel] KefuSendData vipLevel
         */

        /**
         * Constructs a new KefuSendData.
         * @memberof msgProto
         * @classdesc Represents a KefuSendData.
         * @implements IKefuSendData
         * @constructor
         * @param {msgProto.IKefuSendData=} [properties] Properties to set
         */
        function KefuSendData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KefuSendData lastId.
         * @member {number} lastId
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.lastId = 0;

        /**
         * KefuSendData content.
         * @member {string} content
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.content = "";

        /**
         * KefuSendData openId.
         * @member {string} openId
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.openId = "";

        /**
         * KefuSendData nickname.
         * @member {string} nickname
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.nickname = "";

        /**
         * KefuSendData vipLevel.
         * @member {number} vipLevel
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.vipLevel = 0;

        /**
         * Encodes the specified KefuSendData message. Does not implicitly {@link msgProto.KefuSendData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KefuSendData
         * @static
         * @param {msgProto.IKefuSendData} message KefuSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuSendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.openId);
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nickname);
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.vipLevel);
            return writer;
        };

        /**
         * Decodes a KefuSendData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KefuSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KefuSendData} KefuSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuSendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KefuSendData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                case 3:
                    message.openId = reader.string();
                    break;
                case 4:
                    message.nickname = reader.string();
                    break;
                case 5:
                    message.vipLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a KefuSendData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.KefuSendData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.KefuSendData} KefuSendData
         */
        KefuSendData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.KefuSendData)
                return object;
            var message = new $root.msgProto.KefuSendData();
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            if (object.content != null)
                message.content = String(object.content);
            if (object.openId != null)
                message.openId = String(object.openId);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.vipLevel != null)
                message.vipLevel = object.vipLevel | 0;
            return message;
        };

        /**
         * Creates a plain object from a KefuSendData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.KefuSendData
         * @static
         * @param {msgProto.KefuSendData} message KefuSendData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KefuSendData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastId = 0;
                object.content = "";
                object.openId = "";
                object.nickname = "";
                object.vipLevel = 0;
            }
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.openId != null && message.hasOwnProperty("openId"))
                object.openId = message.openId;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                object.vipLevel = message.vipLevel;
            return object;
        };

        /**
         * Converts this KefuSendData to JSON.
         * @function toJSON
         * @memberof msgProto.KefuSendData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KefuSendData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KefuSendData;
    })();

    msgProto.AdminCoffersLootDefense = (function() {

        /**
         * Properties of an AdminCoffersLootDefense.
         * @memberof msgProto
         * @interface IAdminCoffersLootDefense
         * @property {string|null} [attackData] AdminCoffersLootDefense attackData
         * @property {number|null} [door] AdminCoffersLootDefense door
         */

        /**
         * Constructs a new AdminCoffersLootDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersLootDefense.
         * @implements IAdminCoffersLootDefense
         * @constructor
         * @param {msgProto.IAdminCoffersLootDefense=} [properties] Properties to set
         */
        function AdminCoffersLootDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersLootDefense attackData.
         * @member {string} attackData
         * @memberof msgProto.AdminCoffersLootDefense
         * @instance
         */
        AdminCoffersLootDefense.prototype.attackData = "";

        /**
         * AdminCoffersLootDefense door.
         * @member {number} door
         * @memberof msgProto.AdminCoffersLootDefense
         * @instance
         */
        AdminCoffersLootDefense.prototype.door = 0;

        /**
         * Encodes the specified AdminCoffersLootDefense message. Does not implicitly {@link msgProto.AdminCoffersLootDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {msgProto.IAdminCoffersLootDefense} message AdminCoffersLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.attackData);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            return writer;
        };

        /**
         * Decodes an AdminCoffersLootDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersLootDefense} AdminCoffersLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersLootDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attackData = reader.string();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminCoffersLootDefense message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminCoffersLootDefense} AdminCoffersLootDefense
         */
        AdminCoffersLootDefense.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminCoffersLootDefense)
                return object;
            var message = new $root.msgProto.AdminCoffersLootDefense();
            if (object.attackData != null)
                message.attackData = String(object.attackData);
            if (object.door != null)
                message.door = object.door | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminCoffersLootDefense message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {msgProto.AdminCoffersLootDefense} message AdminCoffersLootDefense
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminCoffersLootDefense.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attackData = "";
                object.door = 0;
            }
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                object.attackData = message.attackData;
            if (message.door != null && message.hasOwnProperty("door"))
                object.door = message.door;
            return object;
        };

        /**
         * Converts this AdminCoffersLootDefense to JSON.
         * @function toJSON
         * @memberof msgProto.AdminCoffersLootDefense
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminCoffersLootDefense.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminCoffersLootDefense;
    })();

    msgProto.AdminCoffersLootCoffersDefense = (function() {

        /**
         * Properties of an AdminCoffersLootCoffersDefense.
         * @memberof msgProto
         * @interface IAdminCoffersLootCoffersDefense
         * @property {number|null} [hurt] AdminCoffersLootCoffersDefense hurt
         * @property {number|null} [breakNum] AdminCoffersLootCoffersDefense breakNum
         */

        /**
         * Constructs a new AdminCoffersLootCoffersDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersLootCoffersDefense.
         * @implements IAdminCoffersLootCoffersDefense
         * @constructor
         * @param {msgProto.IAdminCoffersLootCoffersDefense=} [properties] Properties to set
         */
        function AdminCoffersLootCoffersDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersLootCoffersDefense hurt.
         * @member {number} hurt
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @instance
         */
        AdminCoffersLootCoffersDefense.prototype.hurt = 0;

        /**
         * AdminCoffersLootCoffersDefense breakNum.
         * @member {number} breakNum
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @instance
         */
        AdminCoffersLootCoffersDefense.prototype.breakNum = 0;

        /**
         * Encodes the specified AdminCoffersLootCoffersDefense message. Does not implicitly {@link msgProto.AdminCoffersLootCoffersDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {msgProto.IAdminCoffersLootCoffersDefense} message AdminCoffersLootCoffersDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootCoffersDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hurt);
            if (message.breakNum != null && message.hasOwnProperty("breakNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakNum);
            return writer;
        };

        /**
         * Decodes an AdminCoffersLootCoffersDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersLootCoffersDefense} AdminCoffersLootCoffersDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootCoffersDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersLootCoffersDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hurt = reader.int32();
                    break;
                case 2:
                    message.breakNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminCoffersLootCoffersDefense message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminCoffersLootCoffersDefense} AdminCoffersLootCoffersDefense
         */
        AdminCoffersLootCoffersDefense.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminCoffersLootCoffersDefense)
                return object;
            var message = new $root.msgProto.AdminCoffersLootCoffersDefense();
            if (object.hurt != null)
                message.hurt = object.hurt | 0;
            if (object.breakNum != null)
                message.breakNum = object.breakNum | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminCoffersLootCoffersDefense message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {msgProto.AdminCoffersLootCoffersDefense} message AdminCoffersLootCoffersDefense
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminCoffersLootCoffersDefense.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hurt = 0;
                object.breakNum = 0;
            }
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                object.hurt = message.hurt;
            if (message.breakNum != null && message.hasOwnProperty("breakNum"))
                object.breakNum = message.breakNum;
            return object;
        };

        /**
         * Converts this AdminCoffersLootCoffersDefense to JSON.
         * @function toJSON
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminCoffersLootCoffersDefense.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminCoffersLootCoffersDefense;
    })();

    msgProto.AdminCoffersGetCache = (function() {

        /**
         * Properties of an AdminCoffersGetCache.
         * @memberof msgProto
         * @interface IAdminCoffersGetCache
         */

        /**
         * Constructs a new AdminCoffersGetCache.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersGetCache.
         * @implements IAdminCoffersGetCache
         * @constructor
         * @param {msgProto.IAdminCoffersGetCache=} [properties] Properties to set
         */
        function AdminCoffersGetCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminCoffersGetCache message. Does not implicitly {@link msgProto.AdminCoffersGetCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {msgProto.IAdminCoffersGetCache} message AdminCoffersGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersGetCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminCoffersGetCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersGetCache} AdminCoffersGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersGetCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersGetCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminCoffersGetCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminCoffersGetCache} AdminCoffersGetCache
         */
        AdminCoffersGetCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminCoffersGetCache)
                return object;
            return new $root.msgProto.AdminCoffersGetCache();
        };

        /**
         * Creates a plain object from an AdminCoffersGetCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {msgProto.AdminCoffersGetCache} message AdminCoffersGetCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminCoffersGetCache.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminCoffersGetCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminCoffersGetCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminCoffersGetCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminCoffersGetCache;
    })();

    msgProto.AdminCoffersResetPoints = (function() {

        /**
         * Properties of an AdminCoffersResetPoints.
         * @memberof msgProto
         * @interface IAdminCoffersResetPoints
         */

        /**
         * Constructs a new AdminCoffersResetPoints.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersResetPoints.
         * @implements IAdminCoffersResetPoints
         * @constructor
         * @param {msgProto.IAdminCoffersResetPoints=} [properties] Properties to set
         */
        function AdminCoffersResetPoints(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminCoffersResetPoints message. Does not implicitly {@link msgProto.AdminCoffersResetPoints.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {msgProto.IAdminCoffersResetPoints} message AdminCoffersResetPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersResetPoints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminCoffersResetPoints message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersResetPoints} AdminCoffersResetPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersResetPoints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersResetPoints();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminCoffersResetPoints message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminCoffersResetPoints} AdminCoffersResetPoints
         */
        AdminCoffersResetPoints.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminCoffersResetPoints)
                return object;
            return new $root.msgProto.AdminCoffersResetPoints();
        };

        /**
         * Creates a plain object from an AdminCoffersResetPoints message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {msgProto.AdminCoffersResetPoints} message AdminCoffersResetPoints
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminCoffersResetPoints.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminCoffersResetPoints to JSON.
         * @function toJSON
         * @memberof msgProto.AdminCoffersResetPoints
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminCoffersResetPoints.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminCoffersResetPoints;
    })();

    msgProto.AdminCoffersUpdateCache = (function() {

        /**
         * Properties of an AdminCoffersUpdateCache.
         * @memberof msgProto
         * @interface IAdminCoffersUpdateCache
         * @property {string|null} [data] AdminCoffersUpdateCache data
         */

        /**
         * Constructs a new AdminCoffersUpdateCache.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersUpdateCache.
         * @implements IAdminCoffersUpdateCache
         * @constructor
         * @param {msgProto.IAdminCoffersUpdateCache=} [properties] Properties to set
         */
        function AdminCoffersUpdateCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersUpdateCache data.
         * @member {string} data
         * @memberof msgProto.AdminCoffersUpdateCache
         * @instance
         */
        AdminCoffersUpdateCache.prototype.data = "";

        /**
         * Encodes the specified AdminCoffersUpdateCache message. Does not implicitly {@link msgProto.AdminCoffersUpdateCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {msgProto.IAdminCoffersUpdateCache} message AdminCoffersUpdateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersUpdateCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Decodes an AdminCoffersUpdateCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersUpdateCache} AdminCoffersUpdateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersUpdateCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersUpdateCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminCoffersUpdateCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminCoffersUpdateCache} AdminCoffersUpdateCache
         */
        AdminCoffersUpdateCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminCoffersUpdateCache)
                return object;
            var message = new $root.msgProto.AdminCoffersUpdateCache();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an AdminCoffersUpdateCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {msgProto.AdminCoffersUpdateCache} message AdminCoffersUpdateCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminCoffersUpdateCache.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.data = "";
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this AdminCoffersUpdateCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminCoffersUpdateCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminCoffersUpdateCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminCoffersUpdateCache;
    })();

    msgProto.AdminGuildGetCache = (function() {

        /**
         * Properties of an AdminGuildGetCache.
         * @memberof msgProto
         * @interface IAdminGuildGetCache
         */

        /**
         * Constructs a new AdminGuildGetCache.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetCache.
         * @implements IAdminGuildGetCache
         * @constructor
         * @param {msgProto.IAdminGuildGetCache=} [properties] Properties to set
         */
        function AdminGuildGetCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminGuildGetCache message. Does not implicitly {@link msgProto.AdminGuildGetCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {msgProto.IAdminGuildGetCache} message AdminGuildGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminGuildGetCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetCache} AdminGuildGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildGetCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildGetCache} AdminGuildGetCache
         */
        AdminGuildGetCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildGetCache)
                return object;
            return new $root.msgProto.AdminGuildGetCache();
        };

        /**
         * Creates a plain object from an AdminGuildGetCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {msgProto.AdminGuildGetCache} message AdminGuildGetCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildGetCache.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminGuildGetCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildGetCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildGetCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildGetCache;
    })();

    msgProto.AdminGuildGetGuildById = (function() {

        /**
         * Properties of an AdminGuildGetGuildById.
         * @memberof msgProto
         * @interface IAdminGuildGetGuildById
         * @property {number|null} [id] AdminGuildGetGuildById id
         */

        /**
         * Constructs a new AdminGuildGetGuildById.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetGuildById.
         * @implements IAdminGuildGetGuildById
         * @constructor
         * @param {msgProto.IAdminGuildGetGuildById=} [properties] Properties to set
         */
        function AdminGuildGetGuildById(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildGetGuildById id.
         * @member {number} id
         * @memberof msgProto.AdminGuildGetGuildById
         * @instance
         */
        AdminGuildGetGuildById.prototype.id = 0;

        /**
         * Encodes the specified AdminGuildGetGuildById message. Does not implicitly {@link msgProto.AdminGuildGetGuildById.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {msgProto.IAdminGuildGetGuildById} message AdminGuildGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetGuildById.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Decodes an AdminGuildGetGuildById message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetGuildById} AdminGuildGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetGuildById.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetGuildById();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildGetGuildById message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildGetGuildById} AdminGuildGetGuildById
         */
        AdminGuildGetGuildById.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildGetGuildById)
                return object;
            var message = new $root.msgProto.AdminGuildGetGuildById();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminGuildGetGuildById message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {msgProto.AdminGuildGetGuildById} message AdminGuildGetGuildById
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildGetGuildById.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this AdminGuildGetGuildById to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildGetGuildById
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildGetGuildById.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildGetGuildById;
    })();

    msgProto.Admin_guild_updateCache = (function() {

        /**
         * Properties of an Admin_guild_updateCache.
         * @memberof msgProto
         * @interface IAdmin_guild_updateCache
         * @property {number|null} [id] Admin_guild_updateCache id
         * @property {string|null} [data] Admin_guild_updateCache data
         */

        /**
         * Constructs a new Admin_guild_updateCache.
         * @memberof msgProto
         * @classdesc Represents an Admin_guild_updateCache.
         * @implements IAdmin_guild_updateCache
         * @constructor
         * @param {msgProto.IAdmin_guild_updateCache=} [properties] Properties to set
         */
        function Admin_guild_updateCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Admin_guild_updateCache id.
         * @member {number} id
         * @memberof msgProto.Admin_guild_updateCache
         * @instance
         */
        Admin_guild_updateCache.prototype.id = 0;

        /**
         * Admin_guild_updateCache data.
         * @member {string} data
         * @memberof msgProto.Admin_guild_updateCache
         * @instance
         */
        Admin_guild_updateCache.prototype.data = "";

        /**
         * Encodes the specified Admin_guild_updateCache message. Does not implicitly {@link msgProto.Admin_guild_updateCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {msgProto.IAdmin_guild_updateCache} message Admin_guild_updateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Admin_guild_updateCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Decodes an Admin_guild_updateCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Admin_guild_updateCache} Admin_guild_updateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Admin_guild_updateCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Admin_guild_updateCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an Admin_guild_updateCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.Admin_guild_updateCache} Admin_guild_updateCache
         */
        Admin_guild_updateCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.Admin_guild_updateCache)
                return object;
            var message = new $root.msgProto.Admin_guild_updateCache();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an Admin_guild_updateCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {msgProto.Admin_guild_updateCache} message Admin_guild_updateCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Admin_guild_updateCache.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.data = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this Admin_guild_updateCache to JSON.
         * @function toJSON
         * @memberof msgProto.Admin_guild_updateCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Admin_guild_updateCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Admin_guild_updateCache;
    })();

    msgProto.AdminGuildGetZombieGuild = (function() {

        /**
         * Properties of an AdminGuildGetZombieGuild.
         * @memberof msgProto
         * @interface IAdminGuildGetZombieGuild
         */

        /**
         * Constructs a new AdminGuildGetZombieGuild.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetZombieGuild.
         * @implements IAdminGuildGetZombieGuild
         * @constructor
         * @param {msgProto.IAdminGuildGetZombieGuild=} [properties] Properties to set
         */
        function AdminGuildGetZombieGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminGuildGetZombieGuild message. Does not implicitly {@link msgProto.AdminGuildGetZombieGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {msgProto.IAdminGuildGetZombieGuild} message AdminGuildGetZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetZombieGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminGuildGetZombieGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetZombieGuild} AdminGuildGetZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetZombieGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetZombieGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildGetZombieGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildGetZombieGuild} AdminGuildGetZombieGuild
         */
        AdminGuildGetZombieGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildGetZombieGuild)
                return object;
            return new $root.msgProto.AdminGuildGetZombieGuild();
        };

        /**
         * Creates a plain object from an AdminGuildGetZombieGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {msgProto.AdminGuildGetZombieGuild} message AdminGuildGetZombieGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildGetZombieGuild.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminGuildGetZombieGuild to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildGetZombieGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildGetZombieGuild;
    })();

    msgProto.AdminGuildClearZombieGuild = (function() {

        /**
         * Properties of an AdminGuildClearZombieGuild.
         * @memberof msgProto
         * @interface IAdminGuildClearZombieGuild
         * @property {number|null} [id] AdminGuildClearZombieGuild id
         * @property {string|null} [data] AdminGuildClearZombieGuild data
         */

        /**
         * Constructs a new AdminGuildClearZombieGuild.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildClearZombieGuild.
         * @implements IAdminGuildClearZombieGuild
         * @constructor
         * @param {msgProto.IAdminGuildClearZombieGuild=} [properties] Properties to set
         */
        function AdminGuildClearZombieGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildClearZombieGuild id.
         * @member {number} id
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @instance
         */
        AdminGuildClearZombieGuild.prototype.id = 0;

        /**
         * AdminGuildClearZombieGuild data.
         * @member {string} data
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @instance
         */
        AdminGuildClearZombieGuild.prototype.data = "";

        /**
         * Encodes the specified AdminGuildClearZombieGuild message. Does not implicitly {@link msgProto.AdminGuildClearZombieGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {msgProto.IAdminGuildClearZombieGuild} message AdminGuildClearZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildClearZombieGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Decodes an AdminGuildClearZombieGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildClearZombieGuild} AdminGuildClearZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildClearZombieGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildClearZombieGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildClearZombieGuild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildClearZombieGuild} AdminGuildClearZombieGuild
         */
        AdminGuildClearZombieGuild.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildClearZombieGuild)
                return object;
            var message = new $root.msgProto.AdminGuildClearZombieGuild();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an AdminGuildClearZombieGuild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {msgProto.AdminGuildClearZombieGuild} message AdminGuildClearZombieGuild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildClearZombieGuild.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.data = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this AdminGuildClearZombieGuild to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildClearZombieGuild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildClearZombieGuild;
    })();

    msgProto.AdminGuildChairmanImpeach = (function() {

        /**
         * Properties of an AdminGuildChairmanImpeach.
         * @memberof msgProto
         * @interface IAdminGuildChairmanImpeach
         */

        /**
         * Constructs a new AdminGuildChairmanImpeach.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildChairmanImpeach.
         * @implements IAdminGuildChairmanImpeach
         * @constructor
         * @param {msgProto.IAdminGuildChairmanImpeach=} [properties] Properties to set
         */
        function AdminGuildChairmanImpeach(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminGuildChairmanImpeach message. Does not implicitly {@link msgProto.AdminGuildChairmanImpeach.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {msgProto.IAdminGuildChairmanImpeach} message AdminGuildChairmanImpeach message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildChairmanImpeach.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminGuildChairmanImpeach message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildChairmanImpeach} AdminGuildChairmanImpeach
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildChairmanImpeach.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildChairmanImpeach();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildChairmanImpeach message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildChairmanImpeach} AdminGuildChairmanImpeach
         */
        AdminGuildChairmanImpeach.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildChairmanImpeach)
                return object;
            return new $root.msgProto.AdminGuildChairmanImpeach();
        };

        /**
         * Creates a plain object from an AdminGuildChairmanImpeach message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {msgProto.AdminGuildChairmanImpeach} message AdminGuildChairmanImpeach
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildChairmanImpeach.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminGuildChairmanImpeach to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildChairmanImpeach.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildChairmanImpeach;
    })();

    msgProto.AdminBossGetBossData = (function() {

        /**
         * Properties of an AdminBossGetBossData.
         * @memberof msgProto
         * @interface IAdminBossGetBossData
         * @property {number|null} [bossId] AdminBossGetBossData bossId
         */

        /**
         * Constructs a new AdminBossGetBossData.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetBossData.
         * @implements IAdminBossGetBossData
         * @constructor
         * @param {msgProto.IAdminBossGetBossData=} [properties] Properties to set
         */
        function AdminBossGetBossData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetBossData bossId.
         * @member {number} bossId
         * @memberof msgProto.AdminBossGetBossData
         * @instance
         */
        AdminBossGetBossData.prototype.bossId = 0;

        /**
         * Encodes the specified AdminBossGetBossData message. Does not implicitly {@link msgProto.AdminBossGetBossData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {msgProto.IAdminBossGetBossData} message AdminBossGetBossData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetBossData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes an AdminBossGetBossData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetBossData} AdminBossGetBossData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetBossData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetBossData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminBossGetBossData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminBossGetBossData} AdminBossGetBossData
         */
        AdminBossGetBossData.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminBossGetBossData)
                return object;
            var message = new $root.msgProto.AdminBossGetBossData();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminBossGetBossData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {msgProto.AdminBossGetBossData} message AdminBossGetBossData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminBossGetBossData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this AdminBossGetBossData to JSON.
         * @function toJSON
         * @memberof msgProto.AdminBossGetBossData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminBossGetBossData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminBossGetBossData;
    })();

    msgProto.AdminBossGetUserCache = (function() {

        /**
         * Properties of an AdminBossGetUserCache.
         * @memberof msgProto
         * @interface IAdminBossGetUserCache
         * @property {number|null} [bossId] AdminBossGetUserCache bossId
         */

        /**
         * Constructs a new AdminBossGetUserCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetUserCache.
         * @implements IAdminBossGetUserCache
         * @constructor
         * @param {msgProto.IAdminBossGetUserCache=} [properties] Properties to set
         */
        function AdminBossGetUserCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetUserCache bossId.
         * @member {number} bossId
         * @memberof msgProto.AdminBossGetUserCache
         * @instance
         */
        AdminBossGetUserCache.prototype.bossId = 0;

        /**
         * Encodes the specified AdminBossGetUserCache message. Does not implicitly {@link msgProto.AdminBossGetUserCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {msgProto.IAdminBossGetUserCache} message AdminBossGetUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetUserCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Decodes an AdminBossGetUserCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetUserCache} AdminBossGetUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetUserCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetUserCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminBossGetUserCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminBossGetUserCache} AdminBossGetUserCache
         */
        AdminBossGetUserCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminBossGetUserCache)
                return object;
            var message = new $root.msgProto.AdminBossGetUserCache();
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminBossGetUserCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {msgProto.AdminBossGetUserCache} message AdminBossGetUserCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminBossGetUserCache.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bossId = 0;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            return object;
        };

        /**
         * Converts this AdminBossGetUserCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminBossGetUserCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminBossGetUserCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminBossGetUserCache;
    })();

    msgProto.AdminBossGetGuildById = (function() {

        /**
         * Properties of an AdminBossGetGuildById.
         * @memberof msgProto
         * @interface IAdminBossGetGuildById
         * @property {number|null} [id] AdminBossGetGuildById id
         */

        /**
         * Constructs a new AdminBossGetGuildById.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetGuildById.
         * @implements IAdminBossGetGuildById
         * @constructor
         * @param {msgProto.IAdminBossGetGuildById=} [properties] Properties to set
         */
        function AdminBossGetGuildById(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetGuildById id.
         * @member {number} id
         * @memberof msgProto.AdminBossGetGuildById
         * @instance
         */
        AdminBossGetGuildById.prototype.id = 0;

        /**
         * Encodes the specified AdminBossGetGuildById message. Does not implicitly {@link msgProto.AdminBossGetGuildById.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {msgProto.IAdminBossGetGuildById} message AdminBossGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetGuildById.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Decodes an AdminBossGetGuildById message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetGuildById} AdminBossGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetGuildById.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetGuildById();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminBossGetGuildById message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminBossGetGuildById} AdminBossGetGuildById
         */
        AdminBossGetGuildById.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminBossGetGuildById)
                return object;
            var message = new $root.msgProto.AdminBossGetGuildById();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from an AdminBossGetGuildById message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {msgProto.AdminBossGetGuildById} message AdminBossGetGuildById
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminBossGetGuildById.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this AdminBossGetGuildById to JSON.
         * @function toJSON
         * @memberof msgProto.AdminBossGetGuildById
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminBossGetGuildById.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminBossGetGuildById;
    })();

    msgProto.AdminBossUpdateBossCache = (function() {

        /**
         * Properties of an AdminBossUpdateBossCache.
         * @memberof msgProto
         * @interface IAdminBossUpdateBossCache
         * @property {string|null} [data] AdminBossUpdateBossCache data
         */

        /**
         * Constructs a new AdminBossUpdateBossCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossUpdateBossCache.
         * @implements IAdminBossUpdateBossCache
         * @constructor
         * @param {msgProto.IAdminBossUpdateBossCache=} [properties] Properties to set
         */
        function AdminBossUpdateBossCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossUpdateBossCache data.
         * @member {string} data
         * @memberof msgProto.AdminBossUpdateBossCache
         * @instance
         */
        AdminBossUpdateBossCache.prototype.data = "";

        /**
         * Encodes the specified AdminBossUpdateBossCache message. Does not implicitly {@link msgProto.AdminBossUpdateBossCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {msgProto.IAdminBossUpdateBossCache} message AdminBossUpdateBossCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateBossCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Decodes an AdminBossUpdateBossCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossUpdateBossCache} AdminBossUpdateBossCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateBossCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossUpdateBossCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminBossUpdateBossCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminBossUpdateBossCache} AdminBossUpdateBossCache
         */
        AdminBossUpdateBossCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminBossUpdateBossCache)
                return object;
            var message = new $root.msgProto.AdminBossUpdateBossCache();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an AdminBossUpdateBossCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {msgProto.AdminBossUpdateBossCache} message AdminBossUpdateBossCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminBossUpdateBossCache.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.data = "";
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this AdminBossUpdateBossCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminBossUpdateBossCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminBossUpdateBossCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminBossUpdateBossCache;
    })();

    msgProto.AdminBossUpdateUserCache = (function() {

        /**
         * Properties of an AdminBossUpdateUserCache.
         * @memberof msgProto
         * @interface IAdminBossUpdateUserCache
         * @property {number|null} [id] AdminBossUpdateUserCache id
         * @property {string|null} [data] AdminBossUpdateUserCache data
         */

        /**
         * Constructs a new AdminBossUpdateUserCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossUpdateUserCache.
         * @implements IAdminBossUpdateUserCache
         * @constructor
         * @param {msgProto.IAdminBossUpdateUserCache=} [properties] Properties to set
         */
        function AdminBossUpdateUserCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossUpdateUserCache id.
         * @member {number} id
         * @memberof msgProto.AdminBossUpdateUserCache
         * @instance
         */
        AdminBossUpdateUserCache.prototype.id = 0;

        /**
         * AdminBossUpdateUserCache data.
         * @member {string} data
         * @memberof msgProto.AdminBossUpdateUserCache
         * @instance
         */
        AdminBossUpdateUserCache.prototype.data = "";

        /**
         * Encodes the specified AdminBossUpdateUserCache message. Does not implicitly {@link msgProto.AdminBossUpdateUserCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {msgProto.IAdminBossUpdateUserCache} message AdminBossUpdateUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateUserCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Decodes an AdminBossUpdateUserCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossUpdateUserCache} AdminBossUpdateUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateUserCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossUpdateUserCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminBossUpdateUserCache message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminBossUpdateUserCache} AdminBossUpdateUserCache
         */
        AdminBossUpdateUserCache.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminBossUpdateUserCache)
                return object;
            var message = new $root.msgProto.AdminBossUpdateUserCache();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an AdminBossUpdateUserCache message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {msgProto.AdminBossUpdateUserCache} message AdminBossUpdateUserCache
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminBossUpdateUserCache.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.data = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this AdminBossUpdateUserCache to JSON.
         * @function toJSON
         * @memberof msgProto.AdminBossUpdateUserCache
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminBossUpdateUserCache.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminBossUpdateUserCache;
    })();

    msgProto.AdminChatServersChat = (function() {

        /**
         * Properties of an AdminChatServersChat.
         * @memberof msgProto
         * @interface IAdminChatServersChat
         * @property {string|null} [nickName] AdminChatServersChat nickName
         * @property {number|null} [vip] AdminChatServersChat vip
         * @property {string|null} [content] AdminChatServersChat content
         * @property {boolean|null} [isGM] AdminChatServersChat isGM
         * @property {string|null} [guildName] AdminChatServersChat guildName
         * @property {string|null} [medalTitle] AdminChatServersChat medalTitle
         * @property {boolean|null} [isLittleHorn] AdminChatServersChat isLittleHorn
         */

        /**
         * Constructs a new AdminChatServersChat.
         * @memberof msgProto
         * @classdesc Represents an AdminChatServersChat.
         * @implements IAdminChatServersChat
         * @constructor
         * @param {msgProto.IAdminChatServersChat=} [properties] Properties to set
         */
        function AdminChatServersChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminChatServersChat nickName.
         * @member {string} nickName
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.nickName = "";

        /**
         * AdminChatServersChat vip.
         * @member {number} vip
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.vip = 0;

        /**
         * AdminChatServersChat content.
         * @member {string} content
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.content = "";

        /**
         * AdminChatServersChat isGM.
         * @member {boolean} isGM
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.isGM = false;

        /**
         * AdminChatServersChat guildName.
         * @member {string} guildName
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.guildName = "";

        /**
         * AdminChatServersChat medalTitle.
         * @member {string} medalTitle
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.medalTitle = "";

        /**
         * AdminChatServersChat isLittleHorn.
         * @member {boolean} isLittleHorn
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.isLittleHorn = false;

        /**
         * Encodes the specified AdminChatServersChat message. Does not implicitly {@link msgProto.AdminChatServersChat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {msgProto.IAdminChatServersChat} message AdminChatServersChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminChatServersChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
            if (message.vip != null && message.hasOwnProperty("vip"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vip);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
            if (message.isGM != null && message.hasOwnProperty("isGM"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isGM);
            if (message.guildName != null && message.hasOwnProperty("guildName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.guildName);
            if (message.medalTitle != null && message.hasOwnProperty("medalTitle"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.medalTitle);
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isLittleHorn);
            return writer;
        };

        /**
         * Decodes an AdminChatServersChat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminChatServersChat} AdminChatServersChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminChatServersChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminChatServersChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nickName = reader.string();
                    break;
                case 2:
                    message.vip = reader.int32();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                case 4:
                    message.isGM = reader.bool();
                    break;
                case 5:
                    message.guildName = reader.string();
                    break;
                case 6:
                    message.medalTitle = reader.string();
                    break;
                case 7:
                    message.isLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminChatServersChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminChatServersChat} AdminChatServersChat
         */
        AdminChatServersChat.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminChatServersChat)
                return object;
            var message = new $root.msgProto.AdminChatServersChat();
            if (object.nickName != null)
                message.nickName = String(object.nickName);
            if (object.vip != null)
                message.vip = object.vip | 0;
            if (object.content != null)
                message.content = String(object.content);
            if (object.isGM != null)
                message.isGM = Boolean(object.isGM);
            if (object.guildName != null)
                message.guildName = String(object.guildName);
            if (object.medalTitle != null)
                message.medalTitle = String(object.medalTitle);
            if (object.isLittleHorn != null)
                message.isLittleHorn = Boolean(object.isLittleHorn);
            return message;
        };

        /**
         * Creates a plain object from an AdminChatServersChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {msgProto.AdminChatServersChat} message AdminChatServersChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminChatServersChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nickName = "";
                object.vip = 0;
                object.content = "";
                object.isGM = false;
                object.guildName = "";
                object.medalTitle = "";
                object.isLittleHorn = false;
            }
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                object.nickName = message.nickName;
            if (message.vip != null && message.hasOwnProperty("vip"))
                object.vip = message.vip;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.isGM != null && message.hasOwnProperty("isGM"))
                object.isGM = message.isGM;
            if (message.guildName != null && message.hasOwnProperty("guildName"))
                object.guildName = message.guildName;
            if (message.medalTitle != null && message.hasOwnProperty("medalTitle"))
                object.medalTitle = message.medalTitle;
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                object.isLittleHorn = message.isLittleHorn;
            return object;
        };

        /**
         * Converts this AdminChatServersChat to JSON.
         * @function toJSON
         * @memberof msgProto.AdminChatServersChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminChatServersChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminChatServersChat;
    })();

    msgProto.AdminGuildWarLootDefense = (function() {

        /**
         * Properties of an AdminGuildWarLootDefense.
         * @memberof msgProto
         * @interface IAdminGuildWarLootDefense
         * @property {string|null} [attackData] AdminGuildWarLootDefense attackData
         * @property {boolean|null} [isWin] AdminGuildWarLootDefense isWin
         * @property {string|null} [defenceData] AdminGuildWarLootDefense defenceData
         */

        /**
         * Constructs a new AdminGuildWarLootDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarLootDefense.
         * @implements IAdminGuildWarLootDefense
         * @constructor
         * @param {msgProto.IAdminGuildWarLootDefense=} [properties] Properties to set
         */
        function AdminGuildWarLootDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarLootDefense attackData.
         * @member {string} attackData
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.attackData = "";

        /**
         * AdminGuildWarLootDefense isWin.
         * @member {boolean} isWin
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.isWin = false;

        /**
         * AdminGuildWarLootDefense defenceData.
         * @member {string} defenceData
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.defenceData = "";

        /**
         * Encodes the specified AdminGuildWarLootDefense message. Does not implicitly {@link msgProto.AdminGuildWarLootDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {msgProto.IAdminGuildWarLootDefense} message AdminGuildWarLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarLootDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.attackData);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isWin);
            if (message.defenceData != null && message.hasOwnProperty("defenceData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.defenceData);
            return writer;
        };

        /**
         * Decodes an AdminGuildWarLootDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarLootDefense} AdminGuildWarLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarLootDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarLootDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attackData = reader.string();
                    break;
                case 2:
                    message.isWin = reader.bool();
                    break;
                case 3:
                    message.defenceData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildWarLootDefense message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildWarLootDefense} AdminGuildWarLootDefense
         */
        AdminGuildWarLootDefense.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildWarLootDefense)
                return object;
            var message = new $root.msgProto.AdminGuildWarLootDefense();
            if (object.attackData != null)
                message.attackData = String(object.attackData);
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.defenceData != null)
                message.defenceData = String(object.defenceData);
            return message;
        };

        /**
         * Creates a plain object from an AdminGuildWarLootDefense message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {msgProto.AdminGuildWarLootDefense} message AdminGuildWarLootDefense
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildWarLootDefense.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attackData = "";
                object.isWin = false;
                object.defenceData = "";
            }
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                object.attackData = message.attackData;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.defenceData != null && message.hasOwnProperty("defenceData"))
                object.defenceData = message.defenceData;
            return object;
        };

        /**
         * Converts this AdminGuildWarLootDefense to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildWarLootDefense.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildWarLootDefense;
    })();

    msgProto.AdminGuildWarPushBeFightRecord = (function() {

        /**
         * Properties of an AdminGuildWarPushBeFightRecord.
         * @memberof msgProto
         * @interface IAdminGuildWarPushBeFightRecord
         * @property {number|null} [guildId] AdminGuildWarPushBeFightRecord guildId
         * @property {string|null} [data] AdminGuildWarPushBeFightRecord data
         */

        /**
         * Constructs a new AdminGuildWarPushBeFightRecord.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarPushBeFightRecord.
         * @implements IAdminGuildWarPushBeFightRecord
         * @constructor
         * @param {msgProto.IAdminGuildWarPushBeFightRecord=} [properties] Properties to set
         */
        function AdminGuildWarPushBeFightRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarPushBeFightRecord guildId.
         * @member {number} guildId
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @instance
         */
        AdminGuildWarPushBeFightRecord.prototype.guildId = 0;

        /**
         * AdminGuildWarPushBeFightRecord data.
         * @member {string} data
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @instance
         */
        AdminGuildWarPushBeFightRecord.prototype.data = "";

        /**
         * Encodes the specified AdminGuildWarPushBeFightRecord message. Does not implicitly {@link msgProto.AdminGuildWarPushBeFightRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {msgProto.IAdminGuildWarPushBeFightRecord} message AdminGuildWarPushBeFightRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarPushBeFightRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Decodes an AdminGuildWarPushBeFightRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarPushBeFightRecord} AdminGuildWarPushBeFightRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarPushBeFightRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarPushBeFightRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildWarPushBeFightRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildWarPushBeFightRecord} AdminGuildWarPushBeFightRecord
         */
        AdminGuildWarPushBeFightRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildWarPushBeFightRecord)
                return object;
            var message = new $root.msgProto.AdminGuildWarPushBeFightRecord();
            if (object.guildId != null)
                message.guildId = object.guildId | 0;
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from an AdminGuildWarPushBeFightRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {msgProto.AdminGuildWarPushBeFightRecord} message AdminGuildWarPushBeFightRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildWarPushBeFightRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.guildId = 0;
                object.data = "";
            }
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                object.guildId = message.guildId;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this AdminGuildWarPushBeFightRecord to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildWarPushBeFightRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildWarPushBeFightRecord;
    })();

    msgProto.AdminGuildWarGetCurServerGuildWarObj = (function() {

        /**
         * Properties of an AdminGuildWarGetCurServerGuildWarObj.
         * @memberof msgProto
         * @interface IAdminGuildWarGetCurServerGuildWarObj
         */

        /**
         * Constructs a new AdminGuildWarGetCurServerGuildWarObj.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarGetCurServerGuildWarObj.
         * @implements IAdminGuildWarGetCurServerGuildWarObj
         * @constructor
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj=} [properties] Properties to set
         */
        function AdminGuildWarGetCurServerGuildWarObj(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminGuildWarGetCurServerGuildWarObj message. Does not implicitly {@link msgProto.AdminGuildWarGetCurServerGuildWarObj.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj} message AdminGuildWarGetCurServerGuildWarObj message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarGetCurServerGuildWarObj.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminGuildWarGetCurServerGuildWarObj message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarGetCurServerGuildWarObj} AdminGuildWarGetCurServerGuildWarObj
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarGetCurServerGuildWarObj.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarGetCurServerGuildWarObj();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildWarGetCurServerGuildWarObj message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildWarGetCurServerGuildWarObj} AdminGuildWarGetCurServerGuildWarObj
         */
        AdminGuildWarGetCurServerGuildWarObj.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildWarGetCurServerGuildWarObj)
                return object;
            return new $root.msgProto.AdminGuildWarGetCurServerGuildWarObj();
        };

        /**
         * Creates a plain object from an AdminGuildWarGetCurServerGuildWarObj message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {msgProto.AdminGuildWarGetCurServerGuildWarObj} message AdminGuildWarGetCurServerGuildWarObj
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildWarGetCurServerGuildWarObj.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminGuildWarGetCurServerGuildWarObj to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildWarGetCurServerGuildWarObj.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildWarGetCurServerGuildWarObj;
    })();

    msgProto.AdminGuildWarEnter100User = (function() {

        /**
         * Properties of an AdminGuildWarEnter100User.
         * @memberof msgProto
         * @interface IAdminGuildWarEnter100User
         */

        /**
         * Constructs a new AdminGuildWarEnter100User.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarEnter100User.
         * @implements IAdminGuildWarEnter100User
         * @constructor
         * @param {msgProto.IAdminGuildWarEnter100User=} [properties] Properties to set
         */
        function AdminGuildWarEnter100User(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminGuildWarEnter100User message. Does not implicitly {@link msgProto.AdminGuildWarEnter100User.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {msgProto.IAdminGuildWarEnter100User} message AdminGuildWarEnter100User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarEnter100User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminGuildWarEnter100User message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarEnter100User} AdminGuildWarEnter100User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarEnter100User.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarEnter100User();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildWarEnter100User message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildWarEnter100User} AdminGuildWarEnter100User
         */
        AdminGuildWarEnter100User.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildWarEnter100User)
                return object;
            return new $root.msgProto.AdminGuildWarEnter100User();
        };

        /**
         * Creates a plain object from an AdminGuildWarEnter100User message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {msgProto.AdminGuildWarEnter100User} message AdminGuildWarEnter100User
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildWarEnter100User.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminGuildWarEnter100User to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildWarEnter100User
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildWarEnter100User.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildWarEnter100User;
    })();

    msgProto.AdminGuildWarSyncGetSyncServer = (function() {

        /**
         * Properties of an AdminGuildWarSyncGetSyncServer.
         * @memberof msgProto
         * @interface IAdminGuildWarSyncGetSyncServer
         * @property {string|null} [curServerData] AdminGuildWarSyncGetSyncServer curServerData
         */

        /**
         * Constructs a new AdminGuildWarSyncGetSyncServer.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarSyncGetSyncServer.
         * @implements IAdminGuildWarSyncGetSyncServer
         * @constructor
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer=} [properties] Properties to set
         */
        function AdminGuildWarSyncGetSyncServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarSyncGetSyncServer curServerData.
         * @member {string} curServerData
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @instance
         */
        AdminGuildWarSyncGetSyncServer.prototype.curServerData = "";

        /**
         * Encodes the specified AdminGuildWarSyncGetSyncServer message. Does not implicitly {@link msgProto.AdminGuildWarSyncGetSyncServer.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer} message AdminGuildWarSyncGetSyncServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarSyncGetSyncServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.curServerData != null && message.hasOwnProperty("curServerData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.curServerData);
            return writer;
        };

        /**
         * Decodes an AdminGuildWarSyncGetSyncServer message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarSyncGetSyncServer} AdminGuildWarSyncGetSyncServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarSyncGetSyncServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarSyncGetSyncServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.curServerData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminGuildWarSyncGetSyncServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminGuildWarSyncGetSyncServer} AdminGuildWarSyncGetSyncServer
         */
        AdminGuildWarSyncGetSyncServer.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminGuildWarSyncGetSyncServer)
                return object;
            var message = new $root.msgProto.AdminGuildWarSyncGetSyncServer();
            if (object.curServerData != null)
                message.curServerData = String(object.curServerData);
            return message;
        };

        /**
         * Creates a plain object from an AdminGuildWarSyncGetSyncServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {msgProto.AdminGuildWarSyncGetSyncServer} message AdminGuildWarSyncGetSyncServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminGuildWarSyncGetSyncServer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.curServerData = "";
            if (message.curServerData != null && message.hasOwnProperty("curServerData"))
                object.curServerData = message.curServerData;
            return object;
        };

        /**
         * Converts this AdminGuildWarSyncGetSyncServer to JSON.
         * @function toJSON
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminGuildWarSyncGetSyncServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminGuildWarSyncGetSyncServer;
    })();

    msgProto.AdminTreasureGetTreasureCash = (function() {

        /**
         * Properties of an AdminTreasureGetTreasureCash.
         * @memberof msgProto
         * @interface IAdminTreasureGetTreasureCash
         */

        /**
         * Constructs a new AdminTreasureGetTreasureCash.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureGetTreasureCash.
         * @implements IAdminTreasureGetTreasureCash
         * @constructor
         * @param {msgProto.IAdminTreasureGetTreasureCash=} [properties] Properties to set
         */
        function AdminTreasureGetTreasureCash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminTreasureGetTreasureCash message. Does not implicitly {@link msgProto.AdminTreasureGetTreasureCash.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureCash} message AdminTreasureGetTreasureCash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureCash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminTreasureGetTreasureCash message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureGetTreasureCash} AdminTreasureGetTreasureCash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureCash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureGetTreasureCash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminTreasureGetTreasureCash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminTreasureGetTreasureCash} AdminTreasureGetTreasureCash
         */
        AdminTreasureGetTreasureCash.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminTreasureGetTreasureCash)
                return object;
            return new $root.msgProto.AdminTreasureGetTreasureCash();
        };

        /**
         * Creates a plain object from an AdminTreasureGetTreasureCash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {msgProto.AdminTreasureGetTreasureCash} message AdminTreasureGetTreasureCash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminTreasureGetTreasureCash.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminTreasureGetTreasureCash to JSON.
         * @function toJSON
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminTreasureGetTreasureCash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminTreasureGetTreasureCash;
    })();

    msgProto.AdminTreasureGetTreasureByUserId = (function() {

        /**
         * Properties of an AdminTreasureGetTreasureByUserId.
         * @memberof msgProto
         * @interface IAdminTreasureGetTreasureByUserId
         */

        /**
         * Constructs a new AdminTreasureGetTreasureByUserId.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureGetTreasureByUserId.
         * @implements IAdminTreasureGetTreasureByUserId
         * @constructor
         * @param {msgProto.IAdminTreasureGetTreasureByUserId=} [properties] Properties to set
         */
        function AdminTreasureGetTreasureByUserId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified AdminTreasureGetTreasureByUserId message. Does not implicitly {@link msgProto.AdminTreasureGetTreasureByUserId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureByUserId} message AdminTreasureGetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureByUserId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes an AdminTreasureGetTreasureByUserId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureGetTreasureByUserId} AdminTreasureGetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureByUserId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureGetTreasureByUserId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminTreasureGetTreasureByUserId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminTreasureGetTreasureByUserId} AdminTreasureGetTreasureByUserId
         */
        AdminTreasureGetTreasureByUserId.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminTreasureGetTreasureByUserId)
                return object;
            return new $root.msgProto.AdminTreasureGetTreasureByUserId();
        };

        /**
         * Creates a plain object from an AdminTreasureGetTreasureByUserId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {msgProto.AdminTreasureGetTreasureByUserId} message AdminTreasureGetTreasureByUserId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminTreasureGetTreasureByUserId.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AdminTreasureGetTreasureByUserId to JSON.
         * @function toJSON
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminTreasureGetTreasureByUserId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminTreasureGetTreasureByUserId;
    })();

    msgProto.AdminTreasureSetTreasureByUserId = (function() {

        /**
         * Properties of an AdminTreasureSetTreasureByUserId.
         * @memberof msgProto
         * @interface IAdminTreasureSetTreasureByUserId
         * @property {number|Long|null} [userId] AdminTreasureSetTreasureByUserId userId
         */

        /**
         * Constructs a new AdminTreasureSetTreasureByUserId.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureSetTreasureByUserId.
         * @implements IAdminTreasureSetTreasureByUserId
         * @constructor
         * @param {msgProto.IAdminTreasureSetTreasureByUserId=} [properties] Properties to set
         */
        function AdminTreasureSetTreasureByUserId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminTreasureSetTreasureByUserId userId.
         * @member {number|Long} userId
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @instance
         */
        AdminTreasureSetTreasureByUserId.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Encodes the specified AdminTreasureSetTreasureByUserId message. Does not implicitly {@link msgProto.AdminTreasureSetTreasureByUserId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureSetTreasureByUserId} message AdminTreasureSetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureSetTreasureByUserId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Decodes an AdminTreasureSetTreasureByUserId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureSetTreasureByUserId} AdminTreasureSetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureSetTreasureByUserId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureSetTreasureByUserId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates an AdminTreasureSetTreasureByUserId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.AdminTreasureSetTreasureByUserId} AdminTreasureSetTreasureByUserId
         */
        AdminTreasureSetTreasureByUserId.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.AdminTreasureSetTreasureByUserId)
                return object;
            var message = new $root.msgProto.AdminTreasureSetTreasureByUserId();
            if (object.userId != null)
                if ($util.Long)
                    (message.userId = $util.Long.fromValue(object.userId)).unsigned = true;
                else if (typeof object.userId === "string")
                    message.userId = parseInt(object.userId, 10);
                else if (typeof object.userId === "number")
                    message.userId = object.userId;
                else if (typeof object.userId === "object")
                    message.userId = new $util.LongBits(object.userId.low >>> 0, object.userId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AdminTreasureSetTreasureByUserId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {msgProto.AdminTreasureSetTreasureByUserId} message AdminTreasureSetTreasureByUserId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdminTreasureSetTreasureByUserId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userId = options.longs === String ? "0" : 0;
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (typeof message.userId === "number")
                    object.userId = options.longs === String ? String(message.userId) : message.userId;
                else
                    object.userId = options.longs === String ? $util.Long.prototype.toString.call(message.userId) : options.longs === Number ? new $util.LongBits(message.userId.low >>> 0, message.userId.high >>> 0).toNumber(true) : message.userId;
            return object;
        };

        /**
         * Converts this AdminTreasureSetTreasureByUserId to JSON.
         * @function toJSON
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdminTreasureSetTreasureByUserId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AdminTreasureSetTreasureByUserId;
    })();

    msgProto.ServerInfo = (function() {

        /**
         * Properties of a ServerInfo.
         * @memberof msgProto
         * @interface IServerInfo
         * @property {string|null} [Ip] ServerInfo Ip
         * @property {number|null} [Port] ServerInfo Port
         */

        /**
         * Constructs a new ServerInfo.
         * @memberof msgProto
         * @classdesc Represents a ServerInfo.
         * @implements IServerInfo
         * @constructor
         * @param {msgProto.IServerInfo=} [properties] Properties to set
         */
        function ServerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerInfo Ip.
         * @member {string} Ip
         * @memberof msgProto.ServerInfo
         * @instance
         */
        ServerInfo.prototype.Ip = "";

        /**
         * ServerInfo Port.
         * @member {number} Port
         * @memberof msgProto.ServerInfo
         * @instance
         */
        ServerInfo.prototype.Port = 0;

        /**
         * Encodes the specified ServerInfo message. Does not implicitly {@link msgProto.ServerInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ServerInfo
         * @static
         * @param {msgProto.IServerInfo} message ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Ip);
            if (message.Port != null && message.hasOwnProperty("Port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Port);
            return writer;
        };

        /**
         * Decodes a ServerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ServerInfo} ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ServerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Ip = reader.string();
                    break;
                case 2:
                    message.Port = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a ServerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.ServerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.ServerInfo} ServerInfo
         */
        ServerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.ServerInfo)
                return object;
            var message = new $root.msgProto.ServerInfo();
            if (object.Ip != null)
                message.Ip = String(object.Ip);
            if (object.Port != null)
                message.Port = object.Port | 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.ServerInfo
         * @static
         * @param {msgProto.ServerInfo} message ServerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Ip = "";
                object.Port = 0;
            }
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                object.Ip = message.Ip;
            if (message.Port != null && message.hasOwnProperty("Port"))
                object.Port = message.Port;
            return object;
        };

        /**
         * Converts this ServerInfo to JSON.
         * @function toJSON
         * @memberof msgProto.ServerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServerInfo;
    })();

    msgProto.PingAck = (function() {

        /**
         * Properties of a PingAck.
         * @memberof msgProto
         * @interface IPingAck
         */

        /**
         * Constructs a new PingAck.
         * @memberof msgProto
         * @classdesc Represents a PingAck.
         * @implements IPingAck
         * @constructor
         * @param {msgProto.IPingAck=} [properties] Properties to set
         */
        function PingAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Encodes the specified PingAck message. Does not implicitly {@link msgProto.PingAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PingAck
         * @static
         * @param {msgProto.IPingAck} message PingAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PingAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PingAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PingAck} PingAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PingAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a PingAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.PingAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.PingAck} PingAck
         */
        PingAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.PingAck)
                return object;
            return new $root.msgProto.PingAck();
        };

        /**
         * Creates a plain object from a PingAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.PingAck
         * @static
         * @param {msgProto.PingAck} message PingAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingAck.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PingAck to JSON.
         * @function toJSON
         * @memberof msgProto.PingAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingAck;
    })();

    msgProto.LoginReq = (function() {

        /**
         * Properties of a LoginReq.
         * @memberof msgProto
         * @interface ILoginReq
         * @property {string|null} [Version] LoginReq Version
         * @property {string|null} [Platform] LoginReq Platform
         * @property {string|null} [Uid] LoginReq Uid
         */

        /**
         * Constructs a new LoginReq.
         * @memberof msgProto
         * @classdesc Represents a LoginReq.
         * @implements ILoginReq
         * @constructor
         * @param {msgProto.ILoginReq=} [properties] Properties to set
         */
        function LoginReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginReq Version.
         * @member {string} Version
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Version = "";

        /**
         * LoginReq Platform.
         * @member {string} Platform
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Platform = "";

        /**
         * LoginReq Uid.
         * @member {string} Uid
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Uid = "";

        /**
         * Encodes the specified LoginReq message. Does not implicitly {@link msgProto.LoginReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginReq
         * @static
         * @param {msgProto.ILoginReq} message LoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Version != null && message.hasOwnProperty("Version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Version);
            if (message.Platform != null && message.hasOwnProperty("Platform"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Platform);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Uid);
            return writer;
        };

        /**
         * Decodes a LoginReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginReq} LoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Version = reader.string();
                    break;
                case 2:
                    message.Platform = reader.string();
                    break;
                case 3:
                    message.Uid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LoginReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LoginReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LoginReq} LoginReq
         */
        LoginReq.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LoginReq)
                return object;
            var message = new $root.msgProto.LoginReq();
            if (object.Version != null)
                message.Version = String(object.Version);
            if (object.Platform != null)
                message.Platform = String(object.Platform);
            if (object.Uid != null)
                message.Uid = String(object.Uid);
            return message;
        };

        /**
         * Creates a plain object from a LoginReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LoginReq
         * @static
         * @param {msgProto.LoginReq} message LoginReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Version = "";
                object.Platform = "";
                object.Uid = "";
            }
            if (message.Version != null && message.hasOwnProperty("Version"))
                object.Version = message.Version;
            if (message.Platform != null && message.hasOwnProperty("Platform"))
                object.Platform = message.Platform;
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                object.Uid = message.Uid;
            return object;
        };

        /**
         * Converts this LoginReq to JSON.
         * @function toJSON
         * @memberof msgProto.LoginReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginReq;
    })();

    msgProto.LoginAck = (function() {

        /**
         * Properties of a LoginAck.
         * @memberof msgProto
         * @interface ILoginAck
         * @property {msgProto.ResultCode|null} [Result] LoginAck Result
         * @property {msgProto.IServerInfo|null} [Server] LoginAck Server
         * @property {string|null} [GameToken] LoginAck GameToken
         * @property {string|null} [GameSvcId] LoginAck GameSvcId
         */

        /**
         * Constructs a new LoginAck.
         * @memberof msgProto
         * @classdesc Represents a LoginAck.
         * @implements ILoginAck
         * @constructor
         * @param {msgProto.ILoginAck=} [properties] Properties to set
         */
        function LoginAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginAck Result.
         * @member {msgProto.ResultCode} Result
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.Result = 0;

        /**
         * LoginAck Server.
         * @member {msgProto.IServerInfo|null|undefined} Server
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.Server = null;

        /**
         * LoginAck GameToken.
         * @member {string} GameToken
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.GameToken = "";

        /**
         * LoginAck GameSvcId.
         * @member {string} GameSvcId
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.GameSvcId = "";

        /**
         * Encodes the specified LoginAck message. Does not implicitly {@link msgProto.LoginAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginAck
         * @static
         * @param {msgProto.ILoginAck} message LoginAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            if (message.Server != null && message.hasOwnProperty("Server"))
                $root.msgProto.ServerInfo.encode(message.Server, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.GameToken);
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.GameSvcId);
            return writer;
        };

        /**
         * Decodes a LoginAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginAck} LoginAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                case 2:
                    message.Server = $root.msgProto.ServerInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.GameToken = reader.string();
                    break;
                case 4:
                    message.GameSvcId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a LoginAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.LoginAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.LoginAck} LoginAck
         */
        LoginAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.LoginAck)
                return object;
            var message = new $root.msgProto.LoginAck();
            switch (object.Result) {
            case "NoError":
            case 0:
                message.Result = 0;
                break;
            case "GateNotFound":
            case 1:
                message.Result = 1;
                break;
            case "GateAddressError":
            case 2:
                message.Result = 2;
                break;
            case "GameNotFound":
            case 3:
                message.Result = 3;
                break;
            }
            if (object.Server != null) {
                if (typeof object.Server !== "object")
                    throw TypeError(".msgProto.LoginAck.Server: object expected");
                message.Server = $root.msgProto.ServerInfo.fromObject(object.Server);
            }
            if (object.GameToken != null)
                message.GameToken = String(object.GameToken);
            if (object.GameSvcId != null)
                message.GameSvcId = String(object.GameSvcId);
            return message;
        };

        /**
         * Creates a plain object from a LoginAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.LoginAck
         * @static
         * @param {msgProto.LoginAck} message LoginAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Result = options.enums === String ? "NoError" : 0;
                object.Server = null;
                object.GameToken = "";
                object.GameSvcId = "";
            }
            if (message.Result != null && message.hasOwnProperty("Result"))
                object.Result = options.enums === String ? $root.msgProto.ResultCode[message.Result] : message.Result;
            if (message.Server != null && message.hasOwnProperty("Server"))
                object.Server = $root.msgProto.ServerInfo.toObject(message.Server, options);
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                object.GameToken = message.GameToken;
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                object.GameSvcId = message.GameSvcId;
            return object;
        };

        /**
         * Converts this LoginAck to JSON.
         * @function toJSON
         * @memberof msgProto.LoginAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginAck;
    })();

    msgProto.VerifyReq = (function() {

        /**
         * Properties of a VerifyReq.
         * @memberof msgProto
         * @interface IVerifyReq
         * @property {string|null} [GameToken] VerifyReq GameToken
         * @property {string|null} [GameSvcId] VerifyReq GameSvcId
         * @property {number|Long|null} [AccountId] VerifyReq AccountId
         */

        /**
         * Constructs a new VerifyReq.
         * @memberof msgProto
         * @classdesc Represents a VerifyReq.
         * @implements IVerifyReq
         * @constructor
         * @param {msgProto.IVerifyReq=} [properties] Properties to set
         */
        function VerifyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyReq GameToken.
         * @member {string} GameToken
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.GameToken = "";

        /**
         * VerifyReq GameSvcId.
         * @member {string} GameSvcId
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.GameSvcId = "";

        /**
         * VerifyReq AccountId.
         * @member {number|Long} AccountId
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified VerifyReq message. Does not implicitly {@link msgProto.VerifyReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.VerifyReq
         * @static
         * @param {msgProto.IVerifyReq} message VerifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GameToken);
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.GameSvcId);
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.AccountId);
            return writer;
        };

        /**
         * Decodes a VerifyReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.VerifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.VerifyReq} VerifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.VerifyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GameToken = reader.string();
                    break;
                case 2:
                    message.GameSvcId = reader.string();
                    break;
                case 3:
                    message.AccountId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a VerifyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.VerifyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.VerifyReq} VerifyReq
         */
        VerifyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.VerifyReq)
                return object;
            var message = new $root.msgProto.VerifyReq();
            if (object.GameToken != null)
                message.GameToken = String(object.GameToken);
            if (object.GameSvcId != null)
                message.GameSvcId = String(object.GameSvcId);
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a VerifyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.VerifyReq
         * @static
         * @param {msgProto.VerifyReq} message VerifyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.GameToken = "";
                object.GameSvcId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
            }
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                object.GameToken = message.GameToken;
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                object.GameSvcId = message.GameSvcId;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            return object;
        };

        /**
         * Converts this VerifyReq to JSON.
         * @function toJSON
         * @memberof msgProto.VerifyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyReq;
    })();

    msgProto.VerifyAck = (function() {

        /**
         * Properties of a VerifyAck.
         * @memberof msgProto
         * @interface IVerifyAck
         * @property {msgProto.ResultCode|null} [Result] VerifyAck Result
         */

        /**
         * Constructs a new VerifyAck.
         * @memberof msgProto
         * @classdesc Represents a VerifyAck.
         * @implements IVerifyAck
         * @constructor
         * @param {msgProto.IVerifyAck=} [properties] Properties to set
         */
        function VerifyAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyAck Result.
         * @member {msgProto.ResultCode} Result
         * @memberof msgProto.VerifyAck
         * @instance
         */
        VerifyAck.prototype.Result = 0;

        /**
         * Encodes the specified VerifyAck message. Does not implicitly {@link msgProto.VerifyAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.VerifyAck
         * @static
         * @param {msgProto.IVerifyAck} message VerifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            return writer;
        };

        /**
         * Decodes a VerifyAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.VerifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.VerifyAck} VerifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.VerifyAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Creates a VerifyAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgProto.VerifyAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgProto.VerifyAck} VerifyAck
         */
        VerifyAck.fromObject = function fromObject(object) {
            if (object instanceof $root.msgProto.VerifyAck)
                return object;
            var message = new $root.msgProto.VerifyAck();
            switch (object.Result) {
            case "NoError":
            case 0:
                message.Result = 0;
                break;
            case "GateNotFound":
            case 1:
                message.Result = 1;
                break;
            case "GateAddressError":
            case 2:
                message.Result = 2;
                break;
            case "GameNotFound":
            case 3:
                message.Result = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a VerifyAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgProto.VerifyAck
         * @static
         * @param {msgProto.VerifyAck} message VerifyAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.Result = options.enums === String ? "NoError" : 0;
            if (message.Result != null && message.hasOwnProperty("Result"))
                object.Result = options.enums === String ? $root.msgProto.ResultCode[message.Result] : message.Result;
            return object;
        };

        /**
         * Converts this VerifyAck to JSON.
         * @function toJSON
         * @memberof msgProto.VerifyAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyAck;
    })();

    /**
     * ResultCode enum.
     * @name msgProto.ResultCode
     * @enum {string}
     * @property {number} NoError=0 NoError value
     * @property {number} GateNotFound=1 GateNotFound value
     * @property {number} GateAddressError=2 GateAddressError value
     * @property {number} GameNotFound=3 GameNotFound value
     */
    msgProto.ResultCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoError"] = 0;
        values[valuesById[1] = "GateNotFound"] = 1;
        values[valuesById[2] = "GateAddressError"] = 2;
        values[valuesById[3] = "GameNotFound"] = 3;
        return values;
    })();

    return msgProto;
})();