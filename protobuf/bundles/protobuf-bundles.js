var $protobuf = window.protobuf;
$protobuf.roots.default=window;
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.msgProto = (function() {

    /**
     * Namespace msgProto.
     * @exports msgProto
     * @namespace
     */
    var msgProto = {};

    msgProto.ChatReq = (function() {

        /**
         * Properties of a ChatReq.
         * @memberof msgProto
         * @interface IChatReq
         * @property {string|null} [Content] ChatReq Content
         */

        /**
         * Constructs a new ChatReq.
         * @memberof msgProto
         * @classdesc Represents a ChatReq.
         * @implements IChatReq
         * @constructor
         * @param {msgProto.IChatReq=} [properties] Properties to set
         */
        function ChatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatReq Content.
         * @member {string} Content
         * @memberof msgProto.ChatReq
         * @instance
         */
        ChatReq.prototype.Content = "";

        /**
         * Creates a new ChatReq instance using the specified properties.
         * @function create
         * @memberof msgProto.ChatReq
         * @static
         * @param {msgProto.IChatReq=} [properties] Properties to set
         * @returns {msgProto.ChatReq} ChatReq instance
         */
        ChatReq.create = function create(properties) {
            return new ChatReq(properties);
        };

        /**
         * Encodes the specified ChatReq message. Does not implicitly {@link msgProto.ChatReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatReq
         * @static
         * @param {msgProto.IChatReq} message ChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Content);
            return writer;
        };

        /**
         * Encodes the specified ChatReq message, length delimited. Does not implicitly {@link msgProto.ChatReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChatReq
         * @static
         * @param {msgProto.IChatReq} message ChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatReq} ChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChatReq} ChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatReq message.
         * @function verify
         * @memberof msgProto.ChatReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            return null;
        };

        return ChatReq;
    })();

    msgProto.ChatAck = (function() {

        /**
         * Properties of a ChatAck.
         * @memberof msgProto
         * @interface IChatAck
         * @property {string|null} [Content] ChatAck Content
         */

        /**
         * Constructs a new ChatAck.
         * @memberof msgProto
         * @classdesc Represents a ChatAck.
         * @implements IChatAck
         * @constructor
         * @param {msgProto.IChatAck=} [properties] Properties to set
         */
        function ChatAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatAck Content.
         * @member {string} Content
         * @memberof msgProto.ChatAck
         * @instance
         */
        ChatAck.prototype.Content = "";

        /**
         * Creates a new ChatAck instance using the specified properties.
         * @function create
         * @memberof msgProto.ChatAck
         * @static
         * @param {msgProto.IChatAck=} [properties] Properties to set
         * @returns {msgProto.ChatAck} ChatAck instance
         */
        ChatAck.create = function create(properties) {
            return new ChatAck(properties);
        };

        /**
         * Encodes the specified ChatAck message. Does not implicitly {@link msgProto.ChatAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatAck
         * @static
         * @param {msgProto.IChatAck} message ChatAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Content);
            return writer;
        };

        /**
         * Encodes the specified ChatAck message, length delimited. Does not implicitly {@link msgProto.ChatAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChatAck
         * @static
         * @param {msgProto.IChatAck} message ChatAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatAck} ChatAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChatAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChatAck} ChatAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatAck message.
         * @function verify
         * @memberof msgProto.ChatAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            return null;
        };

        return ChatAck;
    })();

    msgProto.TestAck = (function() {

        /**
         * Properties of a TestAck.
         * @memberof msgProto
         * @interface ITestAck
         * @property {string|null} [Dummy] TestAck Dummy
         */

        /**
         * Constructs a new TestAck.
         * @memberof msgProto
         * @classdesc Represents a TestAck.
         * @implements ITestAck
         * @constructor
         * @param {msgProto.ITestAck=} [properties] Properties to set
         */
        function TestAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestAck Dummy.
         * @member {string} Dummy
         * @memberof msgProto.TestAck
         * @instance
         */
        TestAck.prototype.Dummy = "";

        /**
         * Creates a new TestAck instance using the specified properties.
         * @function create
         * @memberof msgProto.TestAck
         * @static
         * @param {msgProto.ITestAck=} [properties] Properties to set
         * @returns {msgProto.TestAck} TestAck instance
         */
        TestAck.create = function create(properties) {
            return new TestAck(properties);
        };

        /**
         * Encodes the specified TestAck message. Does not implicitly {@link msgProto.TestAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TestAck
         * @static
         * @param {msgProto.ITestAck} message TestAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Dummy != null && message.hasOwnProperty("Dummy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Dummy);
            return writer;
        };

        /**
         * Encodes the specified TestAck message, length delimited. Does not implicitly {@link msgProto.TestAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TestAck
         * @static
         * @param {msgProto.ITestAck} message TestAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TestAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TestAck} TestAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TestAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Dummy = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TestAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TestAck} TestAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestAck message.
         * @function verify
         * @memberof msgProto.TestAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Dummy != null && message.hasOwnProperty("Dummy"))
                if (!$util.isString(message.Dummy))
                    return "Dummy: string expected";
            return null;
        };

        return TestAck;
    })();

    msgProto.ContentReq = (function() {

        /**
         * Properties of a ContentReq.
         * @memberof msgProto
         * @interface IContentReq
         * @property {string|null} [Msg] ContentReq Msg
         * @property {number|null} [Value] ContentReq Value
         */

        /**
         * Constructs a new ContentReq.
         * @memberof msgProto
         * @classdesc Represents a ContentReq.
         * @implements IContentReq
         * @constructor
         * @param {msgProto.IContentReq=} [properties] Properties to set
         */
        function ContentReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentReq Msg.
         * @member {string} Msg
         * @memberof msgProto.ContentReq
         * @instance
         */
        ContentReq.prototype.Msg = "";

        /**
         * ContentReq Value.
         * @member {number} Value
         * @memberof msgProto.ContentReq
         * @instance
         */
        ContentReq.prototype.Value = 0;

        /**
         * Creates a new ContentReq instance using the specified properties.
         * @function create
         * @memberof msgProto.ContentReq
         * @static
         * @param {msgProto.IContentReq=} [properties] Properties to set
         * @returns {msgProto.ContentReq} ContentReq instance
         */
        ContentReq.create = function create(properties) {
            return new ContentReq(properties);
        };

        /**
         * Encodes the specified ContentReq message. Does not implicitly {@link msgProto.ContentReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ContentReq
         * @static
         * @param {msgProto.IContentReq} message ContentReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Value);
            return writer;
        };

        /**
         * Encodes the specified ContentReq message, length delimited. Does not implicitly {@link msgProto.ContentReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ContentReq
         * @static
         * @param {msgProto.IContentReq} message ContentReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContentReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ContentReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ContentReq} ContentReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ContentReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = reader.string();
                    break;
                case 2:
                    message.Value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContentReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ContentReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ContentReq} ContentReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContentReq message.
         * @function verify
         * @memberof msgProto.ContentReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContentReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (!$util.isInteger(message.Value))
                    return "Value: integer expected";
            return null;
        };

        return ContentReq;
    })();

    msgProto.ContentAck = (function() {

        /**
         * Properties of a ContentAck.
         * @memberof msgProto
         * @interface IContentAck
         * @property {string|null} [Msg] ContentAck Msg
         * @property {number|null} [Value] ContentAck Value
         */

        /**
         * Constructs a new ContentAck.
         * @memberof msgProto
         * @classdesc Represents a ContentAck.
         * @implements IContentAck
         * @constructor
         * @param {msgProto.IContentAck=} [properties] Properties to set
         */
        function ContentAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentAck Msg.
         * @member {string} Msg
         * @memberof msgProto.ContentAck
         * @instance
         */
        ContentAck.prototype.Msg = "";

        /**
         * ContentAck Value.
         * @member {number} Value
         * @memberof msgProto.ContentAck
         * @instance
         */
        ContentAck.prototype.Value = 0;

        /**
         * Creates a new ContentAck instance using the specified properties.
         * @function create
         * @memberof msgProto.ContentAck
         * @static
         * @param {msgProto.IContentAck=} [properties] Properties to set
         * @returns {msgProto.ContentAck} ContentAck instance
         */
        ContentAck.create = function create(properties) {
            return new ContentAck(properties);
        };

        /**
         * Encodes the specified ContentAck message. Does not implicitly {@link msgProto.ContentAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ContentAck
         * @static
         * @param {msgProto.IContentAck} message ContentAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Value);
            return writer;
        };

        /**
         * Encodes the specified ContentAck message, length delimited. Does not implicitly {@link msgProto.ContentAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ContentAck
         * @static
         * @param {msgProto.IContentAck} message ContentAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContentAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ContentAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ContentAck} ContentAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ContentAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = reader.string();
                    break;
                case 2:
                    message.Value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContentAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ContentAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ContentAck} ContentAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContentAck message.
         * @function verify
         * @memberof msgProto.ContentAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContentAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (!$util.isInteger(message.Value))
                    return "Value: integer expected";
            return null;
        };

        return ContentAck;
    })();

    msgProto.ActivityBuyMysterShop = (function() {

        /**
         * Properties of an ActivityBuyMysterShop.
         * @memberof msgProto
         * @interface IActivityBuyMysterShop
         * @property {number|null} [activityId] ActivityBuyMysterShop activityId
         * @property {number|null} [index] ActivityBuyMysterShop index
         */

        /**
         * Constructs a new ActivityBuyMysterShop.
         * @memberof msgProto
         * @classdesc Represents an ActivityBuyMysterShop.
         * @implements IActivityBuyMysterShop
         * @constructor
         * @param {msgProto.IActivityBuyMysterShop=} [properties] Properties to set
         */
        function ActivityBuyMysterShop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityBuyMysterShop activityId.
         * @member {number} activityId
         * @memberof msgProto.ActivityBuyMysterShop
         * @instance
         */
        ActivityBuyMysterShop.prototype.activityId = 0;

        /**
         * ActivityBuyMysterShop index.
         * @member {number} index
         * @memberof msgProto.ActivityBuyMysterShop
         * @instance
         */
        ActivityBuyMysterShop.prototype.index = 0;

        /**
         * Creates a new ActivityBuyMysterShop instance using the specified properties.
         * @function create
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {msgProto.IActivityBuyMysterShop=} [properties] Properties to set
         * @returns {msgProto.ActivityBuyMysterShop} ActivityBuyMysterShop instance
         */
        ActivityBuyMysterShop.create = function create(properties) {
            return new ActivityBuyMysterShop(properties);
        };

        /**
         * Encodes the specified ActivityBuyMysterShop message. Does not implicitly {@link msgProto.ActivityBuyMysterShop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {msgProto.IActivityBuyMysterShop} message ActivityBuyMysterShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityBuyMysterShop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified ActivityBuyMysterShop message, length delimited. Does not implicitly {@link msgProto.ActivityBuyMysterShop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {msgProto.IActivityBuyMysterShop} message ActivityBuyMysterShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityBuyMysterShop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivityBuyMysterShop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityBuyMysterShop} ActivityBuyMysterShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityBuyMysterShop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityBuyMysterShop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivityBuyMysterShop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ActivityBuyMysterShop} ActivityBuyMysterShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityBuyMysterShop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivityBuyMysterShop message.
         * @function verify
         * @memberof msgProto.ActivityBuyMysterShop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivityBuyMysterShop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return ActivityBuyMysterShop;
    })();

    msgProto.ActivityGetList = (function() {

        /**
         * Properties of an ActivityGetList.
         * @memberof msgProto
         * @interface IActivityGetList
         */

        /**
         * Constructs a new ActivityGetList.
         * @memberof msgProto
         * @classdesc Represents an ActivityGetList.
         * @implements IActivityGetList
         * @constructor
         * @param {msgProto.IActivityGetList=} [properties] Properties to set
         */
        function ActivityGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ActivityGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {msgProto.IActivityGetList=} [properties] Properties to set
         * @returns {msgProto.ActivityGetList} ActivityGetList instance
         */
        ActivityGetList.create = function create(properties) {
            return new ActivityGetList(properties);
        };

        /**
         * Encodes the specified ActivityGetList message. Does not implicitly {@link msgProto.ActivityGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {msgProto.IActivityGetList} message ActivityGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ActivityGetList message, length delimited. Does not implicitly {@link msgProto.ActivityGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {msgProto.IActivityGetList} message ActivityGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivityGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityGetList} ActivityGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivityGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ActivityGetList} ActivityGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivityGetList message.
         * @function verify
         * @memberof msgProto.ActivityGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivityGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ActivityGetList;
    })();

    msgProto.ActivityReceive = (function() {

        /**
         * Properties of an ActivityReceive.
         * @memberof msgProto
         * @interface IActivityReceive
         * @property {number|null} [activityId] ActivityReceive activityId
         * @property {number|null} [index] ActivityReceive index
         */

        /**
         * Constructs a new ActivityReceive.
         * @memberof msgProto
         * @classdesc Represents an ActivityReceive.
         * @implements IActivityReceive
         * @constructor
         * @param {msgProto.IActivityReceive=} [properties] Properties to set
         */
        function ActivityReceive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityReceive activityId.
         * @member {number} activityId
         * @memberof msgProto.ActivityReceive
         * @instance
         */
        ActivityReceive.prototype.activityId = 0;

        /**
         * ActivityReceive index.
         * @member {number} index
         * @memberof msgProto.ActivityReceive
         * @instance
         */
        ActivityReceive.prototype.index = 0;

        /**
         * Creates a new ActivityReceive instance using the specified properties.
         * @function create
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {msgProto.IActivityReceive=} [properties] Properties to set
         * @returns {msgProto.ActivityReceive} ActivityReceive instance
         */
        ActivityReceive.create = function create(properties) {
            return new ActivityReceive(properties);
        };

        /**
         * Encodes the specified ActivityReceive message. Does not implicitly {@link msgProto.ActivityReceive.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {msgProto.IActivityReceive} message ActivityReceive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReceive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified ActivityReceive message, length delimited. Does not implicitly {@link msgProto.ActivityReceive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {msgProto.IActivityReceive} message ActivityReceive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReceive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivityReceive message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityReceive} ActivityReceive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReceive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityReceive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivityReceive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ActivityReceive} ActivityReceive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReceive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivityReceive message.
         * @function verify
         * @memberof msgProto.ActivityReceive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivityReceive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return ActivityReceive;
    })();

    msgProto.ActivityGetIsNeedOperate = (function() {

        /**
         * Properties of an ActivityGetIsNeedOperate.
         * @memberof msgProto
         * @interface IActivityGetIsNeedOperate
         */

        /**
         * Constructs a new ActivityGetIsNeedOperate.
         * @memberof msgProto
         * @classdesc Represents an ActivityGetIsNeedOperate.
         * @implements IActivityGetIsNeedOperate
         * @constructor
         * @param {msgProto.IActivityGetIsNeedOperate=} [properties] Properties to set
         */
        function ActivityGetIsNeedOperate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ActivityGetIsNeedOperate instance using the specified properties.
         * @function create
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {msgProto.IActivityGetIsNeedOperate=} [properties] Properties to set
         * @returns {msgProto.ActivityGetIsNeedOperate} ActivityGetIsNeedOperate instance
         */
        ActivityGetIsNeedOperate.create = function create(properties) {
            return new ActivityGetIsNeedOperate(properties);
        };

        /**
         * Encodes the specified ActivityGetIsNeedOperate message. Does not implicitly {@link msgProto.ActivityGetIsNeedOperate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {msgProto.IActivityGetIsNeedOperate} message ActivityGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetIsNeedOperate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ActivityGetIsNeedOperate message, length delimited. Does not implicitly {@link msgProto.ActivityGetIsNeedOperate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {msgProto.IActivityGetIsNeedOperate} message ActivityGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityGetIsNeedOperate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivityGetIsNeedOperate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityGetIsNeedOperate} ActivityGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetIsNeedOperate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityGetIsNeedOperate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivityGetIsNeedOperate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ActivityGetIsNeedOperate} ActivityGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityGetIsNeedOperate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivityGetIsNeedOperate message.
         * @function verify
         * @memberof msgProto.ActivityGetIsNeedOperate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivityGetIsNeedOperate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ActivityGetIsNeedOperate;
    })();

    msgProto.activity_patchSign = (function() {

        /**
         * Properties of an activity_patchSign.
         * @memberof msgProto
         * @interface Iactivity_patchSign
         * @property {number|null} [activityId] activity_patchSign activityId
         */

        /**
         * Constructs a new activity_patchSign.
         * @memberof msgProto
         * @classdesc Represents an activity_patchSign.
         * @implements Iactivity_patchSign
         * @constructor
         * @param {msgProto.Iactivity_patchSign=} [properties] Properties to set
         */
        function activity_patchSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * activity_patchSign activityId.
         * @member {number} activityId
         * @memberof msgProto.activity_patchSign
         * @instance
         */
        activity_patchSign.prototype.activityId = 0;

        /**
         * Creates a new activity_patchSign instance using the specified properties.
         * @function create
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {msgProto.Iactivity_patchSign=} [properties] Properties to set
         * @returns {msgProto.activity_patchSign} activity_patchSign instance
         */
        activity_patchSign.create = function create(properties) {
            return new activity_patchSign(properties);
        };

        /**
         * Encodes the specified activity_patchSign message. Does not implicitly {@link msgProto.activity_patchSign.verify|verify} messages.
         * @function encode
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {msgProto.Iactivity_patchSign} message activity_patchSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        activity_patchSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityId);
            return writer;
        };

        /**
         * Encodes the specified activity_patchSign message, length delimited. Does not implicitly {@link msgProto.activity_patchSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {msgProto.Iactivity_patchSign} message activity_patchSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        activity_patchSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an activity_patchSign message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.activity_patchSign} activity_patchSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        activity_patchSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.activity_patchSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an activity_patchSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.activity_patchSign} activity_patchSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        activity_patchSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an activity_patchSign message.
         * @function verify
         * @memberof msgProto.activity_patchSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        activity_patchSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activityId != null && message.hasOwnProperty("activityId"))
                if (!$util.isInteger(message.activityId))
                    return "activityId: integer expected";
            return null;
        };

        return activity_patchSign;
    })();

    msgProto.ActivityReport = (function() {

        /**
         * Properties of an ActivityReport.
         * @memberof msgProto
         * @interface IActivityReport
         * @property {number|null} [ActivityId] ActivityReport ActivityId
         * @property {string|null} [report] ActivityReport report
         */

        /**
         * Constructs a new ActivityReport.
         * @memberof msgProto
         * @classdesc Represents an ActivityReport.
         * @implements IActivityReport
         * @constructor
         * @param {msgProto.IActivityReport=} [properties] Properties to set
         */
        function ActivityReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivityReport ActivityId.
         * @member {number} ActivityId
         * @memberof msgProto.ActivityReport
         * @instance
         */
        ActivityReport.prototype.ActivityId = 0;

        /**
         * ActivityReport report.
         * @member {string} report
         * @memberof msgProto.ActivityReport
         * @instance
         */
        ActivityReport.prototype.report = "";

        /**
         * Creates a new ActivityReport instance using the specified properties.
         * @function create
         * @memberof msgProto.ActivityReport
         * @static
         * @param {msgProto.IActivityReport=} [properties] Properties to set
         * @returns {msgProto.ActivityReport} ActivityReport instance
         */
        ActivityReport.create = function create(properties) {
            return new ActivityReport(properties);
        };

        /**
         * Encodes the specified ActivityReport message. Does not implicitly {@link msgProto.ActivityReport.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ActivityReport
         * @static
         * @param {msgProto.IActivityReport} message ActivityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ActivityId != null && message.hasOwnProperty("ActivityId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ActivityId);
            if (message.report != null && message.hasOwnProperty("report"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.report);
            return writer;
        };

        /**
         * Encodes the specified ActivityReport message, length delimited. Does not implicitly {@link msgProto.ActivityReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ActivityReport
         * @static
         * @param {msgProto.IActivityReport} message ActivityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivityReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivityReport message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ActivityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ActivityReport} ActivityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ActivityReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ActivityId = reader.int32();
                    break;
                case 2:
                    message.report = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivityReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ActivityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ActivityReport} ActivityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivityReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivityReport message.
         * @function verify
         * @memberof msgProto.ActivityReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivityReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ActivityId != null && message.hasOwnProperty("ActivityId"))
                if (!$util.isInteger(message.ActivityId))
                    return "ActivityId: integer expected";
            if (message.report != null && message.hasOwnProperty("report"))
                if (!$util.isString(message.report))
                    return "report: string expected";
            return null;
        };

        return ActivityReport;
    })();

    msgProto.ArenaGetInfo = (function() {

        /**
         * Properties of an ArenaGetInfo.
         * @memberof msgProto
         * @interface IArenaGetInfo
         */

        /**
         * Constructs a new ArenaGetInfo.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetInfo.
         * @implements IArenaGetInfo
         * @constructor
         * @param {msgProto.IArenaGetInfo=} [properties] Properties to set
         */
        function ArenaGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {msgProto.IArenaGetInfo=} [properties] Properties to set
         * @returns {msgProto.ArenaGetInfo} ArenaGetInfo instance
         */
        ArenaGetInfo.create = function create(properties) {
            return new ArenaGetInfo(properties);
        };

        /**
         * Encodes the specified ArenaGetInfo message. Does not implicitly {@link msgProto.ArenaGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {msgProto.IArenaGetInfo} message ArenaGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaGetInfo message, length delimited. Does not implicitly {@link msgProto.ArenaGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {msgProto.IArenaGetInfo} message ArenaGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetInfo} ArenaGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaGetInfo} ArenaGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaGetInfo message.
         * @function verify
         * @memberof msgProto.ArenaGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaGetInfo;
    })();

    msgProto.ArenaResetFightRanks = (function() {

        /**
         * Properties of an ArenaResetFightRanks.
         * @memberof msgProto
         * @interface IArenaResetFightRanks
         */

        /**
         * Constructs a new ArenaResetFightRanks.
         * @memberof msgProto
         * @classdesc Represents an ArenaResetFightRanks.
         * @implements IArenaResetFightRanks
         * @constructor
         * @param {msgProto.IArenaResetFightRanks=} [properties] Properties to set
         */
        function ArenaResetFightRanks(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaResetFightRanks instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {msgProto.IArenaResetFightRanks=} [properties] Properties to set
         * @returns {msgProto.ArenaResetFightRanks} ArenaResetFightRanks instance
         */
        ArenaResetFightRanks.create = function create(properties) {
            return new ArenaResetFightRanks(properties);
        };

        /**
         * Encodes the specified ArenaResetFightRanks message. Does not implicitly {@link msgProto.ArenaResetFightRanks.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {msgProto.IArenaResetFightRanks} message ArenaResetFightRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaResetFightRanks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaResetFightRanks message, length delimited. Does not implicitly {@link msgProto.ArenaResetFightRanks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {msgProto.IArenaResetFightRanks} message ArenaResetFightRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaResetFightRanks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaResetFightRanks message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaResetFightRanks} ArenaResetFightRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaResetFightRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaResetFightRanks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaResetFightRanks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaResetFightRanks} ArenaResetFightRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaResetFightRanks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaResetFightRanks message.
         * @function verify
         * @memberof msgProto.ArenaResetFightRanks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaResetFightRanks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaResetFightRanks;
    })();

    msgProto.ArenaFightStart = (function() {

        /**
         * Properties of an ArenaFightStart.
         * @memberof msgProto
         * @interface IArenaFightStart
         * @property {string|null} [rank] ArenaFightStart rank
         */

        /**
         * Constructs a new ArenaFightStart.
         * @memberof msgProto
         * @classdesc Represents an ArenaFightStart.
         * @implements IArenaFightStart
         * @constructor
         * @param {msgProto.IArenaFightStart=} [properties] Properties to set
         */
        function ArenaFightStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaFightStart rank.
         * @member {string} rank
         * @memberof msgProto.ArenaFightStart
         * @instance
         */
        ArenaFightStart.prototype.rank = "";

        /**
         * Creates a new ArenaFightStart instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {msgProto.IArenaFightStart=} [properties] Properties to set
         * @returns {msgProto.ArenaFightStart} ArenaFightStart instance
         */
        ArenaFightStart.create = function create(properties) {
            return new ArenaFightStart(properties);
        };

        /**
         * Encodes the specified ArenaFightStart message. Does not implicitly {@link msgProto.ArenaFightStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {msgProto.IArenaFightStart} message ArenaFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rank != null && message.hasOwnProperty("rank"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rank);
            return writer;
        };

        /**
         * Encodes the specified ArenaFightStart message, length delimited. Does not implicitly {@link msgProto.ArenaFightStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {msgProto.IArenaFightStart} message ArenaFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaFightStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaFightStart} ArenaFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaFightStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaFightStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaFightStart} ArenaFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaFightStart message.
         * @function verify
         * @memberof msgProto.ArenaFightStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaFightStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isString(message.rank))
                    return "rank: string expected";
            return null;
        };

        return ArenaFightStart;
    })();

    msgProto.ArenaFightEnd = (function() {

        /**
         * Properties of an ArenaFightEnd.
         * @memberof msgProto
         * @interface IArenaFightEnd
         * @property {string|null} [rank] ArenaFightEnd rank
         * @property {number|null} [isWin] ArenaFightEnd isWin
         * @property {string|null} [fightData] ArenaFightEnd fightData
         */

        /**
         * Constructs a new ArenaFightEnd.
         * @memberof msgProto
         * @classdesc Represents an ArenaFightEnd.
         * @implements IArenaFightEnd
         * @constructor
         * @param {msgProto.IArenaFightEnd=} [properties] Properties to set
         */
        function ArenaFightEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaFightEnd rank.
         * @member {string} rank
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.rank = "";

        /**
         * ArenaFightEnd isWin.
         * @member {number} isWin
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.isWin = 0;

        /**
         * ArenaFightEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.ArenaFightEnd
         * @instance
         */
        ArenaFightEnd.prototype.fightData = "";

        /**
         * Creates a new ArenaFightEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {msgProto.IArenaFightEnd=} [properties] Properties to set
         * @returns {msgProto.ArenaFightEnd} ArenaFightEnd instance
         */
        ArenaFightEnd.create = function create(properties) {
            return new ArenaFightEnd(properties);
        };

        /**
         * Encodes the specified ArenaFightEnd message. Does not implicitly {@link msgProto.ArenaFightEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {msgProto.IArenaFightEnd} message ArenaFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rank != null && message.hasOwnProperty("rank"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rank);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isWin);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Encodes the specified ArenaFightEnd message, length delimited. Does not implicitly {@link msgProto.ArenaFightEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {msgProto.IArenaFightEnd} message ArenaFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaFightEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaFightEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaFightEnd} ArenaFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaFightEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rank = reader.string();
                    break;
                case 2:
                    message.isWin = reader.int32();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaFightEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaFightEnd} ArenaFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaFightEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaFightEnd message.
         * @function verify
         * @memberof msgProto.ArenaFightEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaFightEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isString(message.rank))
                    return "rank: string expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (!$util.isInteger(message.isWin))
                    return "isWin: integer expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            return null;
        };

        return ArenaFightEnd;
    })();

    msgProto.ArenaGetFightUserList = (function() {

        /**
         * Properties of an ArenaGetFightUserList.
         * @memberof msgProto
         * @interface IArenaGetFightUserList
         */

        /**
         * Constructs a new ArenaGetFightUserList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetFightUserList.
         * @implements IArenaGetFightUserList
         * @constructor
         * @param {msgProto.IArenaGetFightUserList=} [properties] Properties to set
         */
        function ArenaGetFightUserList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaGetFightUserList instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {msgProto.IArenaGetFightUserList=} [properties] Properties to set
         * @returns {msgProto.ArenaGetFightUserList} ArenaGetFightUserList instance
         */
        ArenaGetFightUserList.create = function create(properties) {
            return new ArenaGetFightUserList(properties);
        };

        /**
         * Encodes the specified ArenaGetFightUserList message. Does not implicitly {@link msgProto.ArenaGetFightUserList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {msgProto.IArenaGetFightUserList} message ArenaGetFightUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetFightUserList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaGetFightUserList message, length delimited. Does not implicitly {@link msgProto.ArenaGetFightUserList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {msgProto.IArenaGetFightUserList} message ArenaGetFightUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetFightUserList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaGetFightUserList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetFightUserList} ArenaGetFightUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetFightUserList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetFightUserList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaGetFightUserList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaGetFightUserList} ArenaGetFightUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetFightUserList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaGetFightUserList message.
         * @function verify
         * @memberof msgProto.ArenaGetFightUserList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaGetFightUserList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaGetFightUserList;
    })();

    msgProto.ArenaBuyPKNum = (function() {

        /**
         * Properties of an ArenaBuyPKNum.
         * @memberof msgProto
         * @interface IArenaBuyPKNum
         */

        /**
         * Constructs a new ArenaBuyPKNum.
         * @memberof msgProto
         * @classdesc Represents an ArenaBuyPKNum.
         * @implements IArenaBuyPKNum
         * @constructor
         * @param {msgProto.IArenaBuyPKNum=} [properties] Properties to set
         */
        function ArenaBuyPKNum(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaBuyPKNum instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {msgProto.IArenaBuyPKNum=} [properties] Properties to set
         * @returns {msgProto.ArenaBuyPKNum} ArenaBuyPKNum instance
         */
        ArenaBuyPKNum.create = function create(properties) {
            return new ArenaBuyPKNum(properties);
        };

        /**
         * Encodes the specified ArenaBuyPKNum message. Does not implicitly {@link msgProto.ArenaBuyPKNum.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {msgProto.IArenaBuyPKNum} message ArenaBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaBuyPKNum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaBuyPKNum message, length delimited. Does not implicitly {@link msgProto.ArenaBuyPKNum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {msgProto.IArenaBuyPKNum} message ArenaBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaBuyPKNum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaBuyPKNum message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaBuyPKNum} ArenaBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaBuyPKNum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaBuyPKNum();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaBuyPKNum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaBuyPKNum} ArenaBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaBuyPKNum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaBuyPKNum message.
         * @function verify
         * @memberof msgProto.ArenaBuyPKNum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaBuyPKNum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaBuyPKNum;
    })();

    msgProto.ArenaGetRecordList = (function() {

        /**
         * Properties of an ArenaGetRecordList.
         * @memberof msgProto
         * @interface IArenaGetRecordList
         * @property {number|null} [index] ArenaGetRecordList index
         * @property {number|null} [coun] ArenaGetRecordList coun
         */

        /**
         * Constructs a new ArenaGetRecordList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRecordList.
         * @implements IArenaGetRecordList
         * @constructor
         * @param {msgProto.IArenaGetRecordList=} [properties] Properties to set
         */
        function ArenaGetRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArenaGetRecordList index.
         * @member {number} index
         * @memberof msgProto.ArenaGetRecordList
         * @instance
         */
        ArenaGetRecordList.prototype.index = 0;

        /**
         * ArenaGetRecordList coun.
         * @member {number} coun
         * @memberof msgProto.ArenaGetRecordList
         * @instance
         */
        ArenaGetRecordList.prototype.coun = 0;

        /**
         * Creates a new ArenaGetRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {msgProto.IArenaGetRecordList=} [properties] Properties to set
         * @returns {msgProto.ArenaGetRecordList} ArenaGetRecordList instance
         */
        ArenaGetRecordList.create = function create(properties) {
            return new ArenaGetRecordList(properties);
        };

        /**
         * Encodes the specified ArenaGetRecordList message. Does not implicitly {@link msgProto.ArenaGetRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {msgProto.IArenaGetRecordList} message ArenaGetRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.coun != null && message.hasOwnProperty("coun"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.coun);
            return writer;
        };

        /**
         * Encodes the specified ArenaGetRecordList message, length delimited. Does not implicitly {@link msgProto.ArenaGetRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {msgProto.IArenaGetRecordList} message ArenaGetRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaGetRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRecordList} ArenaGetRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.coun = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaGetRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaGetRecordList} ArenaGetRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaGetRecordList message.
         * @function verify
         * @memberof msgProto.ArenaGetRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaGetRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.coun != null && message.hasOwnProperty("coun"))
                if (!$util.isInteger(message.coun))
                    return "coun: integer expected";
            return null;
        };

        return ArenaGetRecordList;
    })();

    msgProto.ArenaSetRead = (function() {

        /**
         * Properties of an ArenaSetRead.
         * @memberof msgProto
         * @interface IArenaSetRead
         */

        /**
         * Constructs a new ArenaSetRead.
         * @memberof msgProto
         * @classdesc Represents an ArenaSetRead.
         * @implements IArenaSetRead
         * @constructor
         * @param {msgProto.IArenaSetRead=} [properties] Properties to set
         */
        function ArenaSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaSetRead instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {msgProto.IArenaSetRead=} [properties] Properties to set
         * @returns {msgProto.ArenaSetRead} ArenaSetRead instance
         */
        ArenaSetRead.create = function create(properties) {
            return new ArenaSetRead(properties);
        };

        /**
         * Encodes the specified ArenaSetRead message. Does not implicitly {@link msgProto.ArenaSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {msgProto.IArenaSetRead} message ArenaSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaSetRead message, length delimited. Does not implicitly {@link msgProto.ArenaSetRead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {msgProto.IArenaSetRead} message ArenaSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaSetRead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaSetRead} ArenaSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaSetRead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaSetRead} ArenaSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaSetRead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaSetRead message.
         * @function verify
         * @memberof msgProto.ArenaSetRead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaSetRead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaSetRead;
    })();

    msgProto.ArenaPickRankAward = (function() {

        /**
         * Properties of an ArenaPickRankAward.
         * @memberof msgProto
         * @interface IArenaPickRankAward
         */

        /**
         * Constructs a new ArenaPickRankAward.
         * @memberof msgProto
         * @classdesc Represents an ArenaPickRankAward.
         * @implements IArenaPickRankAward
         * @constructor
         * @param {msgProto.IArenaPickRankAward=} [properties] Properties to set
         */
        function ArenaPickRankAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaPickRankAward instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {msgProto.IArenaPickRankAward=} [properties] Properties to set
         * @returns {msgProto.ArenaPickRankAward} ArenaPickRankAward instance
         */
        ArenaPickRankAward.create = function create(properties) {
            return new ArenaPickRankAward(properties);
        };

        /**
         * Encodes the specified ArenaPickRankAward message. Does not implicitly {@link msgProto.ArenaPickRankAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {msgProto.IArenaPickRankAward} message ArenaPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaPickRankAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaPickRankAward message, length delimited. Does not implicitly {@link msgProto.ArenaPickRankAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {msgProto.IArenaPickRankAward} message ArenaPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaPickRankAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaPickRankAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaPickRankAward} ArenaPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaPickRankAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaPickRankAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaPickRankAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaPickRankAward} ArenaPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaPickRankAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaPickRankAward message.
         * @function verify
         * @memberof msgProto.ArenaPickRankAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaPickRankAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaPickRankAward;
    })();

    msgProto.ArenaRefreshCD = (function() {

        /**
         * Properties of an ArenaRefreshCD.
         * @memberof msgProto
         * @interface IArenaRefreshCD
         */

        /**
         * Constructs a new ArenaRefreshCD.
         * @memberof msgProto
         * @classdesc Represents an ArenaRefreshCD.
         * @implements IArenaRefreshCD
         * @constructor
         * @param {msgProto.IArenaRefreshCD=} [properties] Properties to set
         */
        function ArenaRefreshCD(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaRefreshCD instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {msgProto.IArenaRefreshCD=} [properties] Properties to set
         * @returns {msgProto.ArenaRefreshCD} ArenaRefreshCD instance
         */
        ArenaRefreshCD.create = function create(properties) {
            return new ArenaRefreshCD(properties);
        };

        /**
         * Encodes the specified ArenaRefreshCD message. Does not implicitly {@link msgProto.ArenaRefreshCD.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {msgProto.IArenaRefreshCD} message ArenaRefreshCD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaRefreshCD.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaRefreshCD message, length delimited. Does not implicitly {@link msgProto.ArenaRefreshCD.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {msgProto.IArenaRefreshCD} message ArenaRefreshCD message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaRefreshCD.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaRefreshCD message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaRefreshCD} ArenaRefreshCD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaRefreshCD.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaRefreshCD();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaRefreshCD message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaRefreshCD} ArenaRefreshCD
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaRefreshCD.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaRefreshCD message.
         * @function verify
         * @memberof msgProto.ArenaRefreshCD
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaRefreshCD.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaRefreshCD;
    })();

    msgProto.ArenaGetRankList = (function() {

        /**
         * Properties of an ArenaGetRankList.
         * @memberof msgProto
         * @interface IArenaGetRankList
         */

        /**
         * Constructs a new ArenaGetRankList.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRankList.
         * @implements IArenaGetRankList
         * @constructor
         * @param {msgProto.IArenaGetRankList=} [properties] Properties to set
         */
        function ArenaGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaGetRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {msgProto.IArenaGetRankList=} [properties] Properties to set
         * @returns {msgProto.ArenaGetRankList} ArenaGetRankList instance
         */
        ArenaGetRankList.create = function create(properties) {
            return new ArenaGetRankList(properties);
        };

        /**
         * Encodes the specified ArenaGetRankList message. Does not implicitly {@link msgProto.ArenaGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {msgProto.IArenaGetRankList} message ArenaGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaGetRankList message, length delimited. Does not implicitly {@link msgProto.ArenaGetRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {msgProto.IArenaGetRankList} message ArenaGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRankList} ArenaGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaGetRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaGetRankList} ArenaGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaGetRankList message.
         * @function verify
         * @memberof msgProto.ArenaGetRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaGetRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaGetRankList;
    })();

    msgProto.ArenaGetRefreshRemainTime = (function() {

        /**
         * Properties of an ArenaGetRefreshRemainTime.
         * @memberof msgProto
         * @interface IArenaGetRefreshRemainTime
         */

        /**
         * Constructs a new ArenaGetRefreshRemainTime.
         * @memberof msgProto
         * @classdesc Represents an ArenaGetRefreshRemainTime.
         * @implements IArenaGetRefreshRemainTime
         * @constructor
         * @param {msgProto.IArenaGetRefreshRemainTime=} [properties] Properties to set
         */
        function ArenaGetRefreshRemainTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ArenaGetRefreshRemainTime instance using the specified properties.
         * @function create
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {msgProto.IArenaGetRefreshRemainTime=} [properties] Properties to set
         * @returns {msgProto.ArenaGetRefreshRemainTime} ArenaGetRefreshRemainTime instance
         */
        ArenaGetRefreshRemainTime.create = function create(properties) {
            return new ArenaGetRefreshRemainTime(properties);
        };

        /**
         * Encodes the specified ArenaGetRefreshRemainTime message. Does not implicitly {@link msgProto.ArenaGetRefreshRemainTime.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {msgProto.IArenaGetRefreshRemainTime} message ArenaGetRefreshRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRefreshRemainTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ArenaGetRefreshRemainTime message, length delimited. Does not implicitly {@link msgProto.ArenaGetRefreshRemainTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {msgProto.IArenaGetRefreshRemainTime} message ArenaGetRefreshRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArenaGetRefreshRemainTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArenaGetRefreshRemainTime message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ArenaGetRefreshRemainTime} ArenaGetRefreshRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRefreshRemainTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ArenaGetRefreshRemainTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArenaGetRefreshRemainTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ArenaGetRefreshRemainTime} ArenaGetRefreshRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArenaGetRefreshRemainTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArenaGetRefreshRemainTime message.
         * @function verify
         * @memberof msgProto.ArenaGetRefreshRemainTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArenaGetRefreshRemainTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ArenaGetRefreshRemainTime;
    })();

    msgProto.BonusGetInfo = (function() {

        /**
         * Properties of a BonusGetInfo.
         * @memberof msgProto
         * @interface IBonusGetInfo
         * @property {number|null} [lastId] BonusGetInfo lastId
         */

        /**
         * Constructs a new BonusGetInfo.
         * @memberof msgProto
         * @classdesc Represents a BonusGetInfo.
         * @implements IBonusGetInfo
         * @constructor
         * @param {msgProto.IBonusGetInfo=} [properties] Properties to set
         */
        function BonusGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusGetInfo lastId.
         * @member {number} lastId
         * @memberof msgProto.BonusGetInfo
         * @instance
         */
        BonusGetInfo.prototype.lastId = 0;

        /**
         * Creates a new BonusGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {msgProto.IBonusGetInfo=} [properties] Properties to set
         * @returns {msgProto.BonusGetInfo} BonusGetInfo instance
         */
        BonusGetInfo.create = function create(properties) {
            return new BonusGetInfo(properties);
        };

        /**
         * Encodes the specified BonusGetInfo message. Does not implicitly {@link msgProto.BonusGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {msgProto.IBonusGetInfo} message BonusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Encodes the specified BonusGetInfo message, length delimited. Does not implicitly {@link msgProto.BonusGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {msgProto.IBonusGetInfo} message BonusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusGetInfo} BonusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BonusGetInfo} BonusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusGetInfo message.
         * @function verify
         * @memberof msgProto.BonusGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            return null;
        };

        return BonusGetInfo;
    })();

    msgProto.BonusBreakRelation = (function() {

        /**
         * Properties of a BonusBreakRelation.
         * @memberof msgProto
         * @interface IBonusBreakRelation
         * @property {number|Long|null} [inviteeUserId] BonusBreakRelation inviteeUserId
         */

        /**
         * Constructs a new BonusBreakRelation.
         * @memberof msgProto
         * @classdesc Represents a BonusBreakRelation.
         * @implements IBonusBreakRelation
         * @constructor
         * @param {msgProto.IBonusBreakRelation=} [properties] Properties to set
         */
        function BonusBreakRelation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusBreakRelation inviteeUserId.
         * @member {number|Long} inviteeUserId
         * @memberof msgProto.BonusBreakRelation
         * @instance
         */
        BonusBreakRelation.prototype.inviteeUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new BonusBreakRelation instance using the specified properties.
         * @function create
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {msgProto.IBonusBreakRelation=} [properties] Properties to set
         * @returns {msgProto.BonusBreakRelation} BonusBreakRelation instance
         */
        BonusBreakRelation.create = function create(properties) {
            return new BonusBreakRelation(properties);
        };

        /**
         * Encodes the specified BonusBreakRelation message. Does not implicitly {@link msgProto.BonusBreakRelation.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {msgProto.IBonusBreakRelation} message BonusBreakRelation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusBreakRelation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inviteeUserId != null && message.hasOwnProperty("inviteeUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inviteeUserId);
            return writer;
        };

        /**
         * Encodes the specified BonusBreakRelation message, length delimited. Does not implicitly {@link msgProto.BonusBreakRelation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {msgProto.IBonusBreakRelation} message BonusBreakRelation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusBreakRelation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusBreakRelation message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusBreakRelation} BonusBreakRelation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusBreakRelation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusBreakRelation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.inviteeUserId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusBreakRelation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BonusBreakRelation} BonusBreakRelation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusBreakRelation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusBreakRelation message.
         * @function verify
         * @memberof msgProto.BonusBreakRelation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusBreakRelation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inviteeUserId != null && message.hasOwnProperty("inviteeUserId"))
                if (!$util.isInteger(message.inviteeUserId) && !(message.inviteeUserId && $util.isInteger(message.inviteeUserId.low) && $util.isInteger(message.inviteeUserId.high)))
                    return "inviteeUserId: integer|Long expected";
            return null;
        };

        return BonusBreakRelation;
    })();

    msgProto.BonusShare = (function() {

        /**
         * Properties of a BonusShare.
         * @memberof msgProto
         * @interface IBonusShare
         * @property {number|null} [serverIndexId] BonusShare serverIndexId
         */

        /**
         * Constructs a new BonusShare.
         * @memberof msgProto
         * @classdesc Represents a BonusShare.
         * @implements IBonusShare
         * @constructor
         * @param {msgProto.IBonusShare=} [properties] Properties to set
         */
        function BonusShare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusShare serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.BonusShare
         * @instance
         */
        BonusShare.prototype.serverIndexId = 0;

        /**
         * Creates a new BonusShare instance using the specified properties.
         * @function create
         * @memberof msgProto.BonusShare
         * @static
         * @param {msgProto.IBonusShare=} [properties] Properties to set
         * @returns {msgProto.BonusShare} BonusShare instance
         */
        BonusShare.create = function create(properties) {
            return new BonusShare(properties);
        };

        /**
         * Encodes the specified BonusShare message. Does not implicitly {@link msgProto.BonusShare.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusShare
         * @static
         * @param {msgProto.IBonusShare} message BonusShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusShare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverIndexId);
            return writer;
        };

        /**
         * Encodes the specified BonusShare message, length delimited. Does not implicitly {@link msgProto.BonusShare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BonusShare
         * @static
         * @param {msgProto.IBonusShare} message BonusShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusShare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusShare message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusShare} BonusShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusShare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusShare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverIndexId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusShare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BonusShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BonusShare} BonusShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusShare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusShare message.
         * @function verify
         * @memberof msgProto.BonusShare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusShare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                if (!$util.isInteger(message.serverIndexId))
                    return "serverIndexId: integer expected";
            return null;
        };

        return BonusShare;
    })();

    msgProto.BonusDraw = (function() {

        /**
         * Properties of a BonusDraw.
         * @memberof msgProto
         * @interface IBonusDraw
         */

        /**
         * Constructs a new BonusDraw.
         * @memberof msgProto
         * @classdesc Represents a BonusDraw.
         * @implements IBonusDraw
         * @constructor
         * @param {msgProto.IBonusDraw=} [properties] Properties to set
         */
        function BonusDraw(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BonusDraw instance using the specified properties.
         * @function create
         * @memberof msgProto.BonusDraw
         * @static
         * @param {msgProto.IBonusDraw=} [properties] Properties to set
         * @returns {msgProto.BonusDraw} BonusDraw instance
         */
        BonusDraw.create = function create(properties) {
            return new BonusDraw(properties);
        };

        /**
         * Encodes the specified BonusDraw message. Does not implicitly {@link msgProto.BonusDraw.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusDraw
         * @static
         * @param {msgProto.IBonusDraw} message BonusDraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusDraw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BonusDraw message, length delimited. Does not implicitly {@link msgProto.BonusDraw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BonusDraw
         * @static
         * @param {msgProto.IBonusDraw} message BonusDraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusDraw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusDraw message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusDraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusDraw} BonusDraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusDraw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusDraw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusDraw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BonusDraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BonusDraw} BonusDraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusDraw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusDraw message.
         * @function verify
         * @memberof msgProto.BonusDraw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusDraw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BonusDraw;
    })();

    msgProto.BonusSendShareGift = (function() {

        /**
         * Properties of a BonusSendShareGift.
         * @memberof msgProto
         * @interface IBonusSendShareGift
         */

        /**
         * Constructs a new BonusSendShareGift.
         * @memberof msgProto
         * @classdesc Represents a BonusSendShareGift.
         * @implements IBonusSendShareGift
         * @constructor
         * @param {msgProto.IBonusSendShareGift=} [properties] Properties to set
         */
        function BonusSendShareGift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BonusSendShareGift instance using the specified properties.
         * @function create
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {msgProto.IBonusSendShareGift=} [properties] Properties to set
         * @returns {msgProto.BonusSendShareGift} BonusSendShareGift instance
         */
        BonusSendShareGift.create = function create(properties) {
            return new BonusSendShareGift(properties);
        };

        /**
         * Encodes the specified BonusSendShareGift message. Does not implicitly {@link msgProto.BonusSendShareGift.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {msgProto.IBonusSendShareGift} message BonusSendShareGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusSendShareGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BonusSendShareGift message, length delimited. Does not implicitly {@link msgProto.BonusSendShareGift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {msgProto.IBonusSendShareGift} message BonusSendShareGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusSendShareGift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusSendShareGift message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BonusSendShareGift} BonusSendShareGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusSendShareGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BonusSendShareGift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusSendShareGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BonusSendShareGift} BonusSendShareGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusSendShareGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusSendShareGift message.
         * @function verify
         * @memberof msgProto.BonusSendShareGift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusSendShareGift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BonusSendShareGift;
    })();

    msgProto.BossGetGuildBossList = (function() {

        /**
         * Properties of a BossGetGuildBossList.
         * @memberof msgProto
         * @interface IBossGetGuildBossList
         */

        /**
         * Constructs a new BossGetGuildBossList.
         * @memberof msgProto
         * @classdesc Represents a BossGetGuildBossList.
         * @implements IBossGetGuildBossList
         * @constructor
         * @param {msgProto.IBossGetGuildBossList=} [properties] Properties to set
         */
        function BossGetGuildBossList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BossGetGuildBossList instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {msgProto.IBossGetGuildBossList=} [properties] Properties to set
         * @returns {msgProto.BossGetGuildBossList} BossGetGuildBossList instance
         */
        BossGetGuildBossList.create = function create(properties) {
            return new BossGetGuildBossList(properties);
        };

        /**
         * Encodes the specified BossGetGuildBossList message. Does not implicitly {@link msgProto.BossGetGuildBossList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {msgProto.IBossGetGuildBossList} message BossGetGuildBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetGuildBossList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BossGetGuildBossList message, length delimited. Does not implicitly {@link msgProto.BossGetGuildBossList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {msgProto.IBossGetGuildBossList} message BossGetGuildBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetGuildBossList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetGuildBossList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetGuildBossList} BossGetGuildBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetGuildBossList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetGuildBossList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetGuildBossList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetGuildBossList} BossGetGuildBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetGuildBossList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetGuildBossList message.
         * @function verify
         * @memberof msgProto.BossGetGuildBossList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetGuildBossList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BossGetGuildBossList;
    })();

    msgProto.BossGetWorldBossList = (function() {

        /**
         * Properties of a BossGetWorldBossList.
         * @memberof msgProto
         * @interface IBossGetWorldBossList
         */

        /**
         * Constructs a new BossGetWorldBossList.
         * @memberof msgProto
         * @classdesc Represents a BossGetWorldBossList.
         * @implements IBossGetWorldBossList
         * @constructor
         * @param {msgProto.IBossGetWorldBossList=} [properties] Properties to set
         */
        function BossGetWorldBossList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BossGetWorldBossList instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {msgProto.IBossGetWorldBossList=} [properties] Properties to set
         * @returns {msgProto.BossGetWorldBossList} BossGetWorldBossList instance
         */
        BossGetWorldBossList.create = function create(properties) {
            return new BossGetWorldBossList(properties);
        };

        /**
         * Encodes the specified BossGetWorldBossList message. Does not implicitly {@link msgProto.BossGetWorldBossList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {msgProto.IBossGetWorldBossList} message BossGetWorldBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetWorldBossList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BossGetWorldBossList message, length delimited. Does not implicitly {@link msgProto.BossGetWorldBossList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {msgProto.IBossGetWorldBossList} message BossGetWorldBossList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetWorldBossList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetWorldBossList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetWorldBossList} BossGetWorldBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetWorldBossList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetWorldBossList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetWorldBossList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetWorldBossList} BossGetWorldBossList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetWorldBossList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetWorldBossList message.
         * @function verify
         * @memberof msgProto.BossGetWorldBossList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetWorldBossList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BossGetWorldBossList;
    })();

    msgProto.BossOpenBoss = (function() {

        /**
         * Properties of a BossOpenBoss.
         * @memberof msgProto
         * @interface IBossOpenBoss
         * @property {number|null} [bossId] BossOpenBoss bossId
         * @property {number|null} [isLock] BossOpenBoss isLock
         */

        /**
         * Constructs a new BossOpenBoss.
         * @memberof msgProto
         * @classdesc Represents a BossOpenBoss.
         * @implements IBossOpenBoss
         * @constructor
         * @param {msgProto.IBossOpenBoss=} [properties] Properties to set
         */
        function BossOpenBoss(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossOpenBoss bossId.
         * @member {number} bossId
         * @memberof msgProto.BossOpenBoss
         * @instance
         */
        BossOpenBoss.prototype.bossId = 0;

        /**
         * BossOpenBoss isLock.
         * @member {number} isLock
         * @memberof msgProto.BossOpenBoss
         * @instance
         */
        BossOpenBoss.prototype.isLock = 0;

        /**
         * Creates a new BossOpenBoss instance using the specified properties.
         * @function create
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {msgProto.IBossOpenBoss=} [properties] Properties to set
         * @returns {msgProto.BossOpenBoss} BossOpenBoss instance
         */
        BossOpenBoss.create = function create(properties) {
            return new BossOpenBoss(properties);
        };

        /**
         * Encodes the specified BossOpenBoss message. Does not implicitly {@link msgProto.BossOpenBoss.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {msgProto.IBossOpenBoss} message BossOpenBoss message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossOpenBoss.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.isLock != null && message.hasOwnProperty("isLock"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isLock);
            return writer;
        };

        /**
         * Encodes the specified BossOpenBoss message, length delimited. Does not implicitly {@link msgProto.BossOpenBoss.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {msgProto.IBossOpenBoss} message BossOpenBoss message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossOpenBoss.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossOpenBoss message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossOpenBoss} BossOpenBoss
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossOpenBoss.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossOpenBoss();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.isLock = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossOpenBoss message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossOpenBoss} BossOpenBoss
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossOpenBoss.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossOpenBoss message.
         * @function verify
         * @memberof msgProto.BossOpenBoss
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossOpenBoss.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            if (message.isLock != null && message.hasOwnProperty("isLock"))
                if (!$util.isInteger(message.isLock))
                    return "isLock: integer expected";
            return null;
        };

        return BossOpenBoss;
    })();

    msgProto.BossEnter = (function() {

        /**
         * Properties of a BossEnter.
         * @memberof msgProto
         * @interface IBossEnter
         * @property {number|null} [bossId] BossEnter bossId
         */

        /**
         * Constructs a new BossEnter.
         * @memberof msgProto
         * @classdesc Represents a BossEnter.
         * @implements IBossEnter
         * @constructor
         * @param {msgProto.IBossEnter=} [properties] Properties to set
         */
        function BossEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossEnter bossId.
         * @member {number} bossId
         * @memberof msgProto.BossEnter
         * @instance
         */
        BossEnter.prototype.bossId = 0;

        /**
         * Creates a new BossEnter instance using the specified properties.
         * @function create
         * @memberof msgProto.BossEnter
         * @static
         * @param {msgProto.IBossEnter=} [properties] Properties to set
         * @returns {msgProto.BossEnter} BossEnter instance
         */
        BossEnter.create = function create(properties) {
            return new BossEnter(properties);
        };

        /**
         * Encodes the specified BossEnter message. Does not implicitly {@link msgProto.BossEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossEnter
         * @static
         * @param {msgProto.IBossEnter} message BossEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossEnter message, length delimited. Does not implicitly {@link msgProto.BossEnter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossEnter
         * @static
         * @param {msgProto.IBossEnter} message BossEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossEnter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossEnter} BossEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossEnter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossEnter} BossEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossEnter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossEnter message.
         * @function verify
         * @memberof msgProto.BossEnter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossEnter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossEnter;
    })();

    msgProto.BossStartFight = (function() {

        /**
         * Properties of a BossStartFight.
         * @memberof msgProto
         * @interface IBossStartFight
         * @property {number|null} [bossId] BossStartFight bossId
         */

        /**
         * Constructs a new BossStartFight.
         * @memberof msgProto
         * @classdesc Represents a BossStartFight.
         * @implements IBossStartFight
         * @constructor
         * @param {msgProto.IBossStartFight=} [properties] Properties to set
         */
        function BossStartFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossStartFight bossId.
         * @member {number} bossId
         * @memberof msgProto.BossStartFight
         * @instance
         */
        BossStartFight.prototype.bossId = 0;

        /**
         * Creates a new BossStartFight instance using the specified properties.
         * @function create
         * @memberof msgProto.BossStartFight
         * @static
         * @param {msgProto.IBossStartFight=} [properties] Properties to set
         * @returns {msgProto.BossStartFight} BossStartFight instance
         */
        BossStartFight.create = function create(properties) {
            return new BossStartFight(properties);
        };

        /**
         * Encodes the specified BossStartFight message. Does not implicitly {@link msgProto.BossStartFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossStartFight
         * @static
         * @param {msgProto.IBossStartFight} message BossStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossStartFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossStartFight message, length delimited. Does not implicitly {@link msgProto.BossStartFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossStartFight
         * @static
         * @param {msgProto.IBossStartFight} message BossStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossStartFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossStartFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossStartFight} BossStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossStartFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossStartFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossStartFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossStartFight} BossStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossStartFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossStartFight message.
         * @function verify
         * @memberof msgProto.BossStartFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossStartFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossStartFight;
    })();

    msgProto.BossHurt = (function() {

        /**
         * Properties of a BossHurt.
         * @memberof msgProto
         * @interface IBossHurt
         * @property {number|null} [bossId] BossHurt bossId
         * @property {string|null} [hurtDic] BossHurt hurtDic
         * @property {number|null} [isEnd] BossHurt isEnd
         * @property {string|null} [mData] BossHurt mData
         * @property {string|null} [hurtArr] BossHurt hurtArr
         */

        /**
         * Constructs a new BossHurt.
         * @memberof msgProto
         * @classdesc Represents a BossHurt.
         * @implements IBossHurt
         * @constructor
         * @param {msgProto.IBossHurt=} [properties] Properties to set
         */
        function BossHurt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossHurt bossId.
         * @member {number} bossId
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.bossId = 0;

        /**
         * BossHurt hurtDic.
         * @member {string} hurtDic
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.hurtDic = "";

        /**
         * BossHurt isEnd.
         * @member {number} isEnd
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.isEnd = 0;

        /**
         * BossHurt mData.
         * @member {string} mData
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.mData = "";

        /**
         * BossHurt hurtArr.
         * @member {string} hurtArr
         * @memberof msgProto.BossHurt
         * @instance
         */
        BossHurt.prototype.hurtArr = "";

        /**
         * Creates a new BossHurt instance using the specified properties.
         * @function create
         * @memberof msgProto.BossHurt
         * @static
         * @param {msgProto.IBossHurt=} [properties] Properties to set
         * @returns {msgProto.BossHurt} BossHurt instance
         */
        BossHurt.create = function create(properties) {
            return new BossHurt(properties);
        };

        /**
         * Encodes the specified BossHurt message. Does not implicitly {@link msgProto.BossHurt.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossHurt
         * @static
         * @param {msgProto.IBossHurt} message BossHurt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossHurt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.hurtDic != null && message.hasOwnProperty("hurtDic"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hurtDic);
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isEnd);
            if (message.mData != null && message.hasOwnProperty("mData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.mData);
            if (message.hurtArr != null && message.hasOwnProperty("hurtArr"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hurtArr);
            return writer;
        };

        /**
         * Encodes the specified BossHurt message, length delimited. Does not implicitly {@link msgProto.BossHurt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossHurt
         * @static
         * @param {msgProto.IBossHurt} message BossHurt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossHurt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossHurt message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossHurt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossHurt} BossHurt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossHurt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossHurt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.hurtDic = reader.string();
                    break;
                case 3:
                    message.isEnd = reader.int32();
                    break;
                case 4:
                    message.mData = reader.string();
                    break;
                case 5:
                    message.hurtArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossHurt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossHurt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossHurt} BossHurt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossHurt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossHurt message.
         * @function verify
         * @memberof msgProto.BossHurt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossHurt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            if (message.hurtDic != null && message.hasOwnProperty("hurtDic"))
                if (!$util.isString(message.hurtDic))
                    return "hurtDic: string expected";
            if (message.isEnd != null && message.hasOwnProperty("isEnd"))
                if (!$util.isInteger(message.isEnd))
                    return "isEnd: integer expected";
            if (message.mData != null && message.hasOwnProperty("mData"))
                if (!$util.isString(message.mData))
                    return "mData: string expected";
            if (message.hurtArr != null && message.hasOwnProperty("hurtArr"))
                if (!$util.isString(message.hurtArr))
                    return "hurtArr: string expected";
            return null;
        };

        return BossHurt;
    })();

    msgProto.BossExitFight = (function() {

        /**
         * Properties of a BossExitFight.
         * @memberof msgProto
         * @interface IBossExitFight
         * @property {number|null} [bossId] BossExitFight bossId
         */

        /**
         * Constructs a new BossExitFight.
         * @memberof msgProto
         * @classdesc Represents a BossExitFight.
         * @implements IBossExitFight
         * @constructor
         * @param {msgProto.IBossExitFight=} [properties] Properties to set
         */
        function BossExitFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossExitFight bossId.
         * @member {number} bossId
         * @memberof msgProto.BossExitFight
         * @instance
         */
        BossExitFight.prototype.bossId = 0;

        /**
         * Creates a new BossExitFight instance using the specified properties.
         * @function create
         * @memberof msgProto.BossExitFight
         * @static
         * @param {msgProto.IBossExitFight=} [properties] Properties to set
         * @returns {msgProto.BossExitFight} BossExitFight instance
         */
        BossExitFight.create = function create(properties) {
            return new BossExitFight(properties);
        };

        /**
         * Encodes the specified BossExitFight message. Does not implicitly {@link msgProto.BossExitFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossExitFight
         * @static
         * @param {msgProto.IBossExitFight} message BossExitFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossExitFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossExitFight message, length delimited. Does not implicitly {@link msgProto.BossExitFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossExitFight
         * @static
         * @param {msgProto.IBossExitFight} message BossExitFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossExitFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossExitFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossExitFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossExitFight} BossExitFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossExitFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossExitFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossExitFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossExitFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossExitFight} BossExitFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossExitFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossExitFight message.
         * @function verify
         * @memberof msgProto.BossExitFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossExitFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossExitFight;
    })();

    msgProto.BossClearFightCd = (function() {

        /**
         * Properties of a BossClearFightCd.
         * @memberof msgProto
         * @interface IBossClearFightCd
         */

        /**
         * Constructs a new BossClearFightCd.
         * @memberof msgProto
         * @classdesc Represents a BossClearFightCd.
         * @implements IBossClearFightCd
         * @constructor
         * @param {msgProto.IBossClearFightCd=} [properties] Properties to set
         */
        function BossClearFightCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BossClearFightCd instance using the specified properties.
         * @function create
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {msgProto.IBossClearFightCd=} [properties] Properties to set
         * @returns {msgProto.BossClearFightCd} BossClearFightCd instance
         */
        BossClearFightCd.create = function create(properties) {
            return new BossClearFightCd(properties);
        };

        /**
         * Encodes the specified BossClearFightCd message. Does not implicitly {@link msgProto.BossClearFightCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {msgProto.IBossClearFightCd} message BossClearFightCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossClearFightCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BossClearFightCd message, length delimited. Does not implicitly {@link msgProto.BossClearFightCd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {msgProto.IBossClearFightCd} message BossClearFightCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossClearFightCd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossClearFightCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossClearFightCd} BossClearFightCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossClearFightCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossClearFightCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossClearFightCd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossClearFightCd} BossClearFightCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossClearFightCd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossClearFightCd message.
         * @function verify
         * @memberof msgProto.BossClearFightCd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossClearFightCd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BossClearFightCd;
    })();

    msgProto.BossInspire = (function() {

        /**
         * Properties of a BossInspire.
         * @memberof msgProto
         * @interface IBossInspire
         * @property {number|null} [bossId] BossInspire bossId
         */

        /**
         * Constructs a new BossInspire.
         * @memberof msgProto
         * @classdesc Represents a BossInspire.
         * @implements IBossInspire
         * @constructor
         * @param {msgProto.IBossInspire=} [properties] Properties to set
         */
        function BossInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossInspire bossId.
         * @member {number} bossId
         * @memberof msgProto.BossInspire
         * @instance
         */
        BossInspire.prototype.bossId = 0;

        /**
         * Creates a new BossInspire instance using the specified properties.
         * @function create
         * @memberof msgProto.BossInspire
         * @static
         * @param {msgProto.IBossInspire=} [properties] Properties to set
         * @returns {msgProto.BossInspire} BossInspire instance
         */
        BossInspire.create = function create(properties) {
            return new BossInspire(properties);
        };

        /**
         * Encodes the specified BossInspire message. Does not implicitly {@link msgProto.BossInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossInspire
         * @static
         * @param {msgProto.IBossInspire} message BossInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossInspire message, length delimited. Does not implicitly {@link msgProto.BossInspire.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossInspire
         * @static
         * @param {msgProto.IBossInspire} message BossInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossInspire.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossInspire} BossInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossInspire message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossInspire} BossInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossInspire.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossInspire message.
         * @function verify
         * @memberof msgProto.BossInspire
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossInspire.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossInspire;
    })();

    msgProto.BossGetInspireRecordArr = (function() {

        /**
         * Properties of a BossGetInspireRecordArr.
         * @memberof msgProto
         * @interface IBossGetInspireRecordArr
         * @property {number|null} [bossId] BossGetInspireRecordArr bossId
         */

        /**
         * Constructs a new BossGetInspireRecordArr.
         * @memberof msgProto
         * @classdesc Represents a BossGetInspireRecordArr.
         * @implements IBossGetInspireRecordArr
         * @constructor
         * @param {msgProto.IBossGetInspireRecordArr=} [properties] Properties to set
         */
        function BossGetInspireRecordArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetInspireRecordArr bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetInspireRecordArr
         * @instance
         */
        BossGetInspireRecordArr.prototype.bossId = 0;

        /**
         * Creates a new BossGetInspireRecordArr instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {msgProto.IBossGetInspireRecordArr=} [properties] Properties to set
         * @returns {msgProto.BossGetInspireRecordArr} BossGetInspireRecordArr instance
         */
        BossGetInspireRecordArr.create = function create(properties) {
            return new BossGetInspireRecordArr(properties);
        };

        /**
         * Encodes the specified BossGetInspireRecordArr message. Does not implicitly {@link msgProto.BossGetInspireRecordArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {msgProto.IBossGetInspireRecordArr} message BossGetInspireRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetInspireRecordArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossGetInspireRecordArr message, length delimited. Does not implicitly {@link msgProto.BossGetInspireRecordArr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {msgProto.IBossGetInspireRecordArr} message BossGetInspireRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetInspireRecordArr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetInspireRecordArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetInspireRecordArr} BossGetInspireRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetInspireRecordArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetInspireRecordArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetInspireRecordArr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetInspireRecordArr} BossGetInspireRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetInspireRecordArr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetInspireRecordArr message.
         * @function verify
         * @memberof msgProto.BossGetInspireRecordArr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetInspireRecordArr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossGetInspireRecordArr;
    })();

    msgProto.BossSyncInspire = (function() {

        /**
         * Properties of a BossSyncInspire.
         * @memberof msgProto
         * @interface IBossSyncInspire
         * @property {number|null} [bossId] BossSyncInspire bossId
         */

        /**
         * Constructs a new BossSyncInspire.
         * @memberof msgProto
         * @classdesc Represents a BossSyncInspire.
         * @implements IBossSyncInspire
         * @constructor
         * @param {msgProto.IBossSyncInspire=} [properties] Properties to set
         */
        function BossSyncInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossSyncInspire bossId.
         * @member {number} bossId
         * @memberof msgProto.BossSyncInspire
         * @instance
         */
        BossSyncInspire.prototype.bossId = 0;

        /**
         * Creates a new BossSyncInspire instance using the specified properties.
         * @function create
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {msgProto.IBossSyncInspire=} [properties] Properties to set
         * @returns {msgProto.BossSyncInspire} BossSyncInspire instance
         */
        BossSyncInspire.create = function create(properties) {
            return new BossSyncInspire(properties);
        };

        /**
         * Encodes the specified BossSyncInspire message. Does not implicitly {@link msgProto.BossSyncInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {msgProto.IBossSyncInspire} message BossSyncInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossSyncInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossSyncInspire message, length delimited. Does not implicitly {@link msgProto.BossSyncInspire.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {msgProto.IBossSyncInspire} message BossSyncInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossSyncInspire.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossSyncInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossSyncInspire} BossSyncInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossSyncInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossSyncInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossSyncInspire message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossSyncInspire} BossSyncInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossSyncInspire.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossSyncInspire message.
         * @function verify
         * @memberof msgProto.BossSyncInspire
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossSyncInspire.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossSyncInspire;
    })();

    msgProto.BossGetHurtRankList = (function() {

        /**
         * Properties of a BossGetHurtRankList.
         * @memberof msgProto
         * @interface IBossGetHurtRankList
         * @property {number|null} [bossId] BossGetHurtRankList bossId
         */

        /**
         * Constructs a new BossGetHurtRankList.
         * @memberof msgProto
         * @classdesc Represents a BossGetHurtRankList.
         * @implements IBossGetHurtRankList
         * @constructor
         * @param {msgProto.IBossGetHurtRankList=} [properties] Properties to set
         */
        function BossGetHurtRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetHurtRankList bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetHurtRankList
         * @instance
         */
        BossGetHurtRankList.prototype.bossId = 0;

        /**
         * Creates a new BossGetHurtRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {msgProto.IBossGetHurtRankList=} [properties] Properties to set
         * @returns {msgProto.BossGetHurtRankList} BossGetHurtRankList instance
         */
        BossGetHurtRankList.create = function create(properties) {
            return new BossGetHurtRankList(properties);
        };

        /**
         * Encodes the specified BossGetHurtRankList message. Does not implicitly {@link msgProto.BossGetHurtRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {msgProto.IBossGetHurtRankList} message BossGetHurtRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetHurtRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossGetHurtRankList message, length delimited. Does not implicitly {@link msgProto.BossGetHurtRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {msgProto.IBossGetHurtRankList} message BossGetHurtRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetHurtRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetHurtRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetHurtRankList} BossGetHurtRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetHurtRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetHurtRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetHurtRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetHurtRankList} BossGetHurtRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetHurtRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetHurtRankList message.
         * @function verify
         * @memberof msgProto.BossGetHurtRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetHurtRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossGetHurtRankList;
    })();

    msgProto.BossGetFirstHurtRank = (function() {

        /**
         * Properties of a BossGetFirstHurtRank.
         * @memberof msgProto
         * @interface IBossGetFirstHurtRank
         * @property {number|null} [bossId] BossGetFirstHurtRank bossId
         */

        /**
         * Constructs a new BossGetFirstHurtRank.
         * @memberof msgProto
         * @classdesc Represents a BossGetFirstHurtRank.
         * @implements IBossGetFirstHurtRank
         * @constructor
         * @param {msgProto.IBossGetFirstHurtRank=} [properties] Properties to set
         */
        function BossGetFirstHurtRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetFirstHurtRank bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetFirstHurtRank
         * @instance
         */
        BossGetFirstHurtRank.prototype.bossId = 0;

        /**
         * Creates a new BossGetFirstHurtRank instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {msgProto.IBossGetFirstHurtRank=} [properties] Properties to set
         * @returns {msgProto.BossGetFirstHurtRank} BossGetFirstHurtRank instance
         */
        BossGetFirstHurtRank.create = function create(properties) {
            return new BossGetFirstHurtRank(properties);
        };

        /**
         * Encodes the specified BossGetFirstHurtRank message. Does not implicitly {@link msgProto.BossGetFirstHurtRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {msgProto.IBossGetFirstHurtRank} message BossGetFirstHurtRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetFirstHurtRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified BossGetFirstHurtRank message, length delimited. Does not implicitly {@link msgProto.BossGetFirstHurtRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {msgProto.IBossGetFirstHurtRank} message BossGetFirstHurtRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetFirstHurtRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetFirstHurtRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetFirstHurtRank} BossGetFirstHurtRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetFirstHurtRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetFirstHurtRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetFirstHurtRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetFirstHurtRank} BossGetFirstHurtRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetFirstHurtRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetFirstHurtRank message.
         * @function verify
         * @memberof msgProto.BossGetFirstHurtRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetFirstHurtRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return BossGetFirstHurtRank;
    })();

    msgProto.BossGetBossResult = (function() {

        /**
         * Properties of a BossGetBossResult.
         * @memberof msgProto
         * @interface IBossGetBossResult
         * @property {number|null} [bossId] BossGetBossResult bossId
         * @property {number|null} [originBossId] BossGetBossResult originBossId
         */

        /**
         * Constructs a new BossGetBossResult.
         * @memberof msgProto
         * @classdesc Represents a BossGetBossResult.
         * @implements IBossGetBossResult
         * @constructor
         * @param {msgProto.IBossGetBossResult=} [properties] Properties to set
         */
        function BossGetBossResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetBossResult bossId.
         * @member {number} bossId
         * @memberof msgProto.BossGetBossResult
         * @instance
         */
        BossGetBossResult.prototype.bossId = 0;

        /**
         * BossGetBossResult originBossId.
         * @member {number} originBossId
         * @memberof msgProto.BossGetBossResult
         * @instance
         */
        BossGetBossResult.prototype.originBossId = 0;

        /**
         * Creates a new BossGetBossResult instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {msgProto.IBossGetBossResult=} [properties] Properties to set
         * @returns {msgProto.BossGetBossResult} BossGetBossResult instance
         */
        BossGetBossResult.create = function create(properties) {
            return new BossGetBossResult(properties);
        };

        /**
         * Encodes the specified BossGetBossResult message. Does not implicitly {@link msgProto.BossGetBossResult.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {msgProto.IBossGetBossResult} message BossGetBossResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetBossResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.originBossId);
            return writer;
        };

        /**
         * Encodes the specified BossGetBossResult message, length delimited. Does not implicitly {@link msgProto.BossGetBossResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {msgProto.IBossGetBossResult} message BossGetBossResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetBossResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetBossResult message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetBossResult} BossGetBossResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetBossResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetBossResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                case 2:
                    message.originBossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetBossResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetBossResult} BossGetBossResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetBossResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetBossResult message.
         * @function verify
         * @memberof msgProto.BossGetBossResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetBossResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                if (!$util.isInteger(message.originBossId))
                    return "originBossId: integer expected";
            return null;
        };

        return BossGetBossResult;
    })();

    msgProto.BossGetResultData = (function() {

        /**
         * Properties of a BossGetResultData.
         * @memberof msgProto
         * @interface IBossGetResultData
         * @property {number|null} [originBossId] BossGetResultData originBossId
         */

        /**
         * Constructs a new BossGetResultData.
         * @memberof msgProto
         * @classdesc Represents a BossGetResultData.
         * @implements IBossGetResultData
         * @constructor
         * @param {msgProto.IBossGetResultData=} [properties] Properties to set
         */
        function BossGetResultData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BossGetResultData originBossId.
         * @member {number} originBossId
         * @memberof msgProto.BossGetResultData
         * @instance
         */
        BossGetResultData.prototype.originBossId = 0;

        /**
         * Creates a new BossGetResultData instance using the specified properties.
         * @function create
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {msgProto.IBossGetResultData=} [properties] Properties to set
         * @returns {msgProto.BossGetResultData} BossGetResultData instance
         */
        BossGetResultData.create = function create(properties) {
            return new BossGetResultData(properties);
        };

        /**
         * Encodes the specified BossGetResultData message. Does not implicitly {@link msgProto.BossGetResultData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {msgProto.IBossGetResultData} message BossGetResultData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetResultData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.originBossId);
            return writer;
        };

        /**
         * Encodes the specified BossGetResultData message, length delimited. Does not implicitly {@link msgProto.BossGetResultData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {msgProto.IBossGetResultData} message BossGetResultData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BossGetResultData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BossGetResultData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.BossGetResultData} BossGetResultData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetResultData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.BossGetResultData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.originBossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BossGetResultData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.BossGetResultData} BossGetResultData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BossGetResultData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BossGetResultData message.
         * @function verify
         * @memberof msgProto.BossGetResultData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BossGetResultData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originBossId != null && message.hasOwnProperty("originBossId"))
                if (!$util.isInteger(message.originBossId))
                    return "originBossId: integer expected";
            return null;
        };

        return BossGetResultData;
    })();

    msgProto.DemonLotusGetInfo = (function() {

        /**
         * Properties of a DemonLotusGetInfo.
         * @memberof msgProto
         * @interface IDemonLotusGetInfo
         */

        /**
         * Constructs a new DemonLotusGetInfo.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusGetInfo.
         * @implements IDemonLotusGetInfo
         * @constructor
         * @param {msgProto.IDemonLotusGetInfo=} [properties] Properties to set
         */
        function DemonLotusGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {msgProto.IDemonLotusGetInfo=} [properties] Properties to set
         * @returns {msgProto.DemonLotusGetInfo} DemonLotusGetInfo instance
         */
        DemonLotusGetInfo.create = function create(properties) {
            return new DemonLotusGetInfo(properties);
        };

        /**
         * Encodes the specified DemonLotusGetInfo message. Does not implicitly {@link msgProto.DemonLotusGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {msgProto.IDemonLotusGetInfo} message DemonLotusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusGetInfo message, length delimited. Does not implicitly {@link msgProto.DemonLotusGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {msgProto.IDemonLotusGetInfo} message DemonLotusGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusGetInfo} DemonLotusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusGetInfo} DemonLotusGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusGetInfo message.
         * @function verify
         * @memberof msgProto.DemonLotusGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusGetInfo;
    })();

    msgProto.DemonLotusUpLotus = (function() {

        /**
         * Properties of a DemonLotusUpLotus.
         * @memberof msgProto
         * @interface IDemonLotusUpLotus
         */

        /**
         * Constructs a new DemonLotusUpLotus.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusUpLotus.
         * @implements IDemonLotusUpLotus
         * @constructor
         * @param {msgProto.IDemonLotusUpLotus=} [properties] Properties to set
         */
        function DemonLotusUpLotus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusUpLotus instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {msgProto.IDemonLotusUpLotus=} [properties] Properties to set
         * @returns {msgProto.DemonLotusUpLotus} DemonLotusUpLotus instance
         */
        DemonLotusUpLotus.create = function create(properties) {
            return new DemonLotusUpLotus(properties);
        };

        /**
         * Encodes the specified DemonLotusUpLotus message. Does not implicitly {@link msgProto.DemonLotusUpLotus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {msgProto.IDemonLotusUpLotus} message DemonLotusUpLotus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusUpLotus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusUpLotus message, length delimited. Does not implicitly {@link msgProto.DemonLotusUpLotus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {msgProto.IDemonLotusUpLotus} message DemonLotusUpLotus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusUpLotus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusUpLotus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusUpLotus} DemonLotusUpLotus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusUpLotus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusUpLotus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusUpLotus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusUpLotus} DemonLotusUpLotus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusUpLotus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusUpLotus message.
         * @function verify
         * @memberof msgProto.DemonLotusUpLotus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusUpLotus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusUpLotus;
    })();

    msgProto.DemonLotusGetRevenue = (function() {

        /**
         * Properties of a DemonLotusGetRevenue.
         * @memberof msgProto
         * @interface IDemonLotusGetRevenue
         */

        /**
         * Constructs a new DemonLotusGetRevenue.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusGetRevenue.
         * @implements IDemonLotusGetRevenue
         * @constructor
         * @param {msgProto.IDemonLotusGetRevenue=} [properties] Properties to set
         */
        function DemonLotusGetRevenue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusGetRevenue instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {msgProto.IDemonLotusGetRevenue=} [properties] Properties to set
         * @returns {msgProto.DemonLotusGetRevenue} DemonLotusGetRevenue instance
         */
        DemonLotusGetRevenue.create = function create(properties) {
            return new DemonLotusGetRevenue(properties);
        };

        /**
         * Encodes the specified DemonLotusGetRevenue message. Does not implicitly {@link msgProto.DemonLotusGetRevenue.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {msgProto.IDemonLotusGetRevenue} message DemonLotusGetRevenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetRevenue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusGetRevenue message, length delimited. Does not implicitly {@link msgProto.DemonLotusGetRevenue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {msgProto.IDemonLotusGetRevenue} message DemonLotusGetRevenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusGetRevenue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusGetRevenue message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusGetRevenue} DemonLotusGetRevenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetRevenue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusGetRevenue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusGetRevenue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusGetRevenue} DemonLotusGetRevenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusGetRevenue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusGetRevenue message.
         * @function verify
         * @memberof msgProto.DemonLotusGetRevenue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusGetRevenue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusGetRevenue;
    })();

    msgProto.DemonLotusOpening = (function() {

        /**
         * Properties of a DemonLotusOpening.
         * @memberof msgProto
         * @interface IDemonLotusOpening
         */

        /**
         * Constructs a new DemonLotusOpening.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusOpening.
         * @implements IDemonLotusOpening
         * @constructor
         * @param {msgProto.IDemonLotusOpening=} [properties] Properties to set
         */
        function DemonLotusOpening(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusOpening instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {msgProto.IDemonLotusOpening=} [properties] Properties to set
         * @returns {msgProto.DemonLotusOpening} DemonLotusOpening instance
         */
        DemonLotusOpening.create = function create(properties) {
            return new DemonLotusOpening(properties);
        };

        /**
         * Encodes the specified DemonLotusOpening message. Does not implicitly {@link msgProto.DemonLotusOpening.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {msgProto.IDemonLotusOpening} message DemonLotusOpening message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusOpening.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusOpening message, length delimited. Does not implicitly {@link msgProto.DemonLotusOpening.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {msgProto.IDemonLotusOpening} message DemonLotusOpening message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusOpening.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusOpening message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusOpening} DemonLotusOpening
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusOpening.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusOpening();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusOpening message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusOpening} DemonLotusOpening
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusOpening.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusOpening message.
         * @function verify
         * @memberof msgProto.DemonLotusOpening
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusOpening.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusOpening;
    })();

    msgProto.DemonLotusLotusAdvance = (function() {

        /**
         * Properties of a DemonLotusLotusAdvance.
         * @memberof msgProto
         * @interface IDemonLotusLotusAdvance
         */

        /**
         * Constructs a new DemonLotusLotusAdvance.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusLotusAdvance.
         * @implements IDemonLotusLotusAdvance
         * @constructor
         * @param {msgProto.IDemonLotusLotusAdvance=} [properties] Properties to set
         */
        function DemonLotusLotusAdvance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusLotusAdvance instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {msgProto.IDemonLotusLotusAdvance=} [properties] Properties to set
         * @returns {msgProto.DemonLotusLotusAdvance} DemonLotusLotusAdvance instance
         */
        DemonLotusLotusAdvance.create = function create(properties) {
            return new DemonLotusLotusAdvance(properties);
        };

        /**
         * Encodes the specified DemonLotusLotusAdvance message. Does not implicitly {@link msgProto.DemonLotusLotusAdvance.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {msgProto.IDemonLotusLotusAdvance} message DemonLotusLotusAdvance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusLotusAdvance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusLotusAdvance message, length delimited. Does not implicitly {@link msgProto.DemonLotusLotusAdvance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {msgProto.IDemonLotusLotusAdvance} message DemonLotusLotusAdvance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusLotusAdvance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusLotusAdvance message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusLotusAdvance} DemonLotusLotusAdvance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusLotusAdvance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusLotusAdvance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusLotusAdvance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusLotusAdvance} DemonLotusLotusAdvance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusLotusAdvance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusLotusAdvance message.
         * @function verify
         * @memberof msgProto.DemonLotusLotusAdvance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusLotusAdvance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusLotusAdvance;
    })();

    msgProto.DemonLotusTreasureTrain = (function() {

        /**
         * Properties of a DemonLotusTreasureTrain.
         * @memberof msgProto
         * @interface IDemonLotusTreasureTrain
         */

        /**
         * Constructs a new DemonLotusTreasureTrain.
         * @memberof msgProto
         * @classdesc Represents a DemonLotusTreasureTrain.
         * @implements IDemonLotusTreasureTrain
         * @constructor
         * @param {msgProto.IDemonLotusTreasureTrain=} [properties] Properties to set
         */
        function DemonLotusTreasureTrain(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemonLotusTreasureTrain instance using the specified properties.
         * @function create
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {msgProto.IDemonLotusTreasureTrain=} [properties] Properties to set
         * @returns {msgProto.DemonLotusTreasureTrain} DemonLotusTreasureTrain instance
         */
        DemonLotusTreasureTrain.create = function create(properties) {
            return new DemonLotusTreasureTrain(properties);
        };

        /**
         * Encodes the specified DemonLotusTreasureTrain message. Does not implicitly {@link msgProto.DemonLotusTreasureTrain.verify|verify} messages.
         * @function encode
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {msgProto.IDemonLotusTreasureTrain} message DemonLotusTreasureTrain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusTreasureTrain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemonLotusTreasureTrain message, length delimited. Does not implicitly {@link msgProto.DemonLotusTreasureTrain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {msgProto.IDemonLotusTreasureTrain} message DemonLotusTreasureTrain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemonLotusTreasureTrain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemonLotusTreasureTrain message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.DemonLotusTreasureTrain} DemonLotusTreasureTrain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusTreasureTrain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.DemonLotusTreasureTrain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemonLotusTreasureTrain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.DemonLotusTreasureTrain} DemonLotusTreasureTrain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemonLotusTreasureTrain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemonLotusTreasureTrain message.
         * @function verify
         * @memberof msgProto.DemonLotusTreasureTrain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemonLotusTreasureTrain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return DemonLotusTreasureTrain;
    })();

    msgProto.MailGetList = (function() {

        /**
         * Properties of a MailGetList.
         * @memberof msgProto
         * @interface IMailGetList
         */

        /**
         * Constructs a new MailGetList.
         * @memberof msgProto
         * @classdesc Represents a MailGetList.
         * @implements IMailGetList
         * @constructor
         * @param {msgProto.IMailGetList=} [properties] Properties to set
         */
        function MailGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MailGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.MailGetList
         * @static
         * @param {msgProto.IMailGetList=} [properties] Properties to set
         * @returns {msgProto.MailGetList} MailGetList instance
         */
        MailGetList.create = function create(properties) {
            return new MailGetList(properties);
        };

        /**
         * Encodes the specified MailGetList message. Does not implicitly {@link msgProto.MailGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailGetList
         * @static
         * @param {msgProto.IMailGetList} message MailGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MailGetList message, length delimited. Does not implicitly {@link msgProto.MailGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.MailGetList
         * @static
         * @param {msgProto.IMailGetList} message MailGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailGetList} MailGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.MailGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.MailGetList} MailGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailGetList message.
         * @function verify
         * @memberof msgProto.MailGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return MailGetList;
    })();

    msgProto.mailPickItems = (function() {

        /**
         * Properties of a mailPickItems.
         * @memberof msgProto
         * @interface ImailPickItems
         * @property {number|null} [mailId] mailPickItems mailId
         */

        /**
         * Constructs a new mailPickItems.
         * @memberof msgProto
         * @classdesc Represents a mailPickItems.
         * @implements ImailPickItems
         * @constructor
         * @param {msgProto.ImailPickItems=} [properties] Properties to set
         */
        function mailPickItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * mailPickItems mailId.
         * @member {number} mailId
         * @memberof msgProto.mailPickItems
         * @instance
         */
        mailPickItems.prototype.mailId = 0;

        /**
         * Creates a new mailPickItems instance using the specified properties.
         * @function create
         * @memberof msgProto.mailPickItems
         * @static
         * @param {msgProto.ImailPickItems=} [properties] Properties to set
         * @returns {msgProto.mailPickItems} mailPickItems instance
         */
        mailPickItems.create = function create(properties) {
            return new mailPickItems(properties);
        };

        /**
         * Encodes the specified mailPickItems message. Does not implicitly {@link msgProto.mailPickItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.mailPickItems
         * @static
         * @param {msgProto.ImailPickItems} message mailPickItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        mailPickItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Encodes the specified mailPickItems message, length delimited. Does not implicitly {@link msgProto.mailPickItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.mailPickItems
         * @static
         * @param {msgProto.ImailPickItems} message mailPickItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        mailPickItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a mailPickItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.mailPickItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.mailPickItems} mailPickItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        mailPickItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.mailPickItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a mailPickItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.mailPickItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.mailPickItems} mailPickItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        mailPickItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a mailPickItems message.
         * @function verify
         * @memberof msgProto.mailPickItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        mailPickItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                if (!$util.isInteger(message.mailId))
                    return "mailId: integer expected";
            return null;
        };

        return mailPickItems;
    })();

    msgProto.MailPickAllItems = (function() {

        /**
         * Properties of a MailPickAllItems.
         * @memberof msgProto
         * @interface IMailPickAllItems
         */

        /**
         * Constructs a new MailPickAllItems.
         * @memberof msgProto
         * @classdesc Represents a MailPickAllItems.
         * @implements IMailPickAllItems
         * @constructor
         * @param {msgProto.IMailPickAllItems=} [properties] Properties to set
         */
        function MailPickAllItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MailPickAllItems instance using the specified properties.
         * @function create
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {msgProto.IMailPickAllItems=} [properties] Properties to set
         * @returns {msgProto.MailPickAllItems} MailPickAllItems instance
         */
        MailPickAllItems.create = function create(properties) {
            return new MailPickAllItems(properties);
        };

        /**
         * Encodes the specified MailPickAllItems message. Does not implicitly {@link msgProto.MailPickAllItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {msgProto.IMailPickAllItems} message MailPickAllItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailPickAllItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MailPickAllItems message, length delimited. Does not implicitly {@link msgProto.MailPickAllItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {msgProto.IMailPickAllItems} message MailPickAllItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailPickAllItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailPickAllItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailPickAllItems} MailPickAllItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailPickAllItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailPickAllItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailPickAllItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.MailPickAllItems} MailPickAllItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailPickAllItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailPickAllItems message.
         * @function verify
         * @memberof msgProto.MailPickAllItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailPickAllItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return MailPickAllItems;
    })();

    msgProto.MailSetRead = (function() {

        /**
         * Properties of a MailSetRead.
         * @memberof msgProto
         * @interface IMailSetRead
         * @property {number|null} [mailId] MailSetRead mailId
         */

        /**
         * Constructs a new MailSetRead.
         * @memberof msgProto
         * @classdesc Represents a MailSetRead.
         * @implements IMailSetRead
         * @constructor
         * @param {msgProto.IMailSetRead=} [properties] Properties to set
         */
        function MailSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailSetRead mailId.
         * @member {number} mailId
         * @memberof msgProto.MailSetRead
         * @instance
         */
        MailSetRead.prototype.mailId = 0;

        /**
         * Creates a new MailSetRead instance using the specified properties.
         * @function create
         * @memberof msgProto.MailSetRead
         * @static
         * @param {msgProto.IMailSetRead=} [properties] Properties to set
         * @returns {msgProto.MailSetRead} MailSetRead instance
         */
        MailSetRead.create = function create(properties) {
            return new MailSetRead(properties);
        };

        /**
         * Encodes the specified MailSetRead message. Does not implicitly {@link msgProto.MailSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailSetRead
         * @static
         * @param {msgProto.IMailSetRead} message MailSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Encodes the specified MailSetRead message, length delimited. Does not implicitly {@link msgProto.MailSetRead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.MailSetRead
         * @static
         * @param {msgProto.IMailSetRead} message MailSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSetRead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailSetRead} MailSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailSetRead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.MailSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.MailSetRead} MailSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSetRead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailSetRead message.
         * @function verify
         * @memberof msgProto.MailSetRead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailSetRead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                if (!$util.isInteger(message.mailId))
                    return "mailId: integer expected";
            return null;
        };

        return MailSetRead;
    })();

    msgProto.MailGetIsNeedOperate = (function() {

        /**
         * Properties of a MailGetIsNeedOperate.
         * @memberof msgProto
         * @interface IMailGetIsNeedOperate
         * @property {number|null} [mailId] MailGetIsNeedOperate mailId
         */

        /**
         * Constructs a new MailGetIsNeedOperate.
         * @memberof msgProto
         * @classdesc Represents a MailGetIsNeedOperate.
         * @implements IMailGetIsNeedOperate
         * @constructor
         * @param {msgProto.IMailGetIsNeedOperate=} [properties] Properties to set
         */
        function MailGetIsNeedOperate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailGetIsNeedOperate mailId.
         * @member {number} mailId
         * @memberof msgProto.MailGetIsNeedOperate
         * @instance
         */
        MailGetIsNeedOperate.prototype.mailId = 0;

        /**
         * Creates a new MailGetIsNeedOperate instance using the specified properties.
         * @function create
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {msgProto.IMailGetIsNeedOperate=} [properties] Properties to set
         * @returns {msgProto.MailGetIsNeedOperate} MailGetIsNeedOperate instance
         */
        MailGetIsNeedOperate.create = function create(properties) {
            return new MailGetIsNeedOperate(properties);
        };

        /**
         * Encodes the specified MailGetIsNeedOperate message. Does not implicitly {@link msgProto.MailGetIsNeedOperate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {msgProto.IMailGetIsNeedOperate} message MailGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetIsNeedOperate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailId);
            return writer;
        };

        /**
         * Encodes the specified MailGetIsNeedOperate message, length delimited. Does not implicitly {@link msgProto.MailGetIsNeedOperate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {msgProto.IMailGetIsNeedOperate} message MailGetIsNeedOperate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailGetIsNeedOperate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailGetIsNeedOperate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.MailGetIsNeedOperate} MailGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetIsNeedOperate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.MailGetIsNeedOperate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailGetIsNeedOperate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.MailGetIsNeedOperate} MailGetIsNeedOperate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailGetIsNeedOperate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailGetIsNeedOperate message.
         * @function verify
         * @memberof msgProto.MailGetIsNeedOperate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailGetIsNeedOperate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailId != null && message.hasOwnProperty("mailId"))
                if (!$util.isInteger(message.mailId))
                    return "mailId: integer expected";
            return null;
        };

        return MailGetIsNeedOperate;
    })();

    msgProto.EventEventBuy = (function() {

        /**
         * Properties of an EventEventBuy.
         * @memberof msgProto
         * @interface IEventEventBuy
         * @property {number|null} [eventId] EventEventBuy eventId
         */

        /**
         * Constructs a new EventEventBuy.
         * @memberof msgProto
         * @classdesc Represents an EventEventBuy.
         * @implements IEventEventBuy
         * @constructor
         * @param {msgProto.IEventEventBuy=} [properties] Properties to set
         */
        function EventEventBuy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventEventBuy eventId.
         * @member {number} eventId
         * @memberof msgProto.EventEventBuy
         * @instance
         */
        EventEventBuy.prototype.eventId = 0;

        /**
         * Creates a new EventEventBuy instance using the specified properties.
         * @function create
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {msgProto.IEventEventBuy=} [properties] Properties to set
         * @returns {msgProto.EventEventBuy} EventEventBuy instance
         */
        EventEventBuy.create = function create(properties) {
            return new EventEventBuy(properties);
        };

        /**
         * Encodes the specified EventEventBuy message. Does not implicitly {@link msgProto.EventEventBuy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {msgProto.IEventEventBuy} message EventEventBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventEventBuy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventId);
            return writer;
        };

        /**
         * Encodes the specified EventEventBuy message, length delimited. Does not implicitly {@link msgProto.EventEventBuy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {msgProto.IEventEventBuy} message EventEventBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventEventBuy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventEventBuy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EventEventBuy} EventEventBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventEventBuy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EventEventBuy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventEventBuy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EventEventBuy} EventEventBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventEventBuy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventEventBuy message.
         * @function verify
         * @memberof msgProto.EventEventBuy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventEventBuy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                if (!$util.isInteger(message.eventId))
                    return "eventId: integer expected";
            return null;
        };

        return EventEventBuy;
    })();

    msgProto.EquipChangeEquip = (function() {

        /**
         * Properties of an EquipChangeEquip.
         * @memberof msgProto
         * @interface IEquipChangeEquip
         * @property {number|null} [tempId] EquipChangeEquip tempId
         * @property {number|null} [index] EquipChangeEquip index
         * @property {number|null} [equipId] EquipChangeEquip equipId
         */

        /**
         * Constructs a new EquipChangeEquip.
         * @memberof msgProto
         * @classdesc Represents an EquipChangeEquip.
         * @implements IEquipChangeEquip
         * @constructor
         * @param {msgProto.IEquipChangeEquip=} [properties] Properties to set
         */
        function EquipChangeEquip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipChangeEquip tempId.
         * @member {number} tempId
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.tempId = 0;

        /**
         * EquipChangeEquip index.
         * @member {number} index
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.index = 0;

        /**
         * EquipChangeEquip equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipChangeEquip
         * @instance
         */
        EquipChangeEquip.prototype.equipId = 0;

        /**
         * Creates a new EquipChangeEquip instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {msgProto.IEquipChangeEquip=} [properties] Properties to set
         * @returns {msgProto.EquipChangeEquip} EquipChangeEquip instance
         */
        EquipChangeEquip.create = function create(properties) {
            return new EquipChangeEquip(properties);
        };

        /**
         * Encodes the specified EquipChangeEquip message. Does not implicitly {@link msgProto.EquipChangeEquip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {msgProto.IEquipChangeEquip} message EquipChangeEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipChangeEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equipId);
            return writer;
        };

        /**
         * Encodes the specified EquipChangeEquip message, length delimited. Does not implicitly {@link msgProto.EquipChangeEquip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {msgProto.IEquipChangeEquip} message EquipChangeEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipChangeEquip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipChangeEquip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipChangeEquip} EquipChangeEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipChangeEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipChangeEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.equipId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipChangeEquip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipChangeEquip} EquipChangeEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipChangeEquip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipChangeEquip message.
         * @function verify
         * @memberof msgProto.EquipChangeEquip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipChangeEquip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                if (!$util.isInteger(message.equipId))
                    return "equipId: integer expected";
            return null;
        };

        return EquipChangeEquip;
    })();

    msgProto.EquipInheritedEquip = (function() {

        /**
         * Properties of an EquipInheritedEquip.
         * @memberof msgProto
         * @interface IEquipInheritedEquip
         * @property {number|null} [equipId] EquipInheritedEquip equipId
         * @property {number|null} [tempId] EquipInheritedEquip tempId
         */

        /**
         * Constructs a new EquipInheritedEquip.
         * @memberof msgProto
         * @classdesc Represents an EquipInheritedEquip.
         * @implements IEquipInheritedEquip
         * @constructor
         * @param {msgProto.IEquipInheritedEquip=} [properties] Properties to set
         */
        function EquipInheritedEquip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipInheritedEquip equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipInheritedEquip
         * @instance
         */
        EquipInheritedEquip.prototype.equipId = 0;

        /**
         * EquipInheritedEquip tempId.
         * @member {number} tempId
         * @memberof msgProto.EquipInheritedEquip
         * @instance
         */
        EquipInheritedEquip.prototype.tempId = 0;

        /**
         * Creates a new EquipInheritedEquip instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {msgProto.IEquipInheritedEquip=} [properties] Properties to set
         * @returns {msgProto.EquipInheritedEquip} EquipInheritedEquip instance
         */
        EquipInheritedEquip.create = function create(properties) {
            return new EquipInheritedEquip(properties);
        };

        /**
         * Encodes the specified EquipInheritedEquip message. Does not implicitly {@link msgProto.EquipInheritedEquip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {msgProto.IEquipInheritedEquip} message EquipInheritedEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipInheritedEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified EquipInheritedEquip message, length delimited. Does not implicitly {@link msgProto.EquipInheritedEquip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {msgProto.IEquipInheritedEquip} message EquipInheritedEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipInheritedEquip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipInheritedEquip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipInheritedEquip} EquipInheritedEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipInheritedEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipInheritedEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                case 2:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipInheritedEquip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipInheritedEquip} EquipInheritedEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipInheritedEquip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipInheritedEquip message.
         * @function verify
         * @memberof msgProto.EquipInheritedEquip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipInheritedEquip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                if (!$util.isInteger(message.equipId))
                    return "equipId: integer expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return EquipInheritedEquip;
    })();

    msgProto.EquipCustomization = (function() {

        /**
         * Properties of an EquipCustomization.
         * @memberof msgProto
         * @interface IEquipCustomization
         * @property {number|null} [certificate] EquipCustomization certificate
         * @property {number|null} [job] EquipCustomization job
         * @property {string|null} [name] EquipCustomization name
         * @property {number|null} [lvl] EquipCustomization lvl
         * @property {string|null} [abilityIndex] EquipCustomization abilityIndex
         * @property {number|null} [equipType] EquipCustomization equipType
         */

        /**
         * Constructs a new EquipCustomization.
         * @memberof msgProto
         * @classdesc Represents an EquipCustomization.
         * @implements IEquipCustomization
         * @constructor
         * @param {msgProto.IEquipCustomization=} [properties] Properties to set
         */
        function EquipCustomization(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipCustomization certificate.
         * @member {number} certificate
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.certificate = 0;

        /**
         * EquipCustomization job.
         * @member {number} job
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.job = 0;

        /**
         * EquipCustomization name.
         * @member {string} name
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.name = "";

        /**
         * EquipCustomization lvl.
         * @member {number} lvl
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.lvl = 0;

        /**
         * EquipCustomization abilityIndex.
         * @member {string} abilityIndex
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.abilityIndex = "";

        /**
         * EquipCustomization equipType.
         * @member {number} equipType
         * @memberof msgProto.EquipCustomization
         * @instance
         */
        EquipCustomization.prototype.equipType = 0;

        /**
         * Creates a new EquipCustomization instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {msgProto.IEquipCustomization=} [properties] Properties to set
         * @returns {msgProto.EquipCustomization} EquipCustomization instance
         */
        EquipCustomization.create = function create(properties) {
            return new EquipCustomization(properties);
        };

        /**
         * Encodes the specified EquipCustomization message. Does not implicitly {@link msgProto.EquipCustomization.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {msgProto.IEquipCustomization} message EquipCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipCustomization.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.certificate);
            if (message.job != null && message.hasOwnProperty("job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lvl);
            if (message.abilityIndex != null && message.hasOwnProperty("abilityIndex"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.abilityIndex);
            if (message.equipType != null && message.hasOwnProperty("equipType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.equipType);
            return writer;
        };

        /**
         * Encodes the specified EquipCustomization message, length delimited. Does not implicitly {@link msgProto.EquipCustomization.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {msgProto.IEquipCustomization} message EquipCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipCustomization.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipCustomization message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipCustomization} EquipCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipCustomization.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipCustomization();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.int32();
                    break;
                case 2:
                    message.job = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.lvl = reader.int32();
                    break;
                case 5:
                    message.abilityIndex = reader.string();
                    break;
                case 6:
                    message.equipType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipCustomization message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipCustomization} EquipCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipCustomization.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipCustomization message.
         * @function verify
         * @memberof msgProto.EquipCustomization
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipCustomization.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                if (!$util.isInteger(message.certificate))
                    return "certificate: integer expected";
            if (message.job != null && message.hasOwnProperty("job"))
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                if (!$util.isInteger(message.lvl))
                    return "lvl: integer expected";
            if (message.abilityIndex != null && message.hasOwnProperty("abilityIndex"))
                if (!$util.isString(message.abilityIndex))
                    return "abilityIndex: string expected";
            if (message.equipType != null && message.hasOwnProperty("equipType"))
                if (!$util.isInteger(message.equipType))
                    return "equipType: integer expected";
            return null;
        };

        return EquipCustomization;
    })();

    msgProto.EquipUpCustomization = (function() {

        /**
         * Properties of an EquipUpCustomization.
         * @memberof msgProto
         * @interface IEquipUpCustomization
         * @property {number|null} [equipId] EquipUpCustomization equipId
         */

        /**
         * Constructs a new EquipUpCustomization.
         * @memberof msgProto
         * @classdesc Represents an EquipUpCustomization.
         * @implements IEquipUpCustomization
         * @constructor
         * @param {msgProto.IEquipUpCustomization=} [properties] Properties to set
         */
        function EquipUpCustomization(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipUpCustomization equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipUpCustomization
         * @instance
         */
        EquipUpCustomization.prototype.equipId = 0;

        /**
         * Creates a new EquipUpCustomization instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {msgProto.IEquipUpCustomization=} [properties] Properties to set
         * @returns {msgProto.EquipUpCustomization} EquipUpCustomization instance
         */
        EquipUpCustomization.create = function create(properties) {
            return new EquipUpCustomization(properties);
        };

        /**
         * Encodes the specified EquipUpCustomization message. Does not implicitly {@link msgProto.EquipUpCustomization.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {msgProto.IEquipUpCustomization} message EquipUpCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpCustomization.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            return writer;
        };

        /**
         * Encodes the specified EquipUpCustomization message, length delimited. Does not implicitly {@link msgProto.EquipUpCustomization.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {msgProto.IEquipUpCustomization} message EquipUpCustomization message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpCustomization.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipUpCustomization message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipUpCustomization} EquipUpCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpCustomization.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipUpCustomization();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipUpCustomization message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipUpCustomization} EquipUpCustomization
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpCustomization.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipUpCustomization message.
         * @function verify
         * @memberof msgProto.EquipUpCustomization
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipUpCustomization.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                if (!$util.isInteger(message.equipId))
                    return "equipId: integer expected";
            return null;
        };

        return EquipUpCustomization;
    })();

    msgProto.EquipUpdateEquipItemLockStatus = (function() {

        /**
         * Properties of an EquipUpdateEquipItemLockStatus.
         * @memberof msgProto
         * @interface IEquipUpdateEquipItemLockStatus
         * @property {number|null} [equipId] EquipUpdateEquipItemLockStatus equipId
         * @property {number|null} [isLocked] EquipUpdateEquipItemLockStatus isLocked
         */

        /**
         * Constructs a new EquipUpdateEquipItemLockStatus.
         * @memberof msgProto
         * @classdesc Represents an EquipUpdateEquipItemLockStatus.
         * @implements IEquipUpdateEquipItemLockStatus
         * @constructor
         * @param {msgProto.IEquipUpdateEquipItemLockStatus=} [properties] Properties to set
         */
        function EquipUpdateEquipItemLockStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipUpdateEquipItemLockStatus equipId.
         * @member {number} equipId
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @instance
         */
        EquipUpdateEquipItemLockStatus.prototype.equipId = 0;

        /**
         * EquipUpdateEquipItemLockStatus isLocked.
         * @member {number} isLocked
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @instance
         */
        EquipUpdateEquipItemLockStatus.prototype.isLocked = 0;

        /**
         * Creates a new EquipUpdateEquipItemLockStatus instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {msgProto.IEquipUpdateEquipItemLockStatus=} [properties] Properties to set
         * @returns {msgProto.EquipUpdateEquipItemLockStatus} EquipUpdateEquipItemLockStatus instance
         */
        EquipUpdateEquipItemLockStatus.create = function create(properties) {
            return new EquipUpdateEquipItemLockStatus(properties);
        };

        /**
         * Encodes the specified EquipUpdateEquipItemLockStatus message. Does not implicitly {@link msgProto.EquipUpdateEquipItemLockStatus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {msgProto.IEquipUpdateEquipItemLockStatus} message EquipUpdateEquipItemLockStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpdateEquipItemLockStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.equipId);
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isLocked);
            return writer;
        };

        /**
         * Encodes the specified EquipUpdateEquipItemLockStatus message, length delimited. Does not implicitly {@link msgProto.EquipUpdateEquipItemLockStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {msgProto.IEquipUpdateEquipItemLockStatus} message EquipUpdateEquipItemLockStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipUpdateEquipItemLockStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipUpdateEquipItemLockStatus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipUpdateEquipItemLockStatus} EquipUpdateEquipItemLockStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpdateEquipItemLockStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipUpdateEquipItemLockStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipId = reader.int32();
                    break;
                case 2:
                    message.isLocked = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipUpdateEquipItemLockStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipUpdateEquipItemLockStatus} EquipUpdateEquipItemLockStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipUpdateEquipItemLockStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipUpdateEquipItemLockStatus message.
         * @function verify
         * @memberof msgProto.EquipUpdateEquipItemLockStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipUpdateEquipItemLockStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equipId != null && message.hasOwnProperty("equipId"))
                if (!$util.isInteger(message.equipId))
                    return "equipId: integer expected";
            if (message.isLocked != null && message.hasOwnProperty("isLocked"))
                if (!$util.isInteger(message.isLocked))
                    return "isLocked: integer expected";
            return null;
        };

        return EquipUpdateEquipItemLockStatus;
    })();

    msgProto.EquipSellEquipItems = (function() {

        /**
         * Properties of an EquipSellEquipItems.
         * @memberof msgProto
         * @interface IEquipSellEquipItems
         * @property {string|null} [equipIdArr] EquipSellEquipItems equipIdArr
         */

        /**
         * Constructs a new EquipSellEquipItems.
         * @memberof msgProto
         * @classdesc Represents an EquipSellEquipItems.
         * @implements IEquipSellEquipItems
         * @constructor
         * @param {msgProto.IEquipSellEquipItems=} [properties] Properties to set
         */
        function EquipSellEquipItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipSellEquipItems equipIdArr.
         * @member {string} equipIdArr
         * @memberof msgProto.EquipSellEquipItems
         * @instance
         */
        EquipSellEquipItems.prototype.equipIdArr = "";

        /**
         * Creates a new EquipSellEquipItems instance using the specified properties.
         * @function create
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {msgProto.IEquipSellEquipItems=} [properties] Properties to set
         * @returns {msgProto.EquipSellEquipItems} EquipSellEquipItems instance
         */
        EquipSellEquipItems.create = function create(properties) {
            return new EquipSellEquipItems(properties);
        };

        /**
         * Encodes the specified EquipSellEquipItems message. Does not implicitly {@link msgProto.EquipSellEquipItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {msgProto.IEquipSellEquipItems} message EquipSellEquipItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipSellEquipItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipIdArr != null && message.hasOwnProperty("equipIdArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.equipIdArr);
            return writer;
        };

        /**
         * Encodes the specified EquipSellEquipItems message, length delimited. Does not implicitly {@link msgProto.EquipSellEquipItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {msgProto.IEquipSellEquipItems} message EquipSellEquipItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipSellEquipItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipSellEquipItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.EquipSellEquipItems} EquipSellEquipItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipSellEquipItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.EquipSellEquipItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipIdArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipSellEquipItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.EquipSellEquipItems} EquipSellEquipItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipSellEquipItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipSellEquipItems message.
         * @function verify
         * @memberof msgProto.EquipSellEquipItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipSellEquipItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equipIdArr != null && message.hasOwnProperty("equipIdArr"))
                if (!$util.isString(message.equipIdArr))
                    return "equipIdArr: string expected";
            return null;
        };

        return EquipSellEquipItems;
    })();

    msgProto.UserGetInfo = (function() {

        /**
         * Properties of a UserGetInfo.
         * @memberof msgProto
         * @interface IUserGetInfo
         */

        /**
         * Constructs a new UserGetInfo.
         * @memberof msgProto
         * @classdesc Represents a UserGetInfo.
         * @implements IUserGetInfo
         * @constructor
         * @param {msgProto.IUserGetInfo=} [properties] Properties to set
         */
        function UserGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {msgProto.IUserGetInfo=} [properties] Properties to set
         * @returns {msgProto.UserGetInfo} UserGetInfo instance
         */
        UserGetInfo.create = function create(properties) {
            return new UserGetInfo(properties);
        };

        /**
         * Encodes the specified UserGetInfo message. Does not implicitly {@link msgProto.UserGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {msgProto.IUserGetInfo} message UserGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetInfo message, length delimited. Does not implicitly {@link msgProto.UserGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {msgProto.IUserGetInfo} message UserGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetInfo} UserGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetInfo} UserGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetInfo message.
         * @function verify
         * @memberof msgProto.UserGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetInfo;
    })();

    msgProto.UserChangeName = (function() {

        /**
         * Properties of a UserChangeName.
         * @memberof msgProto
         * @interface IUserChangeName
         * @property {string|null} [name] UserChangeName name
         * @property {number|null} [heroTempId] UserChangeName heroTempId
         */

        /**
         * Constructs a new UserChangeName.
         * @memberof msgProto
         * @classdesc Represents a UserChangeName.
         * @implements IUserChangeName
         * @constructor
         * @param {msgProto.IUserChangeName=} [properties] Properties to set
         */
        function UserChangeName(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserChangeName name.
         * @member {string} name
         * @memberof msgProto.UserChangeName
         * @instance
         */
        UserChangeName.prototype.name = "";

        /**
         * UserChangeName heroTempId.
         * @member {number} heroTempId
         * @memberof msgProto.UserChangeName
         * @instance
         */
        UserChangeName.prototype.heroTempId = 0;

        /**
         * Creates a new UserChangeName instance using the specified properties.
         * @function create
         * @memberof msgProto.UserChangeName
         * @static
         * @param {msgProto.IUserChangeName=} [properties] Properties to set
         * @returns {msgProto.UserChangeName} UserChangeName instance
         */
        UserChangeName.create = function create(properties) {
            return new UserChangeName(properties);
        };

        /**
         * Encodes the specified UserChangeName message. Does not implicitly {@link msgProto.UserChangeName.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserChangeName
         * @static
         * @param {msgProto.IUserChangeName} message UserChangeName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserChangeName.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroTempId);
            return writer;
        };

        /**
         * Encodes the specified UserChangeName message, length delimited. Does not implicitly {@link msgProto.UserChangeName.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserChangeName
         * @static
         * @param {msgProto.IUserChangeName} message UserChangeName message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserChangeName.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserChangeName message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserChangeName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserChangeName} UserChangeName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserChangeName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserChangeName();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.heroTempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserChangeName message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserChangeName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserChangeName} UserChangeName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserChangeName.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserChangeName message.
         * @function verify
         * @memberof msgProto.UserChangeName
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserChangeName.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                if (!$util.isInteger(message.heroTempId))
                    return "heroTempId: integer expected";
            return null;
        };

        return UserChangeName;
    })();

    msgProto.UserUpLvl = (function() {

        /**
         * Properties of a UserUpLvl.
         * @memberof msgProto
         * @interface IUserUpLvl
         */

        /**
         * Constructs a new UserUpLvl.
         * @memberof msgProto
         * @classdesc Represents a UserUpLvl.
         * @implements IUserUpLvl
         * @constructor
         * @param {msgProto.IUserUpLvl=} [properties] Properties to set
         */
        function UserUpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserUpLvl instance using the specified properties.
         * @function create
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {msgProto.IUserUpLvl=} [properties] Properties to set
         * @returns {msgProto.UserUpLvl} UserUpLvl instance
         */
        UserUpLvl.create = function create(properties) {
            return new UserUpLvl(properties);
        };

        /**
         * Encodes the specified UserUpLvl message. Does not implicitly {@link msgProto.UserUpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {msgProto.IUserUpLvl} message UserUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserUpLvl message, length delimited. Does not implicitly {@link msgProto.UserUpLvl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {msgProto.IUserUpLvl} message UserUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpLvl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpLvl} UserUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUpLvl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserUpLvl} UserUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpLvl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUpLvl message.
         * @function verify
         * @memberof msgProto.UserUpLvl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUpLvl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserUpLvl;
    })();

    msgProto.UserSyncData = (function() {

        /**
         * Properties of a UserSyncData.
         * @memberof msgProto
         * @interface IUserSyncData
         * @property {string|null} [sendData] UserSyncData sendData
         */

        /**
         * Constructs a new UserSyncData.
         * @memberof msgProto
         * @classdesc Represents a UserSyncData.
         * @implements IUserSyncData
         * @constructor
         * @param {msgProto.IUserSyncData=} [properties] Properties to set
         */
        function UserSyncData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSyncData sendData.
         * @member {string} sendData
         * @memberof msgProto.UserSyncData
         * @instance
         */
        UserSyncData.prototype.sendData = "";

        /**
         * Creates a new UserSyncData instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSyncData
         * @static
         * @param {msgProto.IUserSyncData=} [properties] Properties to set
         * @returns {msgProto.UserSyncData} UserSyncData instance
         */
        UserSyncData.create = function create(properties) {
            return new UserSyncData(properties);
        };

        /**
         * Encodes the specified UserSyncData message. Does not implicitly {@link msgProto.UserSyncData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSyncData
         * @static
         * @param {msgProto.IUserSyncData} message UserSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendData != null && message.hasOwnProperty("sendData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sendData);
            return writer;
        };

        /**
         * Encodes the specified UserSyncData message, length delimited. Does not implicitly {@link msgProto.UserSyncData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSyncData
         * @static
         * @param {msgProto.IUserSyncData} message UserSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSyncData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSyncData} UserSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSyncData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSyncData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSyncData} UserSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSyncData message.
         * @function verify
         * @memberof msgProto.UserSyncData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSyncData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendData != null && message.hasOwnProperty("sendData"))
                if (!$util.isString(message.sendData))
                    return "sendData: string expected";
            return null;
        };

        return UserSyncData;
    })();

    msgProto.UserSyncData2 = (function() {

        /**
         * Properties of a UserSyncData2.
         * @memberof msgProto
         * @interface IUserSyncData2
         */

        /**
         * Constructs a new UserSyncData2.
         * @memberof msgProto
         * @classdesc Represents a UserSyncData2.
         * @implements IUserSyncData2
         * @constructor
         * @param {msgProto.IUserSyncData2=} [properties] Properties to set
         */
        function UserSyncData2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserSyncData2 instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {msgProto.IUserSyncData2=} [properties] Properties to set
         * @returns {msgProto.UserSyncData2} UserSyncData2 instance
         */
        UserSyncData2.create = function create(properties) {
            return new UserSyncData2(properties);
        };

        /**
         * Encodes the specified UserSyncData2 message. Does not implicitly {@link msgProto.UserSyncData2.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {msgProto.IUserSyncData2} message UserSyncData2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserSyncData2 message, length delimited. Does not implicitly {@link msgProto.UserSyncData2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {msgProto.IUserSyncData2} message UserSyncData2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSyncData2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSyncData2 message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSyncData2} UserSyncData2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSyncData2();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSyncData2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSyncData2} UserSyncData2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSyncData2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSyncData2 message.
         * @function verify
         * @memberof msgProto.UserSyncData2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSyncData2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserSyncData2;
    })();

    msgProto.UserGetBagChest = (function() {

        /**
         * Properties of a UserGetBagChest.
         * @memberof msgProto
         * @interface IUserGetBagChest
         * @property {number|null} [chestId] UserGetBagChest chestId
         * @property {number|null} [count] UserGetBagChest count
         */

        /**
         * Constructs a new UserGetBagChest.
         * @memberof msgProto
         * @classdesc Represents a UserGetBagChest.
         * @implements IUserGetBagChest
         * @constructor
         * @param {msgProto.IUserGetBagChest=} [properties] Properties to set
         */
        function UserGetBagChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserGetBagChest chestId.
         * @member {number} chestId
         * @memberof msgProto.UserGetBagChest
         * @instance
         */
        UserGetBagChest.prototype.chestId = 0;

        /**
         * UserGetBagChest count.
         * @member {number} count
         * @memberof msgProto.UserGetBagChest
         * @instance
         */
        UserGetBagChest.prototype.count = 0;

        /**
         * Creates a new UserGetBagChest instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {msgProto.IUserGetBagChest=} [properties] Properties to set
         * @returns {msgProto.UserGetBagChest} UserGetBagChest instance
         */
        UserGetBagChest.create = function create(properties) {
            return new UserGetBagChest(properties);
        };

        /**
         * Encodes the specified UserGetBagChest message. Does not implicitly {@link msgProto.UserGetBagChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {msgProto.IUserGetBagChest} message UserGetBagChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBagChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chestId != null && message.hasOwnProperty("chestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.chestId);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified UserGetBagChest message, length delimited. Does not implicitly {@link msgProto.UserGetBagChest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {msgProto.IUserGetBagChest} message UserGetBagChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBagChest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetBagChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetBagChest} UserGetBagChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBagChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetBagChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chestId = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetBagChest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetBagChest} UserGetBagChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBagChest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetBagChest message.
         * @function verify
         * @memberof msgProto.UserGetBagChest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetBagChest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chestId != null && message.hasOwnProperty("chestId"))
                if (!$util.isInteger(message.chestId))
                    return "chestId: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return UserGetBagChest;
    })();

    msgProto.UserBuyGold = (function() {

        /**
         * Properties of a UserBuyGold.
         * @memberof msgProto
         * @interface IUserBuyGold
         */

        /**
         * Constructs a new UserBuyGold.
         * @memberof msgProto
         * @classdesc Represents a UserBuyGold.
         * @implements IUserBuyGold
         * @constructor
         * @param {msgProto.IUserBuyGold=} [properties] Properties to set
         */
        function UserBuyGold(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserBuyGold instance using the specified properties.
         * @function create
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {msgProto.IUserBuyGold=} [properties] Properties to set
         * @returns {msgProto.UserBuyGold} UserBuyGold instance
         */
        UserBuyGold.create = function create(properties) {
            return new UserBuyGold(properties);
        };

        /**
         * Encodes the specified UserBuyGold message. Does not implicitly {@link msgProto.UserBuyGold.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {msgProto.IUserBuyGold} message UserBuyGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserBuyGold message, length delimited. Does not implicitly {@link msgProto.UserBuyGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {msgProto.IUserBuyGold} message UserBuyGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserBuyGold message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyGold} UserBuyGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyGold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBuyGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserBuyGold} UserBuyGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserBuyGold message.
         * @function verify
         * @memberof msgProto.UserBuyGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserBuyGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserBuyGold;
    })();

    msgProto.UserBuyLingyun = (function() {

        /**
         * Properties of a UserBuyLingyun.
         * @memberof msgProto
         * @interface IUserBuyLingyun
         */

        /**
         * Constructs a new UserBuyLingyun.
         * @memberof msgProto
         * @classdesc Represents a UserBuyLingyun.
         * @implements IUserBuyLingyun
         * @constructor
         * @param {msgProto.IUserBuyLingyun=} [properties] Properties to set
         */
        function UserBuyLingyun(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserBuyLingyun instance using the specified properties.
         * @function create
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {msgProto.IUserBuyLingyun=} [properties] Properties to set
         * @returns {msgProto.UserBuyLingyun} UserBuyLingyun instance
         */
        UserBuyLingyun.create = function create(properties) {
            return new UserBuyLingyun(properties);
        };

        /**
         * Encodes the specified UserBuyLingyun message. Does not implicitly {@link msgProto.UserBuyLingyun.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {msgProto.IUserBuyLingyun} message UserBuyLingyun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyLingyun.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserBuyLingyun message, length delimited. Does not implicitly {@link msgProto.UserBuyLingyun.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {msgProto.IUserBuyLingyun} message UserBuyLingyun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyLingyun.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserBuyLingyun message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyLingyun} UserBuyLingyun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyLingyun.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyLingyun();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBuyLingyun message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserBuyLingyun} UserBuyLingyun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyLingyun.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserBuyLingyun message.
         * @function verify
         * @memberof msgProto.UserBuyLingyun
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserBuyLingyun.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserBuyLingyun;
    })();

    msgProto.UserGetRedPoint = (function() {

        /**
         * Properties of a UserGetRedPoint.
         * @memberof msgProto
         * @interface IUserGetRedPoint
         */

        /**
         * Constructs a new UserGetRedPoint.
         * @memberof msgProto
         * @classdesc Represents a UserGetRedPoint.
         * @implements IUserGetRedPoint
         * @constructor
         * @param {msgProto.IUserGetRedPoint=} [properties] Properties to set
         */
        function UserGetRedPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetRedPoint instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {msgProto.IUserGetRedPoint=} [properties] Properties to set
         * @returns {msgProto.UserGetRedPoint} UserGetRedPoint instance
         */
        UserGetRedPoint.create = function create(properties) {
            return new UserGetRedPoint(properties);
        };

        /**
         * Encodes the specified UserGetRedPoint message. Does not implicitly {@link msgProto.UserGetRedPoint.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {msgProto.IUserGetRedPoint} message UserGetRedPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetRedPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetRedPoint message, length delimited. Does not implicitly {@link msgProto.UserGetRedPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {msgProto.IUserGetRedPoint} message UserGetRedPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetRedPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetRedPoint message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetRedPoint} UserGetRedPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetRedPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetRedPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetRedPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetRedPoint} UserGetRedPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetRedPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetRedPoint message.
         * @function verify
         * @memberof msgProto.UserGetRedPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetRedPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetRedPoint;
    })();

    msgProto.UserUpdateGuide = (function() {

        /**
         * Properties of a UserUpdateGuide.
         * @memberof msgProto
         * @interface IUserUpdateGuide
         * @property {number|null} [guideId] UserUpdateGuide guideId
         */

        /**
         * Constructs a new UserUpdateGuide.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateGuide.
         * @implements IUserUpdateGuide
         * @constructor
         * @param {msgProto.IUserUpdateGuide=} [properties] Properties to set
         */
        function UserUpdateGuide(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateGuide guideId.
         * @member {number} guideId
         * @memberof msgProto.UserUpdateGuide
         * @instance
         */
        UserUpdateGuide.prototype.guideId = 0;

        /**
         * Creates a new UserUpdateGuide instance using the specified properties.
         * @function create
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {msgProto.IUserUpdateGuide=} [properties] Properties to set
         * @returns {msgProto.UserUpdateGuide} UserUpdateGuide instance
         */
        UserUpdateGuide.create = function create(properties) {
            return new UserUpdateGuide(properties);
        };

        /**
         * Encodes the specified UserUpdateGuide message. Does not implicitly {@link msgProto.UserUpdateGuide.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {msgProto.IUserUpdateGuide} message UserUpdateGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateGuide.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guideId);
            return writer;
        };

        /**
         * Encodes the specified UserUpdateGuide message, length delimited. Does not implicitly {@link msgProto.UserUpdateGuide.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {msgProto.IUserUpdateGuide} message UserUpdateGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateGuide.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUpdateGuide message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateGuide} UserUpdateGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateGuide.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateGuide();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guideId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUpdateGuide message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserUpdateGuide} UserUpdateGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateGuide.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUpdateGuide message.
         * @function verify
         * @memberof msgProto.UserUpdateGuide
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUpdateGuide.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                if (!$util.isInteger(message.guideId))
                    return "guideId: integer expected";
            return null;
        };

        return UserUpdateGuide;
    })();

    msgProto.UserGetWinRecord = (function() {

        /**
         * Properties of a UserGetWinRecord.
         * @memberof msgProto
         * @interface IUserGetWinRecord
         */

        /**
         * Constructs a new UserGetWinRecord.
         * @memberof msgProto
         * @classdesc Represents a UserGetWinRecord.
         * @implements IUserGetWinRecord
         * @constructor
         * @param {msgProto.IUserGetWinRecord=} [properties] Properties to set
         */
        function UserGetWinRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetWinRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {msgProto.IUserGetWinRecord=} [properties] Properties to set
         * @returns {msgProto.UserGetWinRecord} UserGetWinRecord instance
         */
        UserGetWinRecord.create = function create(properties) {
            return new UserGetWinRecord(properties);
        };

        /**
         * Encodes the specified UserGetWinRecord message. Does not implicitly {@link msgProto.UserGetWinRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {msgProto.IUserGetWinRecord} message UserGetWinRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWinRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetWinRecord message, length delimited. Does not implicitly {@link msgProto.UserGetWinRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {msgProto.IUserGetWinRecord} message UserGetWinRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWinRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetWinRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWinRecord} UserGetWinRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWinRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWinRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetWinRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetWinRecord} UserGetWinRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWinRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetWinRecord message.
         * @function verify
         * @memberof msgProto.UserGetWinRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetWinRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetWinRecord;
    })();

    msgProto.UserGetLoseRecord = (function() {

        /**
         * Properties of a UserGetLoseRecord.
         * @memberof msgProto
         * @interface IUserGetLoseRecord
         */

        /**
         * Constructs a new UserGetLoseRecord.
         * @memberof msgProto
         * @classdesc Represents a UserGetLoseRecord.
         * @implements IUserGetLoseRecord
         * @constructor
         * @param {msgProto.IUserGetLoseRecord=} [properties] Properties to set
         */
        function UserGetLoseRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetLoseRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {msgProto.IUserGetLoseRecord=} [properties] Properties to set
         * @returns {msgProto.UserGetLoseRecord} UserGetLoseRecord instance
         */
        UserGetLoseRecord.create = function create(properties) {
            return new UserGetLoseRecord(properties);
        };

        /**
         * Encodes the specified UserGetLoseRecord message. Does not implicitly {@link msgProto.UserGetLoseRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {msgProto.IUserGetLoseRecord} message UserGetLoseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetLoseRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetLoseRecord message, length delimited. Does not implicitly {@link msgProto.UserGetLoseRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {msgProto.IUserGetLoseRecord} message UserGetLoseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetLoseRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetLoseRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetLoseRecord} UserGetLoseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetLoseRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetLoseRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetLoseRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetLoseRecord} UserGetLoseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetLoseRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetLoseRecord message.
         * @function verify
         * @memberof msgProto.UserGetLoseRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetLoseRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetLoseRecord;
    })();

    msgProto.UserBuyToUpLvl = (function() {

        /**
         * Properties of a UserBuyToUpLvl.
         * @memberof msgProto
         * @interface IUserBuyToUpLvl
         */

        /**
         * Constructs a new UserBuyToUpLvl.
         * @memberof msgProto
         * @classdesc Represents a UserBuyToUpLvl.
         * @implements IUserBuyToUpLvl
         * @constructor
         * @param {msgProto.IUserBuyToUpLvl=} [properties] Properties to set
         */
        function UserBuyToUpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserBuyToUpLvl instance using the specified properties.
         * @function create
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {msgProto.IUserBuyToUpLvl=} [properties] Properties to set
         * @returns {msgProto.UserBuyToUpLvl} UserBuyToUpLvl instance
         */
        UserBuyToUpLvl.create = function create(properties) {
            return new UserBuyToUpLvl(properties);
        };

        /**
         * Encodes the specified UserBuyToUpLvl message. Does not implicitly {@link msgProto.UserBuyToUpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {msgProto.IUserBuyToUpLvl} message UserBuyToUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyToUpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserBuyToUpLvl message, length delimited. Does not implicitly {@link msgProto.UserBuyToUpLvl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {msgProto.IUserBuyToUpLvl} message UserBuyToUpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyToUpLvl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserBuyToUpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyToUpLvl} UserBuyToUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyToUpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyToUpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBuyToUpLvl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserBuyToUpLvl} UserBuyToUpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyToUpLvl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserBuyToUpLvl message.
         * @function verify
         * @memberof msgProto.UserBuyToUpLvl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserBuyToUpLvl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserBuyToUpLvl;
    })();

    msgProto.UserSaveDeskSuccess = (function() {

        /**
         * Properties of a UserSaveDeskSuccess.
         * @memberof msgProto
         * @interface IUserSaveDeskSuccess
         * @property {number|null} [type] UserSaveDeskSuccess type
         */

        /**
         * Constructs a new UserSaveDeskSuccess.
         * @memberof msgProto
         * @classdesc Represents a UserSaveDeskSuccess.
         * @implements IUserSaveDeskSuccess
         * @constructor
         * @param {msgProto.IUserSaveDeskSuccess=} [properties] Properties to set
         */
        function UserSaveDeskSuccess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSaveDeskSuccess type.
         * @member {number} type
         * @memberof msgProto.UserSaveDeskSuccess
         * @instance
         */
        UserSaveDeskSuccess.prototype.type = 0;

        /**
         * Creates a new UserSaveDeskSuccess instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {msgProto.IUserSaveDeskSuccess=} [properties] Properties to set
         * @returns {msgProto.UserSaveDeskSuccess} UserSaveDeskSuccess instance
         */
        UserSaveDeskSuccess.create = function create(properties) {
            return new UserSaveDeskSuccess(properties);
        };

        /**
         * Encodes the specified UserSaveDeskSuccess message. Does not implicitly {@link msgProto.UserSaveDeskSuccess.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {msgProto.IUserSaveDeskSuccess} message UserSaveDeskSuccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSaveDeskSuccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified UserSaveDeskSuccess message, length delimited. Does not implicitly {@link msgProto.UserSaveDeskSuccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {msgProto.IUserSaveDeskSuccess} message UserSaveDeskSuccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSaveDeskSuccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSaveDeskSuccess message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSaveDeskSuccess} UserSaveDeskSuccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSaveDeskSuccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSaveDeskSuccess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSaveDeskSuccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSaveDeskSuccess} UserSaveDeskSuccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSaveDeskSuccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSaveDeskSuccess message.
         * @function verify
         * @memberof msgProto.UserSaveDeskSuccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSaveDeskSuccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return UserSaveDeskSuccess;
    })();

    msgProto.UserSetHeroEmbattle = (function() {

        /**
         * Properties of a UserSetHeroEmbattle.
         * @memberof msgProto
         * @interface IUserSetHeroEmbattle
         * @property {string|null} [heroEmbattle] UserSetHeroEmbattle heroEmbattle
         */

        /**
         * Constructs a new UserSetHeroEmbattle.
         * @memberof msgProto
         * @classdesc Represents a UserSetHeroEmbattle.
         * @implements IUserSetHeroEmbattle
         * @constructor
         * @param {msgProto.IUserSetHeroEmbattle=} [properties] Properties to set
         */
        function UserSetHeroEmbattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetHeroEmbattle heroEmbattle.
         * @member {string} heroEmbattle
         * @memberof msgProto.UserSetHeroEmbattle
         * @instance
         */
        UserSetHeroEmbattle.prototype.heroEmbattle = "";

        /**
         * Creates a new UserSetHeroEmbattle instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {msgProto.IUserSetHeroEmbattle=} [properties] Properties to set
         * @returns {msgProto.UserSetHeroEmbattle} UserSetHeroEmbattle instance
         */
        UserSetHeroEmbattle.create = function create(properties) {
            return new UserSetHeroEmbattle(properties);
        };

        /**
         * Encodes the specified UserSetHeroEmbattle message. Does not implicitly {@link msgProto.UserSetHeroEmbattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {msgProto.IUserSetHeroEmbattle} message UserSetHeroEmbattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetHeroEmbattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroEmbattle != null && message.hasOwnProperty("heroEmbattle"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heroEmbattle);
            return writer;
        };

        /**
         * Encodes the specified UserSetHeroEmbattle message, length delimited. Does not implicitly {@link msgProto.UserSetHeroEmbattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {msgProto.IUserSetHeroEmbattle} message UserSetHeroEmbattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetHeroEmbattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetHeroEmbattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetHeroEmbattle} UserSetHeroEmbattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetHeroEmbattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetHeroEmbattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroEmbattle = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetHeroEmbattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSetHeroEmbattle} UserSetHeroEmbattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetHeroEmbattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetHeroEmbattle message.
         * @function verify
         * @memberof msgProto.UserSetHeroEmbattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetHeroEmbattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroEmbattle != null && message.hasOwnProperty("heroEmbattle"))
                if (!$util.isString(message.heroEmbattle))
                    return "heroEmbattle: string expected";
            return null;
        };

        return UserSetHeroEmbattle;
    })();

    msgProto.UserBuyBagGrid = (function() {

        /**
         * Properties of a UserBuyBagGrid.
         * @memberof msgProto
         * @interface IUserBuyBagGrid
         */

        /**
         * Constructs a new UserBuyBagGrid.
         * @memberof msgProto
         * @classdesc Represents a UserBuyBagGrid.
         * @implements IUserBuyBagGrid
         * @constructor
         * @param {msgProto.IUserBuyBagGrid=} [properties] Properties to set
         */
        function UserBuyBagGrid(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserBuyBagGrid instance using the specified properties.
         * @function create
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {msgProto.IUserBuyBagGrid=} [properties] Properties to set
         * @returns {msgProto.UserBuyBagGrid} UserBuyBagGrid instance
         */
        UserBuyBagGrid.create = function create(properties) {
            return new UserBuyBagGrid(properties);
        };

        /**
         * Encodes the specified UserBuyBagGrid message. Does not implicitly {@link msgProto.UserBuyBagGrid.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {msgProto.IUserBuyBagGrid} message UserBuyBagGrid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyBagGrid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserBuyBagGrid message, length delimited. Does not implicitly {@link msgProto.UserBuyBagGrid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {msgProto.IUserBuyBagGrid} message UserBuyBagGrid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserBuyBagGrid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserBuyBagGrid message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserBuyBagGrid} UserBuyBagGrid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyBagGrid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserBuyBagGrid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserBuyBagGrid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserBuyBagGrid} UserBuyBagGrid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserBuyBagGrid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserBuyBagGrid message.
         * @function verify
         * @memberof msgProto.UserBuyBagGrid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserBuyBagGrid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserBuyBagGrid;
    })();

    msgProto.UserUpdateCombat = (function() {

        /**
         * Properties of a UserUpdateCombat.
         * @memberof msgProto
         * @interface IUserUpdateCombat
         */

        /**
         * Constructs a new UserUpdateCombat.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateCombat.
         * @implements IUserUpdateCombat
         * @constructor
         * @param {msgProto.IUserUpdateCombat=} [properties] Properties to set
         */
        function UserUpdateCombat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserUpdateCombat instance using the specified properties.
         * @function create
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {msgProto.IUserUpdateCombat=} [properties] Properties to set
         * @returns {msgProto.UserUpdateCombat} UserUpdateCombat instance
         */
        UserUpdateCombat.create = function create(properties) {
            return new UserUpdateCombat(properties);
        };

        /**
         * Encodes the specified UserUpdateCombat message. Does not implicitly {@link msgProto.UserUpdateCombat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {msgProto.IUserUpdateCombat} message UserUpdateCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateCombat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserUpdateCombat message, length delimited. Does not implicitly {@link msgProto.UserUpdateCombat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {msgProto.IUserUpdateCombat} message UserUpdateCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateCombat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUpdateCombat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateCombat} UserUpdateCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateCombat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateCombat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUpdateCombat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserUpdateCombat} UserUpdateCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateCombat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUpdateCombat message.
         * @function verify
         * @memberof msgProto.UserUpdateCombat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUpdateCombat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserUpdateCombat;
    })();

    msgProto.UserSetAutoFight = (function() {

        /**
         * Properties of a UserSetAutoFight.
         * @memberof msgProto
         * @interface IUserSetAutoFight
         * @property {number|null} [isAuto] UserSetAutoFight isAuto
         */

        /**
         * Constructs a new UserSetAutoFight.
         * @memberof msgProto
         * @classdesc Represents a UserSetAutoFight.
         * @implements IUserSetAutoFight
         * @constructor
         * @param {msgProto.IUserSetAutoFight=} [properties] Properties to set
         */
        function UserSetAutoFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetAutoFight isAuto.
         * @member {number} isAuto
         * @memberof msgProto.UserSetAutoFight
         * @instance
         */
        UserSetAutoFight.prototype.isAuto = 0;

        /**
         * Creates a new UserSetAutoFight instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {msgProto.IUserSetAutoFight=} [properties] Properties to set
         * @returns {msgProto.UserSetAutoFight} UserSetAutoFight instance
         */
        UserSetAutoFight.create = function create(properties) {
            return new UserSetAutoFight(properties);
        };

        /**
         * Encodes the specified UserSetAutoFight message. Does not implicitly {@link msgProto.UserSetAutoFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {msgProto.IUserSetAutoFight} message UserSetAutoFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetAutoFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isAuto != null && message.hasOwnProperty("isAuto"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isAuto);
            return writer;
        };

        /**
         * Encodes the specified UserSetAutoFight message, length delimited. Does not implicitly {@link msgProto.UserSetAutoFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {msgProto.IUserSetAutoFight} message UserSetAutoFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetAutoFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetAutoFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetAutoFight} UserSetAutoFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetAutoFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetAutoFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isAuto = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetAutoFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSetAutoFight} UserSetAutoFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetAutoFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetAutoFight message.
         * @function verify
         * @memberof msgProto.UserSetAutoFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetAutoFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isAuto != null && message.hasOwnProperty("isAuto"))
                if (!$util.isInteger(message.isAuto))
                    return "isAuto: integer expected";
            return null;
        };

        return UserSetAutoFight;
    })();

    msgProto.UserSetTimeError = (function() {

        /**
         * Properties of a UserSetTimeError.
         * @memberof msgProto
         * @interface IUserSetTimeError
         * @property {number|null} [errorNum] UserSetTimeError errorNum
         */

        /**
         * Constructs a new UserSetTimeError.
         * @memberof msgProto
         * @classdesc Represents a UserSetTimeError.
         * @implements IUserSetTimeError
         * @constructor
         * @param {msgProto.IUserSetTimeError=} [properties] Properties to set
         */
        function UserSetTimeError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetTimeError errorNum.
         * @member {number} errorNum
         * @memberof msgProto.UserSetTimeError
         * @instance
         */
        UserSetTimeError.prototype.errorNum = 0;

        /**
         * Creates a new UserSetTimeError instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {msgProto.IUserSetTimeError=} [properties] Properties to set
         * @returns {msgProto.UserSetTimeError} UserSetTimeError instance
         */
        UserSetTimeError.create = function create(properties) {
            return new UserSetTimeError(properties);
        };

        /**
         * Encodes the specified UserSetTimeError message. Does not implicitly {@link msgProto.UserSetTimeError.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {msgProto.IUserSetTimeError} message UserSetTimeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTimeError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errorNum != null && message.hasOwnProperty("errorNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorNum);
            return writer;
        };

        /**
         * Encodes the specified UserSetTimeError message, length delimited. Does not implicitly {@link msgProto.UserSetTimeError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {msgProto.IUserSetTimeError} message UserSetTimeError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTimeError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetTimeError message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetTimeError} UserSetTimeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTimeError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetTimeError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errorNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetTimeError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSetTimeError} UserSetTimeError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTimeError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetTimeError message.
         * @function verify
         * @memberof msgProto.UserSetTimeError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetTimeError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errorNum != null && message.hasOwnProperty("errorNum"))
                if (!$util.isInteger(message.errorNum))
                    return "errorNum: integer expected";
            return null;
        };

        return UserSetTimeError;
    })();

    msgProto.UserSetTodayRankWin = (function() {

        /**
         * Properties of a UserSetTodayRankWin.
         * @memberof msgProto
         * @interface IUserSetTodayRankWin
         * @property {number|Long|null} [eid] UserSetTodayRankWin eid
         */

        /**
         * Constructs a new UserSetTodayRankWin.
         * @memberof msgProto
         * @classdesc Represents a UserSetTodayRankWin.
         * @implements IUserSetTodayRankWin
         * @constructor
         * @param {msgProto.IUserSetTodayRankWin=} [properties] Properties to set
         */
        function UserSetTodayRankWin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetTodayRankWin eid.
         * @member {number|Long} eid
         * @memberof msgProto.UserSetTodayRankWin
         * @instance
         */
        UserSetTodayRankWin.prototype.eid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new UserSetTodayRankWin instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {msgProto.IUserSetTodayRankWin=} [properties] Properties to set
         * @returns {msgProto.UserSetTodayRankWin} UserSetTodayRankWin instance
         */
        UserSetTodayRankWin.create = function create(properties) {
            return new UserSetTodayRankWin(properties);
        };

        /**
         * Encodes the specified UserSetTodayRankWin message. Does not implicitly {@link msgProto.UserSetTodayRankWin.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {msgProto.IUserSetTodayRankWin} message UserSetTodayRankWin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTodayRankWin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && message.hasOwnProperty("eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eid);
            return writer;
        };

        /**
         * Encodes the specified UserSetTodayRankWin message, length delimited. Does not implicitly {@link msgProto.UserSetTodayRankWin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {msgProto.IUserSetTodayRankWin} message UserSetTodayRankWin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetTodayRankWin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetTodayRankWin message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetTodayRankWin} UserSetTodayRankWin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTodayRankWin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetTodayRankWin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetTodayRankWin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSetTodayRankWin} UserSetTodayRankWin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetTodayRankWin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetTodayRankWin message.
         * @function verify
         * @memberof msgProto.UserSetTodayRankWin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetTodayRankWin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid) && !(message.eid && $util.isInteger(message.eid.low) && $util.isInteger(message.eid.high)))
                    return "eid: integer|Long expected";
            return null;
        };

        return UserSetTodayRankWin;
    })();

    msgProto.UserGetWarPrintedList = (function() {

        /**
         * Properties of a UserGetWarPrintedList.
         * @memberof msgProto
         * @interface IUserGetWarPrintedList
         */

        /**
         * Constructs a new UserGetWarPrintedList.
         * @memberof msgProto
         * @classdesc Represents a UserGetWarPrintedList.
         * @implements IUserGetWarPrintedList
         * @constructor
         * @param {msgProto.IUserGetWarPrintedList=} [properties] Properties to set
         */
        function UserGetWarPrintedList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetWarPrintedList instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {msgProto.IUserGetWarPrintedList=} [properties] Properties to set
         * @returns {msgProto.UserGetWarPrintedList} UserGetWarPrintedList instance
         */
        UserGetWarPrintedList.create = function create(properties) {
            return new UserGetWarPrintedList(properties);
        };

        /**
         * Encodes the specified UserGetWarPrintedList message. Does not implicitly {@link msgProto.UserGetWarPrintedList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {msgProto.IUserGetWarPrintedList} message UserGetWarPrintedList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWarPrintedList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetWarPrintedList message, length delimited. Does not implicitly {@link msgProto.UserGetWarPrintedList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {msgProto.IUserGetWarPrintedList} message UserGetWarPrintedList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWarPrintedList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetWarPrintedList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWarPrintedList} UserGetWarPrintedList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWarPrintedList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWarPrintedList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetWarPrintedList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetWarPrintedList} UserGetWarPrintedList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWarPrintedList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetWarPrintedList message.
         * @function verify
         * @memberof msgProto.UserGetWarPrintedList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetWarPrintedList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetWarPrintedList;
    })();

    msgProto.UserWarPrintedStrength = (function() {

        /**
         * Properties of a UserWarPrintedStrength.
         * @memberof msgProto
         * @interface IUserWarPrintedStrength
         * @property {number|null} [warPrintedId] UserWarPrintedStrength warPrintedId
         */

        /**
         * Constructs a new UserWarPrintedStrength.
         * @memberof msgProto
         * @classdesc Represents a UserWarPrintedStrength.
         * @implements IUserWarPrintedStrength
         * @constructor
         * @param {msgProto.IUserWarPrintedStrength=} [properties] Properties to set
         */
        function UserWarPrintedStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserWarPrintedStrength warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserWarPrintedStrength
         * @instance
         */
        UserWarPrintedStrength.prototype.warPrintedId = 0;

        /**
         * Creates a new UserWarPrintedStrength instance using the specified properties.
         * @function create
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {msgProto.IUserWarPrintedStrength=} [properties] Properties to set
         * @returns {msgProto.UserWarPrintedStrength} UserWarPrintedStrength instance
         */
        UserWarPrintedStrength.create = function create(properties) {
            return new UserWarPrintedStrength(properties);
        };

        /**
         * Encodes the specified UserWarPrintedStrength message. Does not implicitly {@link msgProto.UserWarPrintedStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {msgProto.IUserWarPrintedStrength} message UserWarPrintedStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserWarPrintedStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Encodes the specified UserWarPrintedStrength message, length delimited. Does not implicitly {@link msgProto.UserWarPrintedStrength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {msgProto.IUserWarPrintedStrength} message UserWarPrintedStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserWarPrintedStrength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserWarPrintedStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserWarPrintedStrength} UserWarPrintedStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserWarPrintedStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserWarPrintedStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserWarPrintedStrength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserWarPrintedStrength} UserWarPrintedStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserWarPrintedStrength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserWarPrintedStrength message.
         * @function verify
         * @memberof msgProto.UserWarPrintedStrength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserWarPrintedStrength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                if (!$util.isInteger(message.warPrintedId))
                    return "warPrintedId: integer expected";
            return null;
        };

        return UserWarPrintedStrength;
    })();

    msgProto.UserSetMedalTitle = (function() {

        /**
         * Properties of a UserSetMedalTitle.
         * @memberof msgProto
         * @interface IUserSetMedalTitle
         * @property {number|null} [warPrintedId] UserSetMedalTitle warPrintedId
         */

        /**
         * Constructs a new UserSetMedalTitle.
         * @memberof msgProto
         * @classdesc Represents a UserSetMedalTitle.
         * @implements IUserSetMedalTitle
         * @constructor
         * @param {msgProto.IUserSetMedalTitle=} [properties] Properties to set
         */
        function UserSetMedalTitle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetMedalTitle warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserSetMedalTitle
         * @instance
         */
        UserSetMedalTitle.prototype.warPrintedId = 0;

        /**
         * Creates a new UserSetMedalTitle instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {msgProto.IUserSetMedalTitle=} [properties] Properties to set
         * @returns {msgProto.UserSetMedalTitle} UserSetMedalTitle instance
         */
        UserSetMedalTitle.create = function create(properties) {
            return new UserSetMedalTitle(properties);
        };

        /**
         * Encodes the specified UserSetMedalTitle message. Does not implicitly {@link msgProto.UserSetMedalTitle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {msgProto.IUserSetMedalTitle} message UserSetMedalTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetMedalTitle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Encodes the specified UserSetMedalTitle message, length delimited. Does not implicitly {@link msgProto.UserSetMedalTitle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {msgProto.IUserSetMedalTitle} message UserSetMedalTitle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetMedalTitle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetMedalTitle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSetMedalTitle} UserSetMedalTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetMedalTitle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSetMedalTitle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetMedalTitle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSetMedalTitle} UserSetMedalTitle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetMedalTitle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetMedalTitle message.
         * @function verify
         * @memberof msgProto.UserSetMedalTitle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetMedalTitle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                if (!$util.isInteger(message.warPrintedId))
                    return "warPrintedId: integer expected";
            return null;
        };

        return UserSetMedalTitle;
    })();

    msgProto.UserGetGenuineQi = (function() {

        /**
         * Properties of a UserGetGenuineQi.
         * @memberof msgProto
         * @interface IUserGetGenuineQi
         */

        /**
         * Constructs a new UserGetGenuineQi.
         * @memberof msgProto
         * @classdesc Represents a UserGetGenuineQi.
         * @implements IUserGetGenuineQi
         * @constructor
         * @param {msgProto.IUserGetGenuineQi=} [properties] Properties to set
         */
        function UserGetGenuineQi(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetGenuineQi instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {msgProto.IUserGetGenuineQi=} [properties] Properties to set
         * @returns {msgProto.UserGetGenuineQi} UserGetGenuineQi instance
         */
        UserGetGenuineQi.create = function create(properties) {
            return new UserGetGenuineQi(properties);
        };

        /**
         * Encodes the specified UserGetGenuineQi message. Does not implicitly {@link msgProto.UserGetGenuineQi.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {msgProto.IUserGetGenuineQi} message UserGetGenuineQi message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetGenuineQi.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetGenuineQi message, length delimited. Does not implicitly {@link msgProto.UserGetGenuineQi.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {msgProto.IUserGetGenuineQi} message UserGetGenuineQi message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetGenuineQi.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetGenuineQi message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetGenuineQi} UserGetGenuineQi
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetGenuineQi.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetGenuineQi();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetGenuineQi message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetGenuineQi} UserGetGenuineQi
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetGenuineQi.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetGenuineQi message.
         * @function verify
         * @memberof msgProto.UserGetGenuineQi
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetGenuineQi.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetGenuineQi;
    })();

    msgProto.UserActiveMedal = (function() {

        /**
         * Properties of a UserActiveMedal.
         * @memberof msgProto
         * @interface IUserActiveMedal
         * @property {number|null} [warPrintedId] UserActiveMedal warPrintedId
         */

        /**
         * Constructs a new UserActiveMedal.
         * @memberof msgProto
         * @classdesc Represents a UserActiveMedal.
         * @implements IUserActiveMedal
         * @constructor
         * @param {msgProto.IUserActiveMedal=} [properties] Properties to set
         */
        function UserActiveMedal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserActiveMedal warPrintedId.
         * @member {number} warPrintedId
         * @memberof msgProto.UserActiveMedal
         * @instance
         */
        UserActiveMedal.prototype.warPrintedId = 0;

        /**
         * Creates a new UserActiveMedal instance using the specified properties.
         * @function create
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {msgProto.IUserActiveMedal=} [properties] Properties to set
         * @returns {msgProto.UserActiveMedal} UserActiveMedal instance
         */
        UserActiveMedal.create = function create(properties) {
            return new UserActiveMedal(properties);
        };

        /**
         * Encodes the specified UserActiveMedal message. Does not implicitly {@link msgProto.UserActiveMedal.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {msgProto.IUserActiveMedal} message UserActiveMedal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserActiveMedal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.warPrintedId);
            return writer;
        };

        /**
         * Encodes the specified UserActiveMedal message, length delimited. Does not implicitly {@link msgProto.UserActiveMedal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {msgProto.IUserActiveMedal} message UserActiveMedal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserActiveMedal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserActiveMedal message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserActiveMedal} UserActiveMedal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserActiveMedal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserActiveMedal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warPrintedId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserActiveMedal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserActiveMedal} UserActiveMedal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserActiveMedal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserActiveMedal message.
         * @function verify
         * @memberof msgProto.UserActiveMedal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserActiveMedal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warPrintedId != null && message.hasOwnProperty("warPrintedId"))
                if (!$util.isInteger(message.warPrintedId))
                    return "warPrintedId: integer expected";
            return null;
        };

        return UserActiveMedal;
    })();

    msgProto.UserGetBindPhoneUrl = (function() {

        /**
         * Properties of a UserGetBindPhoneUrl.
         * @memberof msgProto
         * @interface IUserGetBindPhoneUrl
         */

        /**
         * Constructs a new UserGetBindPhoneUrl.
         * @memberof msgProto
         * @classdesc Represents a UserGetBindPhoneUrl.
         * @implements IUserGetBindPhoneUrl
         * @constructor
         * @param {msgProto.IUserGetBindPhoneUrl=} [properties] Properties to set
         */
        function UserGetBindPhoneUrl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UserGetBindPhoneUrl instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {msgProto.IUserGetBindPhoneUrl=} [properties] Properties to set
         * @returns {msgProto.UserGetBindPhoneUrl} UserGetBindPhoneUrl instance
         */
        UserGetBindPhoneUrl.create = function create(properties) {
            return new UserGetBindPhoneUrl(properties);
        };

        /**
         * Encodes the specified UserGetBindPhoneUrl message. Does not implicitly {@link msgProto.UserGetBindPhoneUrl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {msgProto.IUserGetBindPhoneUrl} message UserGetBindPhoneUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBindPhoneUrl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UserGetBindPhoneUrl message, length delimited. Does not implicitly {@link msgProto.UserGetBindPhoneUrl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {msgProto.IUserGetBindPhoneUrl} message UserGetBindPhoneUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetBindPhoneUrl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetBindPhoneUrl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetBindPhoneUrl} UserGetBindPhoneUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBindPhoneUrl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetBindPhoneUrl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetBindPhoneUrl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetBindPhoneUrl} UserGetBindPhoneUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetBindPhoneUrl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetBindPhoneUrl message.
         * @function verify
         * @memberof msgProto.UserGetBindPhoneUrl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetBindPhoneUrl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return UserGetBindPhoneUrl;
    })();

    msgProto.UserGetWanbagift = (function() {

        /**
         * Properties of a UserGetWanbagift.
         * @memberof msgProto
         * @interface IUserGetWanbagift
         * @property {string|null} [os] UserGetWanbagift os
         * @property {number|null} [giftId] UserGetWanbagift giftId
         */

        /**
         * Constructs a new UserGetWanbagift.
         * @memberof msgProto
         * @classdesc Represents a UserGetWanbagift.
         * @implements IUserGetWanbagift
         * @constructor
         * @param {msgProto.IUserGetWanbagift=} [properties] Properties to set
         */
        function UserGetWanbagift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserGetWanbagift os.
         * @member {string} os
         * @memberof msgProto.UserGetWanbagift
         * @instance
         */
        UserGetWanbagift.prototype.os = "";

        /**
         * UserGetWanbagift giftId.
         * @member {number} giftId
         * @memberof msgProto.UserGetWanbagift
         * @instance
         */
        UserGetWanbagift.prototype.giftId = 0;

        /**
         * Creates a new UserGetWanbagift instance using the specified properties.
         * @function create
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {msgProto.IUserGetWanbagift=} [properties] Properties to set
         * @returns {msgProto.UserGetWanbagift} UserGetWanbagift instance
         */
        UserGetWanbagift.create = function create(properties) {
            return new UserGetWanbagift(properties);
        };

        /**
         * Encodes the specified UserGetWanbagift message. Does not implicitly {@link msgProto.UserGetWanbagift.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {msgProto.IUserGetWanbagift} message UserGetWanbagift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWanbagift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.os != null && message.hasOwnProperty("os"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.os);
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.giftId);
            return writer;
        };

        /**
         * Encodes the specified UserGetWanbagift message, length delimited. Does not implicitly {@link msgProto.UserGetWanbagift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {msgProto.IUserGetWanbagift} message UserGetWanbagift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserGetWanbagift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserGetWanbagift message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserGetWanbagift} UserGetWanbagift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWanbagift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserGetWanbagift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.os = reader.string();
                    break;
                case 2:
                    message.giftId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserGetWanbagift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserGetWanbagift} UserGetWanbagift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserGetWanbagift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserGetWanbagift message.
         * @function verify
         * @memberof msgProto.UserGetWanbagift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserGetWanbagift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.os != null && message.hasOwnProperty("os"))
                if (!$util.isString(message.os))
                    return "os: string expected";
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
            return null;
        };

        return UserGetWanbagift;
    })();

    msgProto.UserUpdateSetting = (function() {

        /**
         * Properties of a UserUpdateSetting.
         * @memberof msgProto
         * @interface IUserUpdateSetting
         * @property {boolean|null} [catNoVipChat] UserUpdateSetting catNoVipChat
         * @property {boolean|null} [autoBuyLittleHorn] UserUpdateSetting autoBuyLittleHorn
         */

        /**
         * Constructs a new UserUpdateSetting.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateSetting.
         * @implements IUserUpdateSetting
         * @constructor
         * @param {msgProto.IUserUpdateSetting=} [properties] Properties to set
         */
        function UserUpdateSetting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateSetting catNoVipChat.
         * @member {boolean} catNoVipChat
         * @memberof msgProto.UserUpdateSetting
         * @instance
         */
        UserUpdateSetting.prototype.catNoVipChat = false;

        /**
         * UserUpdateSetting autoBuyLittleHorn.
         * @member {boolean} autoBuyLittleHorn
         * @memberof msgProto.UserUpdateSetting
         * @instance
         */
        UserUpdateSetting.prototype.autoBuyLittleHorn = false;

        /**
         * Creates a new UserUpdateSetting instance using the specified properties.
         * @function create
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {msgProto.IUserUpdateSetting=} [properties] Properties to set
         * @returns {msgProto.UserUpdateSetting} UserUpdateSetting instance
         */
        UserUpdateSetting.create = function create(properties) {
            return new UserUpdateSetting(properties);
        };

        /**
         * Encodes the specified UserUpdateSetting message. Does not implicitly {@link msgProto.UserUpdateSetting.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {msgProto.IUserUpdateSetting} message UserUpdateSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.catNoVipChat != null && message.hasOwnProperty("catNoVipChat"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.catNoVipChat);
            if (message.autoBuyLittleHorn != null && message.hasOwnProperty("autoBuyLittleHorn"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoBuyLittleHorn);
            return writer;
        };

        /**
         * Encodes the specified UserUpdateSetting message, length delimited. Does not implicitly {@link msgProto.UserUpdateSetting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {msgProto.IUserUpdateSetting} message UserUpdateSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateSetting.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUpdateSetting message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateSetting} UserUpdateSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateSetting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.catNoVipChat = reader.bool();
                    break;
                case 2:
                    message.autoBuyLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUpdateSetting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserUpdateSetting} UserUpdateSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateSetting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUpdateSetting message.
         * @function verify
         * @memberof msgProto.UserUpdateSetting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUpdateSetting.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.catNoVipChat != null && message.hasOwnProperty("catNoVipChat"))
                if (typeof message.catNoVipChat !== "boolean")
                    return "catNoVipChat: boolean expected";
            if (message.autoBuyLittleHorn != null && message.hasOwnProperty("autoBuyLittleHorn"))
                if (typeof message.autoBuyLittleHorn !== "boolean")
                    return "autoBuyLittleHorn: boolean expected";
            return null;
        };

        return UserUpdateSetting;
    })();

    msgProto.UserUpdateItems4Bag = (function() {

        /**
         * Properties of a UserUpdateItems4Bag.
         * @memberof msgProto
         * @interface IUserUpdateItems4Bag
         * @property {number|null} [itemId] UserUpdateItems4Bag itemId
         */

        /**
         * Constructs a new UserUpdateItems4Bag.
         * @memberof msgProto
         * @classdesc Represents a UserUpdateItems4Bag.
         * @implements IUserUpdateItems4Bag
         * @constructor
         * @param {msgProto.IUserUpdateItems4Bag=} [properties] Properties to set
         */
        function UserUpdateItems4Bag(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserUpdateItems4Bag itemId.
         * @member {number} itemId
         * @memberof msgProto.UserUpdateItems4Bag
         * @instance
         */
        UserUpdateItems4Bag.prototype.itemId = 0;

        /**
         * Creates a new UserUpdateItems4Bag instance using the specified properties.
         * @function create
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {msgProto.IUserUpdateItems4Bag=} [properties] Properties to set
         * @returns {msgProto.UserUpdateItems4Bag} UserUpdateItems4Bag instance
         */
        UserUpdateItems4Bag.create = function create(properties) {
            return new UserUpdateItems4Bag(properties);
        };

        /**
         * Encodes the specified UserUpdateItems4Bag message. Does not implicitly {@link msgProto.UserUpdateItems4Bag.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {msgProto.IUserUpdateItems4Bag} message UserUpdateItems4Bag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateItems4Bag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Encodes the specified UserUpdateItems4Bag message, length delimited. Does not implicitly {@link msgProto.UserUpdateItems4Bag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {msgProto.IUserUpdateItems4Bag} message UserUpdateItems4Bag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserUpdateItems4Bag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserUpdateItems4Bag message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserUpdateItems4Bag} UserUpdateItems4Bag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateItems4Bag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserUpdateItems4Bag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserUpdateItems4Bag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserUpdateItems4Bag} UserUpdateItems4Bag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserUpdateItems4Bag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserUpdateItems4Bag message.
         * @function verify
         * @memberof msgProto.UserUpdateItems4Bag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserUpdateItems4Bag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            return null;
        };

        return UserUpdateItems4Bag;
    })();

    msgProto.FriendGetInfo = (function() {

        /**
         * Properties of a FriendGetInfo.
         * @memberof msgProto
         * @interface IFriendGetInfo
         */

        /**
         * Constructs a new FriendGetInfo.
         * @memberof msgProto
         * @classdesc Represents a FriendGetInfo.
         * @implements IFriendGetInfo
         * @constructor
         * @param {msgProto.IFriendGetInfo=} [properties] Properties to set
         */
        function FriendGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FriendGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {msgProto.IFriendGetInfo=} [properties] Properties to set
         * @returns {msgProto.FriendGetInfo} FriendGetInfo instance
         */
        FriendGetInfo.create = function create(properties) {
            return new FriendGetInfo(properties);
        };

        /**
         * Encodes the specified FriendGetInfo message. Does not implicitly {@link msgProto.FriendGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {msgProto.IFriendGetInfo} message FriendGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FriendGetInfo message, length delimited. Does not implicitly {@link msgProto.FriendGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {msgProto.IFriendGetInfo} message FriendGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendGetInfo} FriendGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FriendGetInfo} FriendGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendGetInfo message.
         * @function verify
         * @memberof msgProto.FriendGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FriendGetInfo;
    })();

    msgProto.FriendRequestFriend = (function() {

        /**
         * Properties of a FriendRequestFriend.
         * @memberof msgProto
         * @interface IFriendRequestFriend
         * @property {number|Long|null} [requestedId] FriendRequestFriend requestedId
         */

        /**
         * Constructs a new FriendRequestFriend.
         * @memberof msgProto
         * @classdesc Represents a FriendRequestFriend.
         * @implements IFriendRequestFriend
         * @constructor
         * @param {msgProto.IFriendRequestFriend=} [properties] Properties to set
         */
        function FriendRequestFriend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendRequestFriend requestedId.
         * @member {number|Long} requestedId
         * @memberof msgProto.FriendRequestFriend
         * @instance
         */
        FriendRequestFriend.prototype.requestedId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FriendRequestFriend instance using the specified properties.
         * @function create
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {msgProto.IFriendRequestFriend=} [properties] Properties to set
         * @returns {msgProto.FriendRequestFriend} FriendRequestFriend instance
         */
        FriendRequestFriend.create = function create(properties) {
            return new FriendRequestFriend(properties);
        };

        /**
         * Encodes the specified FriendRequestFriend message. Does not implicitly {@link msgProto.FriendRequestFriend.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {msgProto.IFriendRequestFriend} message FriendRequestFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendRequestFriend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestedId != null && message.hasOwnProperty("requestedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestedId);
            return writer;
        };

        /**
         * Encodes the specified FriendRequestFriend message, length delimited. Does not implicitly {@link msgProto.FriendRequestFriend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {msgProto.IFriendRequestFriend} message FriendRequestFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendRequestFriend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendRequestFriend message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendRequestFriend} FriendRequestFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRequestFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendRequestFriend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestedId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendRequestFriend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FriendRequestFriend} FriendRequestFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendRequestFriend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendRequestFriend message.
         * @function verify
         * @memberof msgProto.FriendRequestFriend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendRequestFriend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestedId != null && message.hasOwnProperty("requestedId"))
                if (!$util.isInteger(message.requestedId) && !(message.requestedId && $util.isInteger(message.requestedId.low) && $util.isInteger(message.requestedId.high)))
                    return "requestedId: integer|Long expected";
            return null;
        };

        return FriendRequestFriend;
    })();

    msgProto.FriendDisposeFriendRequest = (function() {

        /**
         * Properties of a FriendDisposeFriendRequest.
         * @memberof msgProto
         * @interface IFriendDisposeFriendRequest
         * @property {number|Long|null} [requestId] FriendDisposeFriendRequest requestId
         * @property {boolean|null} [isTake] FriendDisposeFriendRequest isTake
         */

        /**
         * Constructs a new FriendDisposeFriendRequest.
         * @memberof msgProto
         * @classdesc Represents a FriendDisposeFriendRequest.
         * @implements IFriendDisposeFriendRequest
         * @constructor
         * @param {msgProto.IFriendDisposeFriendRequest=} [properties] Properties to set
         */
        function FriendDisposeFriendRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendDisposeFriendRequest requestId.
         * @member {number|Long} requestId
         * @memberof msgProto.FriendDisposeFriendRequest
         * @instance
         */
        FriendDisposeFriendRequest.prototype.requestId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FriendDisposeFriendRequest isTake.
         * @member {boolean} isTake
         * @memberof msgProto.FriendDisposeFriendRequest
         * @instance
         */
        FriendDisposeFriendRequest.prototype.isTake = false;

        /**
         * Creates a new FriendDisposeFriendRequest instance using the specified properties.
         * @function create
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {msgProto.IFriendDisposeFriendRequest=} [properties] Properties to set
         * @returns {msgProto.FriendDisposeFriendRequest} FriendDisposeFriendRequest instance
         */
        FriendDisposeFriendRequest.create = function create(properties) {
            return new FriendDisposeFriendRequest(properties);
        };

        /**
         * Encodes the specified FriendDisposeFriendRequest message. Does not implicitly {@link msgProto.FriendDisposeFriendRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {msgProto.IFriendDisposeFriendRequest} message FriendDisposeFriendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendDisposeFriendRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.requestId);
            if (message.isTake != null && message.hasOwnProperty("isTake"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isTake);
            return writer;
        };

        /**
         * Encodes the specified FriendDisposeFriendRequest message, length delimited. Does not implicitly {@link msgProto.FriendDisposeFriendRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {msgProto.IFriendDisposeFriendRequest} message FriendDisposeFriendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendDisposeFriendRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendDisposeFriendRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendDisposeFriendRequest} FriendDisposeFriendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendDisposeFriendRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendDisposeFriendRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint64();
                    break;
                case 2:
                    message.isTake = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendDisposeFriendRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FriendDisposeFriendRequest} FriendDisposeFriendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendDisposeFriendRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendDisposeFriendRequest message.
         * @function verify
         * @memberof msgProto.FriendDisposeFriendRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendDisposeFriendRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId) && !(message.requestId && $util.isInteger(message.requestId.low) && $util.isInteger(message.requestId.high)))
                    return "requestId: integer|Long expected";
            if (message.isTake != null && message.hasOwnProperty("isTake"))
                if (typeof message.isTake !== "boolean")
                    return "isTake: boolean expected";
            return null;
        };

        return FriendDisposeFriendRequest;
    })();

    msgProto.FriendEventCheer = (function() {

        /**
         * Properties of a FriendEventCheer.
         * @memberof msgProto
         * @interface IFriendEventCheer
         */

        /**
         * Constructs a new FriendEventCheer.
         * @memberof msgProto
         * @classdesc Represents a FriendEventCheer.
         * @implements IFriendEventCheer
         * @constructor
         * @param {msgProto.IFriendEventCheer=} [properties] Properties to set
         */
        function FriendEventCheer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FriendEventCheer instance using the specified properties.
         * @function create
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {msgProto.IFriendEventCheer=} [properties] Properties to set
         * @returns {msgProto.FriendEventCheer} FriendEventCheer instance
         */
        FriendEventCheer.create = function create(properties) {
            return new FriendEventCheer(properties);
        };

        /**
         * Encodes the specified FriendEventCheer message. Does not implicitly {@link msgProto.FriendEventCheer.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {msgProto.IFriendEventCheer} message FriendEventCheer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendEventCheer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FriendEventCheer message, length delimited. Does not implicitly {@link msgProto.FriendEventCheer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {msgProto.IFriendEventCheer} message FriendEventCheer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendEventCheer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendEventCheer message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendEventCheer} FriendEventCheer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendEventCheer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendEventCheer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendEventCheer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FriendEventCheer} FriendEventCheer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendEventCheer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendEventCheer message.
         * @function verify
         * @memberof msgProto.FriendEventCheer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendEventCheer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FriendEventCheer;
    })();

    msgProto.FriendGetRequestInfo = (function() {

        /**
         * Properties of a FriendGetRequestInfo.
         * @memberof msgProto
         * @interface IFriendGetRequestInfo
         */

        /**
         * Constructs a new FriendGetRequestInfo.
         * @memberof msgProto
         * @classdesc Represents a FriendGetRequestInfo.
         * @implements IFriendGetRequestInfo
         * @constructor
         * @param {msgProto.IFriendGetRequestInfo=} [properties] Properties to set
         */
        function FriendGetRequestInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FriendGetRequestInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {msgProto.IFriendGetRequestInfo=} [properties] Properties to set
         * @returns {msgProto.FriendGetRequestInfo} FriendGetRequestInfo instance
         */
        FriendGetRequestInfo.create = function create(properties) {
            return new FriendGetRequestInfo(properties);
        };

        /**
         * Encodes the specified FriendGetRequestInfo message. Does not implicitly {@link msgProto.FriendGetRequestInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {msgProto.IFriendGetRequestInfo} message FriendGetRequestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetRequestInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FriendGetRequestInfo message, length delimited. Does not implicitly {@link msgProto.FriendGetRequestInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {msgProto.IFriendGetRequestInfo} message FriendGetRequestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendGetRequestInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendGetRequestInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FriendGetRequestInfo} FriendGetRequestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetRequestInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FriendGetRequestInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendGetRequestInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FriendGetRequestInfo} FriendGetRequestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendGetRequestInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendGetRequestInfo message.
         * @function verify
         * @memberof msgProto.FriendGetRequestInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendGetRequestInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FriendGetRequestInfo;
    })();

    msgProto.FightPickLoot = (function() {

        /**
         * Properties of a FightPickLoot.
         * @memberof msgProto
         * @interface IFightPickLoot
         * @property {number|null} [copyId] FightPickLoot copyId
         * @property {string|null} [uidArr] FightPickLoot uidArr
         * @property {string|null} [fightData] FightPickLoot fightData
         */

        /**
         * Constructs a new FightPickLoot.
         * @memberof msgProto
         * @classdesc Represents a FightPickLoot.
         * @implements IFightPickLoot
         * @constructor
         * @param {msgProto.IFightPickLoot=} [properties] Properties to set
         */
        function FightPickLoot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightPickLoot copyId.
         * @member {number} copyId
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.copyId = 0;

        /**
         * FightPickLoot uidArr.
         * @member {string} uidArr
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.uidArr = "";

        /**
         * FightPickLoot fightData.
         * @member {string} fightData
         * @memberof msgProto.FightPickLoot
         * @instance
         */
        FightPickLoot.prototype.fightData = "";

        /**
         * Creates a new FightPickLoot instance using the specified properties.
         * @function create
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {msgProto.IFightPickLoot=} [properties] Properties to set
         * @returns {msgProto.FightPickLoot} FightPickLoot instance
         */
        FightPickLoot.create = function create(properties) {
            return new FightPickLoot(properties);
        };

        /**
         * Encodes the specified FightPickLoot message. Does not implicitly {@link msgProto.FightPickLoot.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {msgProto.IFightPickLoot} message FightPickLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightPickLoot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.uidArr != null && message.hasOwnProperty("uidArr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.uidArr);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Encodes the specified FightPickLoot message, length delimited. Does not implicitly {@link msgProto.FightPickLoot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {msgProto.IFightPickLoot} message FightPickLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightPickLoot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightPickLoot message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightPickLoot} FightPickLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightPickLoot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightPickLoot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.uidArr = reader.string();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightPickLoot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FightPickLoot} FightPickLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightPickLoot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightPickLoot message.
         * @function verify
         * @memberof msgProto.FightPickLoot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightPickLoot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.uidArr != null && message.hasOwnProperty("uidArr"))
                if (!$util.isString(message.uidArr))
                    return "uidArr: string expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            return null;
        };

        return FightPickLoot;
    })();

    msgProto.FightRevive = (function() {

        /**
         * Properties of a FightRevive.
         * @memberof msgProto
         * @interface IFightRevive
         */

        /**
         * Constructs a new FightRevive.
         * @memberof msgProto
         * @classdesc Represents a FightRevive.
         * @implements IFightRevive
         * @constructor
         * @param {msgProto.IFightRevive=} [properties] Properties to set
         */
        function FightRevive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FightRevive instance using the specified properties.
         * @function create
         * @memberof msgProto.FightRevive
         * @static
         * @param {msgProto.IFightRevive=} [properties] Properties to set
         * @returns {msgProto.FightRevive} FightRevive instance
         */
        FightRevive.create = function create(properties) {
            return new FightRevive(properties);
        };

        /**
         * Encodes the specified FightRevive message. Does not implicitly {@link msgProto.FightRevive.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightRevive
         * @static
         * @param {msgProto.IFightRevive} message FightRevive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRevive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FightRevive message, length delimited. Does not implicitly {@link msgProto.FightRevive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FightRevive
         * @static
         * @param {msgProto.IFightRevive} message FightRevive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRevive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightRevive message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightRevive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightRevive} FightRevive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRevive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightRevive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightRevive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FightRevive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FightRevive} FightRevive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRevive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightRevive message.
         * @function verify
         * @memberof msgProto.FightRevive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightRevive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FightRevive;
    })();

    msgProto.FightGetAndInitNextLoot = (function() {

        /**
         * Properties of a FightGetAndInitNextLoot.
         * @memberof msgProto
         * @interface IFightGetAndInitNextLoot
         * @property {number|null} [copyId] FightGetAndInitNextLoot copyId
         * @property {boolean|null} [isBoss] FightGetAndInitNextLoot isBoss
         * @property {number|null} [lvl] FightGetAndInitNextLoot lvl
         */

        /**
         * Constructs a new FightGetAndInitNextLoot.
         * @memberof msgProto
         * @classdesc Represents a FightGetAndInitNextLoot.
         * @implements IFightGetAndInitNextLoot
         * @constructor
         * @param {msgProto.IFightGetAndInitNextLoot=} [properties] Properties to set
         */
        function FightGetAndInitNextLoot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightGetAndInitNextLoot copyId.
         * @member {number} copyId
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.copyId = 0;

        /**
         * FightGetAndInitNextLoot isBoss.
         * @member {boolean} isBoss
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.isBoss = false;

        /**
         * FightGetAndInitNextLoot lvl.
         * @member {number} lvl
         * @memberof msgProto.FightGetAndInitNextLoot
         * @instance
         */
        FightGetAndInitNextLoot.prototype.lvl = 0;

        /**
         * Creates a new FightGetAndInitNextLoot instance using the specified properties.
         * @function create
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {msgProto.IFightGetAndInitNextLoot=} [properties] Properties to set
         * @returns {msgProto.FightGetAndInitNextLoot} FightGetAndInitNextLoot instance
         */
        FightGetAndInitNextLoot.create = function create(properties) {
            return new FightGetAndInitNextLoot(properties);
        };

        /**
         * Encodes the specified FightGetAndInitNextLoot message. Does not implicitly {@link msgProto.FightGetAndInitNextLoot.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {msgProto.IFightGetAndInitNextLoot} message FightGetAndInitNextLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightGetAndInitNextLoot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.isBoss != null && message.hasOwnProperty("isBoss"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBoss);
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lvl);
            return writer;
        };

        /**
         * Encodes the specified FightGetAndInitNextLoot message, length delimited. Does not implicitly {@link msgProto.FightGetAndInitNextLoot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {msgProto.IFightGetAndInitNextLoot} message FightGetAndInitNextLoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightGetAndInitNextLoot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightGetAndInitNextLoot message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FightGetAndInitNextLoot} FightGetAndInitNextLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightGetAndInitNextLoot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FightGetAndInitNextLoot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.isBoss = reader.bool();
                    break;
                case 3:
                    message.lvl = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightGetAndInitNextLoot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FightGetAndInitNextLoot} FightGetAndInitNextLoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightGetAndInitNextLoot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightGetAndInitNextLoot message.
         * @function verify
         * @memberof msgProto.FightGetAndInitNextLoot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightGetAndInitNextLoot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.isBoss != null && message.hasOwnProperty("isBoss"))
                if (typeof message.isBoss !== "boolean")
                    return "isBoss: boolean expected";
            if (message.lvl != null && message.hasOwnProperty("lvl"))
                if (!$util.isInteger(message.lvl))
                    return "lvl: integer expected";
            return null;
        };

        return FightGetAndInitNextLoot;
    })();

    msgProto.FiveDaysTargetGetInfo = (function() {

        /**
         * Properties of a FiveDaysTargetGetInfo.
         * @memberof msgProto
         * @interface IFiveDaysTargetGetInfo
         */

        /**
         * Constructs a new FiveDaysTargetGetInfo.
         * @memberof msgProto
         * @classdesc Represents a FiveDaysTargetGetInfo.
         * @implements IFiveDaysTargetGetInfo
         * @constructor
         * @param {msgProto.IFiveDaysTargetGetInfo=} [properties] Properties to set
         */
        function FiveDaysTargetGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FiveDaysTargetGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo=} [properties] Properties to set
         * @returns {msgProto.FiveDaysTargetGetInfo} FiveDaysTargetGetInfo instance
         */
        FiveDaysTargetGetInfo.create = function create(properties) {
            return new FiveDaysTargetGetInfo(properties);
        };

        /**
         * Encodes the specified FiveDaysTargetGetInfo message. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo} message FiveDaysTargetGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FiveDaysTargetGetInfo message, length delimited. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo} message FiveDaysTargetGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FiveDaysTargetGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FiveDaysTargetGetInfo} FiveDaysTargetGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FiveDaysTargetGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FiveDaysTargetGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FiveDaysTargetGetInfo} FiveDaysTargetGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FiveDaysTargetGetInfo message.
         * @function verify
         * @memberof msgProto.FiveDaysTargetGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FiveDaysTargetGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FiveDaysTargetGetInfo;
    })();

    msgProto.FiveDaysTargetGetInfo1 = (function() {

        /**
         * Properties of a FiveDaysTargetGetInfo1.
         * @memberof msgProto
         * @interface IFiveDaysTargetGetInfo1
         */

        /**
         * Constructs a new FiveDaysTargetGetInfo1.
         * @memberof msgProto
         * @classdesc Represents a FiveDaysTargetGetInfo1.
         * @implements IFiveDaysTargetGetInfo1
         * @constructor
         * @param {msgProto.IFiveDaysTargetGetInfo1=} [properties] Properties to set
         */
        function FiveDaysTargetGetInfo1(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FiveDaysTargetGetInfo1 instance using the specified properties.
         * @function create
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo1=} [properties] Properties to set
         * @returns {msgProto.FiveDaysTargetGetInfo1} FiveDaysTargetGetInfo1 instance
         */
        FiveDaysTargetGetInfo1.create = function create(properties) {
            return new FiveDaysTargetGetInfo1(properties);
        };

        /**
         * Encodes the specified FiveDaysTargetGetInfo1 message. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo1.verify|verify} messages.
         * @function encode
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo1} message FiveDaysTargetGetInfo1 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo1.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FiveDaysTargetGetInfo1 message, length delimited. Does not implicitly {@link msgProto.FiveDaysTargetGetInfo1.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {msgProto.IFiveDaysTargetGetInfo1} message FiveDaysTargetGetInfo1 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FiveDaysTargetGetInfo1.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FiveDaysTargetGetInfo1 message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.FiveDaysTargetGetInfo1} FiveDaysTargetGetInfo1
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo1.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.FiveDaysTargetGetInfo1();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FiveDaysTargetGetInfo1 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.FiveDaysTargetGetInfo1} FiveDaysTargetGetInfo1
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FiveDaysTargetGetInfo1.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FiveDaysTargetGetInfo1 message.
         * @function verify
         * @memberof msgProto.FiveDaysTargetGetInfo1
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FiveDaysTargetGetInfo1.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FiveDaysTargetGetInfo1;
    })();

    msgProto.GuildGetInfo = (function() {

        /**
         * Properties of a GuildGetInfo.
         * @memberof msgProto
         * @interface IGuildGetInfo
         */

        /**
         * Constructs a new GuildGetInfo.
         * @memberof msgProto
         * @classdesc Represents a GuildGetInfo.
         * @implements IGuildGetInfo
         * @constructor
         * @param {msgProto.IGuildGetInfo=} [properties] Properties to set
         */
        function GuildGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {msgProto.IGuildGetInfo=} [properties] Properties to set
         * @returns {msgProto.GuildGetInfo} GuildGetInfo instance
         */
        GuildGetInfo.create = function create(properties) {
            return new GuildGetInfo(properties);
        };

        /**
         * Encodes the specified GuildGetInfo message. Does not implicitly {@link msgProto.GuildGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {msgProto.IGuildGetInfo} message GuildGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildGetInfo message, length delimited. Does not implicitly {@link msgProto.GuildGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {msgProto.IGuildGetInfo} message GuildGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGetInfo} GuildGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildGetInfo} GuildGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildGetInfo message.
         * @function verify
         * @memberof msgProto.GuildGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildGetInfo;
    })();

    msgProto.GuildEstablishGuild = (function() {

        /**
         * Properties of a GuildEstablishGuild.
         * @memberof msgProto
         * @interface IGuildEstablishGuild
         * @property {string|null} [name] GuildEstablishGuild name
         */

        /**
         * Constructs a new GuildEstablishGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildEstablishGuild.
         * @implements IGuildEstablishGuild
         * @constructor
         * @param {msgProto.IGuildEstablishGuild=} [properties] Properties to set
         */
        function GuildEstablishGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildEstablishGuild name.
         * @member {string} name
         * @memberof msgProto.GuildEstablishGuild
         * @instance
         */
        GuildEstablishGuild.prototype.name = "";

        /**
         * Creates a new GuildEstablishGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {msgProto.IGuildEstablishGuild=} [properties] Properties to set
         * @returns {msgProto.GuildEstablishGuild} GuildEstablishGuild instance
         */
        GuildEstablishGuild.create = function create(properties) {
            return new GuildEstablishGuild(properties);
        };

        /**
         * Encodes the specified GuildEstablishGuild message. Does not implicitly {@link msgProto.GuildEstablishGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {msgProto.IGuildEstablishGuild} message GuildEstablishGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildEstablishGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified GuildEstablishGuild message, length delimited. Does not implicitly {@link msgProto.GuildEstablishGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {msgProto.IGuildEstablishGuild} message GuildEstablishGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildEstablishGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildEstablishGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildEstablishGuild} GuildEstablishGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildEstablishGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildEstablishGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildEstablishGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildEstablishGuild} GuildEstablishGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildEstablishGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildEstablishGuild message.
         * @function verify
         * @memberof msgProto.GuildEstablishGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildEstablishGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        return GuildEstablishGuild;
    })();

    msgProto.GuildSeekGuild = (function() {

        /**
         * Properties of a GuildSeekGuild.
         * @memberof msgProto
         * @interface IGuildSeekGuild
         * @property {number|null} [guildId] GuildSeekGuild guildId
         */

        /**
         * Constructs a new GuildSeekGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildSeekGuild.
         * @implements IGuildSeekGuild
         * @constructor
         * @param {msgProto.IGuildSeekGuild=} [properties] Properties to set
         */
        function GuildSeekGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSeekGuild guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildSeekGuild
         * @instance
         */
        GuildSeekGuild.prototype.guildId = 0;

        /**
         * Creates a new GuildSeekGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {msgProto.IGuildSeekGuild=} [properties] Properties to set
         * @returns {msgProto.GuildSeekGuild} GuildSeekGuild instance
         */
        GuildSeekGuild.create = function create(properties) {
            return new GuildSeekGuild(properties);
        };

        /**
         * Encodes the specified GuildSeekGuild message. Does not implicitly {@link msgProto.GuildSeekGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {msgProto.IGuildSeekGuild} message GuildSeekGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSeekGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildSeekGuild message, length delimited. Does not implicitly {@link msgProto.GuildSeekGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {msgProto.IGuildSeekGuild} message GuildSeekGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSeekGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildSeekGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSeekGuild} GuildSeekGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSeekGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSeekGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildSeekGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildSeekGuild} GuildSeekGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSeekGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildSeekGuild message.
         * @function verify
         * @memberof msgProto.GuildSeekGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildSeekGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildSeekGuild;
    })();

    msgProto.GuildJoinGuild = (function() {

        /**
         * Properties of a GuildJoinGuild.
         * @memberof msgProto
         * @interface IGuildJoinGuild
         * @property {number|null} [guildId] GuildJoinGuild guildId
         */

        /**
         * Constructs a new GuildJoinGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildJoinGuild.
         * @implements IGuildJoinGuild
         * @constructor
         * @param {msgProto.IGuildJoinGuild=} [properties] Properties to set
         */
        function GuildJoinGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildJoinGuild guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildJoinGuild
         * @instance
         */
        GuildJoinGuild.prototype.guildId = 0;

        /**
         * Creates a new GuildJoinGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {msgProto.IGuildJoinGuild=} [properties] Properties to set
         * @returns {msgProto.GuildJoinGuild} GuildJoinGuild instance
         */
        GuildJoinGuild.create = function create(properties) {
            return new GuildJoinGuild(properties);
        };

        /**
         * Encodes the specified GuildJoinGuild message. Does not implicitly {@link msgProto.GuildJoinGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {msgProto.IGuildJoinGuild} message GuildJoinGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildJoinGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildJoinGuild message, length delimited. Does not implicitly {@link msgProto.GuildJoinGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {msgProto.IGuildJoinGuild} message GuildJoinGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildJoinGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildJoinGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildJoinGuild} GuildJoinGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildJoinGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildJoinGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildJoinGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildJoinGuild} GuildJoinGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildJoinGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildJoinGuild message.
         * @function verify
         * @memberof msgProto.GuildJoinGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildJoinGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildJoinGuild;
    })();

    msgProto.GuildGetAppliedMembers = (function() {

        /**
         * Properties of a GuildGetAppliedMembers.
         * @memberof msgProto
         * @interface IGuildGetAppliedMembers
         */

        /**
         * Constructs a new GuildGetAppliedMembers.
         * @memberof msgProto
         * @classdesc Represents a GuildGetAppliedMembers.
         * @implements IGuildGetAppliedMembers
         * @constructor
         * @param {msgProto.IGuildGetAppliedMembers=} [properties] Properties to set
         */
        function GuildGetAppliedMembers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildGetAppliedMembers instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {msgProto.IGuildGetAppliedMembers=} [properties] Properties to set
         * @returns {msgProto.GuildGetAppliedMembers} GuildGetAppliedMembers instance
         */
        GuildGetAppliedMembers.create = function create(properties) {
            return new GuildGetAppliedMembers(properties);
        };

        /**
         * Encodes the specified GuildGetAppliedMembers message. Does not implicitly {@link msgProto.GuildGetAppliedMembers.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {msgProto.IGuildGetAppliedMembers} message GuildGetAppliedMembers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetAppliedMembers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildGetAppliedMembers message, length delimited. Does not implicitly {@link msgProto.GuildGetAppliedMembers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {msgProto.IGuildGetAppliedMembers} message GuildGetAppliedMembers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGetAppliedMembers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildGetAppliedMembers message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGetAppliedMembers} GuildGetAppliedMembers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetAppliedMembers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGetAppliedMembers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildGetAppliedMembers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildGetAppliedMembers} GuildGetAppliedMembers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGetAppliedMembers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildGetAppliedMembers message.
         * @function verify
         * @memberof msgProto.GuildGetAppliedMembers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildGetAppliedMembers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildGetAppliedMembers;
    })();

    msgProto.GuildAppliedMembersSet = (function() {

        /**
         * Properties of a GuildAppliedMembersSet.
         * @memberof msgProto
         * @interface IGuildAppliedMembersSet
         * @property {number|Long|null} [tUserId] GuildAppliedMembersSet tUserId
         * @property {boolean|null} [isConsent] GuildAppliedMembersSet isConsent
         */

        /**
         * Constructs a new GuildAppliedMembersSet.
         * @memberof msgProto
         * @classdesc Represents a GuildAppliedMembersSet.
         * @implements IGuildAppliedMembersSet
         * @constructor
         * @param {msgProto.IGuildAppliedMembersSet=} [properties] Properties to set
         */
        function GuildAppliedMembersSet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildAppliedMembersSet tUserId.
         * @member {number|Long} tUserId
         * @memberof msgProto.GuildAppliedMembersSet
         * @instance
         */
        GuildAppliedMembersSet.prototype.tUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GuildAppliedMembersSet isConsent.
         * @member {boolean} isConsent
         * @memberof msgProto.GuildAppliedMembersSet
         * @instance
         */
        GuildAppliedMembersSet.prototype.isConsent = false;

        /**
         * Creates a new GuildAppliedMembersSet instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {msgProto.IGuildAppliedMembersSet=} [properties] Properties to set
         * @returns {msgProto.GuildAppliedMembersSet} GuildAppliedMembersSet instance
         */
        GuildAppliedMembersSet.create = function create(properties) {
            return new GuildAppliedMembersSet(properties);
        };

        /**
         * Encodes the specified GuildAppliedMembersSet message. Does not implicitly {@link msgProto.GuildAppliedMembersSet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {msgProto.IGuildAppliedMembersSet} message GuildAppliedMembersSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildAppliedMembersSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tUserId != null && message.hasOwnProperty("tUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tUserId);
            if (message.isConsent != null && message.hasOwnProperty("isConsent"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isConsent);
            return writer;
        };

        /**
         * Encodes the specified GuildAppliedMembersSet message, length delimited. Does not implicitly {@link msgProto.GuildAppliedMembersSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {msgProto.IGuildAppliedMembersSet} message GuildAppliedMembersSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildAppliedMembersSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildAppliedMembersSet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildAppliedMembersSet} GuildAppliedMembersSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildAppliedMembersSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildAppliedMembersSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tUserId = reader.uint64();
                    break;
                case 2:
                    message.isConsent = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildAppliedMembersSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildAppliedMembersSet} GuildAppliedMembersSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildAppliedMembersSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildAppliedMembersSet message.
         * @function verify
         * @memberof msgProto.GuildAppliedMembersSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildAppliedMembersSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tUserId != null && message.hasOwnProperty("tUserId"))
                if (!$util.isInteger(message.tUserId) && !(message.tUserId && $util.isInteger(message.tUserId.low) && $util.isInteger(message.tUserId.high)))
                    return "tUserId: integer|Long expected";
            if (message.isConsent != null && message.hasOwnProperty("isConsent"))
                if (typeof message.isConsent !== "boolean")
                    return "isConsent: boolean expected";
            return null;
        };

        return GuildAppliedMembersSet;
    })();

    msgProto.GuildGuildSetting = (function() {

        /**
         * Properties of a GuildGuildSetting.
         * @memberof msgProto
         * @interface IGuildGuildSetting
         * @property {string|null} [joinCon] GuildGuildSetting joinCon
         * @property {number|null} [joinLvl] GuildGuildSetting joinLvl
         */

        /**
         * Constructs a new GuildGuildSetting.
         * @memberof msgProto
         * @classdesc Represents a GuildGuildSetting.
         * @implements IGuildGuildSetting
         * @constructor
         * @param {msgProto.IGuildGuildSetting=} [properties] Properties to set
         */
        function GuildGuildSetting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildGuildSetting joinCon.
         * @member {string} joinCon
         * @memberof msgProto.GuildGuildSetting
         * @instance
         */
        GuildGuildSetting.prototype.joinCon = "";

        /**
         * GuildGuildSetting joinLvl.
         * @member {number} joinLvl
         * @memberof msgProto.GuildGuildSetting
         * @instance
         */
        GuildGuildSetting.prototype.joinLvl = 0;

        /**
         * Creates a new GuildGuildSetting instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {msgProto.IGuildGuildSetting=} [properties] Properties to set
         * @returns {msgProto.GuildGuildSetting} GuildGuildSetting instance
         */
        GuildGuildSetting.create = function create(properties) {
            return new GuildGuildSetting(properties);
        };

        /**
         * Encodes the specified GuildGuildSetting message. Does not implicitly {@link msgProto.GuildGuildSetting.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {msgProto.IGuildGuildSetting} message GuildGuildSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGuildSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.joinCon != null && message.hasOwnProperty("joinCon"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.joinCon);
            if (message.joinLvl != null && message.hasOwnProperty("joinLvl"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.joinLvl);
            return writer;
        };

        /**
         * Encodes the specified GuildGuildSetting message, length delimited. Does not implicitly {@link msgProto.GuildGuildSetting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {msgProto.IGuildGuildSetting} message GuildGuildSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildGuildSetting.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildGuildSetting message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildGuildSetting} GuildGuildSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGuildSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildGuildSetting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.joinCon = reader.string();
                    break;
                case 2:
                    message.joinLvl = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildGuildSetting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildGuildSetting} GuildGuildSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildGuildSetting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildGuildSetting message.
         * @function verify
         * @memberof msgProto.GuildGuildSetting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildGuildSetting.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.joinCon != null && message.hasOwnProperty("joinCon"))
                if (!$util.isString(message.joinCon))
                    return "joinCon: string expected";
            if (message.joinLvl != null && message.hasOwnProperty("joinLvl"))
                if (!$util.isInteger(message.joinLvl))
                    return "joinLvl: integer expected";
            return null;
        };

        return GuildGuildSetting;
    })();

    msgProto.GuildExitGuild = (function() {

        /**
         * Properties of a GuildExitGuild.
         * @memberof msgProto
         * @interface IGuildExitGuild
         */

        /**
         * Constructs a new GuildExitGuild.
         * @memberof msgProto
         * @classdesc Represents a GuildExitGuild.
         * @implements IGuildExitGuild
         * @constructor
         * @param {msgProto.IGuildExitGuild=} [properties] Properties to set
         */
        function GuildExitGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildExitGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {msgProto.IGuildExitGuild=} [properties] Properties to set
         * @returns {msgProto.GuildExitGuild} GuildExitGuild instance
         */
        GuildExitGuild.create = function create(properties) {
            return new GuildExitGuild(properties);
        };

        /**
         * Encodes the specified GuildExitGuild message. Does not implicitly {@link msgProto.GuildExitGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {msgProto.IGuildExitGuild} message GuildExitGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildExitGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildExitGuild message, length delimited. Does not implicitly {@link msgProto.GuildExitGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {msgProto.IGuildExitGuild} message GuildExitGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildExitGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildExitGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildExitGuild} GuildExitGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildExitGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildExitGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildExitGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildExitGuild} GuildExitGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildExitGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildExitGuild message.
         * @function verify
         * @memberof msgProto.GuildExitGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildExitGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildExitGuild;
    })();

    msgProto.GuildSetNotice = (function() {

        /**
         * Properties of a GuildSetNotice.
         * @memberof msgProto
         * @interface IGuildSetNotice
         * @property {string|null} [notice] GuildSetNotice notice
         */

        /**
         * Constructs a new GuildSetNotice.
         * @memberof msgProto
         * @classdesc Represents a GuildSetNotice.
         * @implements IGuildSetNotice
         * @constructor
         * @param {msgProto.IGuildSetNotice=} [properties] Properties to set
         */
        function GuildSetNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSetNotice notice.
         * @member {string} notice
         * @memberof msgProto.GuildSetNotice
         * @instance
         */
        GuildSetNotice.prototype.notice = "";

        /**
         * Creates a new GuildSetNotice instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {msgProto.IGuildSetNotice=} [properties] Properties to set
         * @returns {msgProto.GuildSetNotice} GuildSetNotice instance
         */
        GuildSetNotice.create = function create(properties) {
            return new GuildSetNotice(properties);
        };

        /**
         * Encodes the specified GuildSetNotice message. Does not implicitly {@link msgProto.GuildSetNotice.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {msgProto.IGuildSetNotice} message GuildSetNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notice != null && message.hasOwnProperty("notice"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.notice);
            return writer;
        };

        /**
         * Encodes the specified GuildSetNotice message, length delimited. Does not implicitly {@link msgProto.GuildSetNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {msgProto.IGuildSetNotice} message GuildSetNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildSetNotice message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSetNotice} GuildSetNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSetNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.notice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildSetNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildSetNotice} GuildSetNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildSetNotice message.
         * @function verify
         * @memberof msgProto.GuildSetNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildSetNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.notice != null && message.hasOwnProperty("notice"))
                if (!$util.isString(message.notice))
                    return "notice: string expected";
            return null;
        };

        return GuildSetNotice;
    })();

    msgProto.GuildLottery = (function() {

        /**
         * Properties of a GuildLottery.
         * @memberof msgProto
         * @interface IGuildLottery
         * @property {number|null} [count] GuildLottery count
         */

        /**
         * Constructs a new GuildLottery.
         * @memberof msgProto
         * @classdesc Represents a GuildLottery.
         * @implements IGuildLottery
         * @constructor
         * @param {msgProto.IGuildLottery=} [properties] Properties to set
         */
        function GuildLottery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildLottery count.
         * @member {number} count
         * @memberof msgProto.GuildLottery
         * @instance
         */
        GuildLottery.prototype.count = 0;

        /**
         * Creates a new GuildLottery instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildLottery
         * @static
         * @param {msgProto.IGuildLottery=} [properties] Properties to set
         * @returns {msgProto.GuildLottery} GuildLottery instance
         */
        GuildLottery.create = function create(properties) {
            return new GuildLottery(properties);
        };

        /**
         * Encodes the specified GuildLottery message. Does not implicitly {@link msgProto.GuildLottery.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildLottery
         * @static
         * @param {msgProto.IGuildLottery} message GuildLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildLottery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified GuildLottery message, length delimited. Does not implicitly {@link msgProto.GuildLottery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildLottery
         * @static
         * @param {msgProto.IGuildLottery} message GuildLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildLottery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildLottery message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildLottery} GuildLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildLottery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildLottery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildLottery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildLottery} GuildLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildLottery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildLottery message.
         * @function verify
         * @memberof msgProto.GuildLottery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildLottery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return GuildLottery;
    })();

    msgProto.GuildSetEnnoble = (function() {

        /**
         * Properties of a GuildSetEnnoble.
         * @memberof msgProto
         * @interface IGuildSetEnnoble
         * @property {number|null} [targetUserId] GuildSetEnnoble targetUserId
         * @property {number|null} [ennobleType] GuildSetEnnoble ennobleType
         */

        /**
         * Constructs a new GuildSetEnnoble.
         * @memberof msgProto
         * @classdesc Represents a GuildSetEnnoble.
         * @implements IGuildSetEnnoble
         * @constructor
         * @param {msgProto.IGuildSetEnnoble=} [properties] Properties to set
         */
        function GuildSetEnnoble(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildSetEnnoble targetUserId.
         * @member {number} targetUserId
         * @memberof msgProto.GuildSetEnnoble
         * @instance
         */
        GuildSetEnnoble.prototype.targetUserId = 0;

        /**
         * GuildSetEnnoble ennobleType.
         * @member {number} ennobleType
         * @memberof msgProto.GuildSetEnnoble
         * @instance
         */
        GuildSetEnnoble.prototype.ennobleType = 0;

        /**
         * Creates a new GuildSetEnnoble instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {msgProto.IGuildSetEnnoble=} [properties] Properties to set
         * @returns {msgProto.GuildSetEnnoble} GuildSetEnnoble instance
         */
        GuildSetEnnoble.create = function create(properties) {
            return new GuildSetEnnoble(properties);
        };

        /**
         * Encodes the specified GuildSetEnnoble message. Does not implicitly {@link msgProto.GuildSetEnnoble.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {msgProto.IGuildSetEnnoble} message GuildSetEnnoble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetEnnoble.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.targetUserId);
            if (message.ennobleType != null && message.hasOwnProperty("ennobleType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ennobleType);
            return writer;
        };

        /**
         * Encodes the specified GuildSetEnnoble message, length delimited. Does not implicitly {@link msgProto.GuildSetEnnoble.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {msgProto.IGuildSetEnnoble} message GuildSetEnnoble message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildSetEnnoble.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildSetEnnoble message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildSetEnnoble} GuildSetEnnoble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetEnnoble.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildSetEnnoble();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetUserId = reader.uint32();
                    break;
                case 2:
                    message.ennobleType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildSetEnnoble message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildSetEnnoble} GuildSetEnnoble
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildSetEnnoble.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildSetEnnoble message.
         * @function verify
         * @memberof msgProto.GuildSetEnnoble
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildSetEnnoble.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                if (!$util.isInteger(message.targetUserId))
                    return "targetUserId: integer expected";
            if (message.ennobleType != null && message.hasOwnProperty("ennobleType"))
                if (!$util.isInteger(message.ennobleType))
                    return "ennobleType: integer expected";
            return null;
        };

        return GuildSetEnnoble;
    })();

    msgProto.GuildPersonPickAct = (function() {

        /**
         * Properties of a GuildPersonPickAct.
         * @memberof msgProto
         * @interface IGuildPersonPickAct
         * @property {number|null} [actId] GuildPersonPickAct actId
         */

        /**
         * Constructs a new GuildPersonPickAct.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonPickAct.
         * @implements IGuildPersonPickAct
         * @constructor
         * @param {msgProto.IGuildPersonPickAct=} [properties] Properties to set
         */
        function GuildPersonPickAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildPersonPickAct actId.
         * @member {number} actId
         * @memberof msgProto.GuildPersonPickAct
         * @instance
         */
        GuildPersonPickAct.prototype.actId = 0;

        /**
         * Creates a new GuildPersonPickAct instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {msgProto.IGuildPersonPickAct=} [properties] Properties to set
         * @returns {msgProto.GuildPersonPickAct} GuildPersonPickAct instance
         */
        GuildPersonPickAct.create = function create(properties) {
            return new GuildPersonPickAct(properties);
        };

        /**
         * Encodes the specified GuildPersonPickAct message. Does not implicitly {@link msgProto.GuildPersonPickAct.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {msgProto.IGuildPersonPickAct} message GuildPersonPickAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonPickAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actId != null && message.hasOwnProperty("actId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.actId);
            return writer;
        };

        /**
         * Encodes the specified GuildPersonPickAct message, length delimited. Does not implicitly {@link msgProto.GuildPersonPickAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {msgProto.IGuildPersonPickAct} message GuildPersonPickAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonPickAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildPersonPickAct message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonPickAct} GuildPersonPickAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonPickAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonPickAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildPersonPickAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildPersonPickAct} GuildPersonPickAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonPickAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildPersonPickAct message.
         * @function verify
         * @memberof msgProto.GuildPersonPickAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildPersonPickAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actId != null && message.hasOwnProperty("actId"))
                if (!$util.isInteger(message.actId))
                    return "actId: integer expected";
            return null;
        };

        return GuildPersonPickAct;
    })();

    msgProto.GuildPersonGetMemberList = (function() {

        /**
         * Properties of a GuildPersonGetMemberList.
         * @memberof msgProto
         * @interface IGuildPersonGetMemberList
         */

        /**
         * Constructs a new GuildPersonGetMemberList.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonGetMemberList.
         * @implements IGuildPersonGetMemberList
         * @constructor
         * @param {msgProto.IGuildPersonGetMemberList=} [properties] Properties to set
         */
        function GuildPersonGetMemberList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildPersonGetMemberList instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {msgProto.IGuildPersonGetMemberList=} [properties] Properties to set
         * @returns {msgProto.GuildPersonGetMemberList} GuildPersonGetMemberList instance
         */
        GuildPersonGetMemberList.create = function create(properties) {
            return new GuildPersonGetMemberList(properties);
        };

        /**
         * Encodes the specified GuildPersonGetMemberList message. Does not implicitly {@link msgProto.GuildPersonGetMemberList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {msgProto.IGuildPersonGetMemberList} message GuildPersonGetMemberList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonGetMemberList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildPersonGetMemberList message, length delimited. Does not implicitly {@link msgProto.GuildPersonGetMemberList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {msgProto.IGuildPersonGetMemberList} message GuildPersonGetMemberList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonGetMemberList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildPersonGetMemberList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonGetMemberList} GuildPersonGetMemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonGetMemberList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonGetMemberList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildPersonGetMemberList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildPersonGetMemberList} GuildPersonGetMemberList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonGetMemberList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildPersonGetMemberList message.
         * @function verify
         * @memberof msgProto.GuildPersonGetMemberList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildPersonGetMemberList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildPersonGetMemberList;
    })();

    msgProto.GuildPersonOpMember = (function() {

        /**
         * Properties of a GuildPersonOpMember.
         * @memberof msgProto
         * @interface IGuildPersonOpMember
         * @property {number|Long|null} [targetUserId] GuildPersonOpMember targetUserId
         * @property {number|null} [op] GuildPersonOpMember op
         */

        /**
         * Constructs a new GuildPersonOpMember.
         * @memberof msgProto
         * @classdesc Represents a GuildPersonOpMember.
         * @implements IGuildPersonOpMember
         * @constructor
         * @param {msgProto.IGuildPersonOpMember=} [properties] Properties to set
         */
        function GuildPersonOpMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildPersonOpMember targetUserId.
         * @member {number|Long} targetUserId
         * @memberof msgProto.GuildPersonOpMember
         * @instance
         */
        GuildPersonOpMember.prototype.targetUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GuildPersonOpMember op.
         * @member {number} op
         * @memberof msgProto.GuildPersonOpMember
         * @instance
         */
        GuildPersonOpMember.prototype.op = 0;

        /**
         * Creates a new GuildPersonOpMember instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {msgProto.IGuildPersonOpMember=} [properties] Properties to set
         * @returns {msgProto.GuildPersonOpMember} GuildPersonOpMember instance
         */
        GuildPersonOpMember.create = function create(properties) {
            return new GuildPersonOpMember(properties);
        };

        /**
         * Encodes the specified GuildPersonOpMember message. Does not implicitly {@link msgProto.GuildPersonOpMember.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {msgProto.IGuildPersonOpMember} message GuildPersonOpMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonOpMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.targetUserId);
            if (message.op != null && message.hasOwnProperty("op"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            return writer;
        };

        /**
         * Encodes the specified GuildPersonOpMember message, length delimited. Does not implicitly {@link msgProto.GuildPersonOpMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {msgProto.IGuildPersonOpMember} message GuildPersonOpMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildPersonOpMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildPersonOpMember message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildPersonOpMember} GuildPersonOpMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonOpMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildPersonOpMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetUserId = reader.uint64();
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildPersonOpMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildPersonOpMember} GuildPersonOpMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildPersonOpMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildPersonOpMember message.
         * @function verify
         * @memberof msgProto.GuildPersonOpMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildPersonOpMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetUserId != null && message.hasOwnProperty("targetUserId"))
                if (!$util.isInteger(message.targetUserId) && !(message.targetUserId && $util.isInteger(message.targetUserId.low) && $util.isInteger(message.targetUserId.high)))
                    return "targetUserId: integer|Long expected";
            if (message.op != null && message.hasOwnProperty("op"))
                if (!$util.isInteger(message.op))
                    return "op: integer expected";
            return null;
        };

        return GuildPersonOpMember;
    })();

    msgProto.GuildWarGetInfo = (function() {

        /**
         * Properties of a GuildWarGetInfo.
         * @memberof msgProto
         * @interface IGuildWarGetInfo
         */

        /**
         * Constructs a new GuildWarGetInfo.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetInfo.
         * @implements IGuildWarGetInfo
         * @constructor
         * @param {msgProto.IGuildWarGetInfo=} [properties] Properties to set
         */
        function GuildWarGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {msgProto.IGuildWarGetInfo=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetInfo} GuildWarGetInfo instance
         */
        GuildWarGetInfo.create = function create(properties) {
            return new GuildWarGetInfo(properties);
        };

        /**
         * Encodes the specified GuildWarGetInfo message. Does not implicitly {@link msgProto.GuildWarGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {msgProto.IGuildWarGetInfo} message GuildWarGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetInfo message, length delimited. Does not implicitly {@link msgProto.GuildWarGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {msgProto.IGuildWarGetInfo} message GuildWarGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetInfo} GuildWarGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetInfo} GuildWarGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetInfo message.
         * @function verify
         * @memberof msgProto.GuildWarGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarGetInfo;
    })();

    msgProto.GuildWarGetGuildList = (function() {

        /**
         * Properties of a GuildWarGetGuildList.
         * @memberof msgProto
         * @interface IGuildWarGetGuildList
         * @property {number|null} [guildId] GuildWarGetGuildList guildId
         */

        /**
         * Constructs a new GuildWarGetGuildList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetGuildList.
         * @implements IGuildWarGetGuildList
         * @constructor
         * @param {msgProto.IGuildWarGetGuildList=} [properties] Properties to set
         */
        function GuildWarGetGuildList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetGuildList guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetGuildList
         * @instance
         */
        GuildWarGetGuildList.prototype.guildId = 0;

        /**
         * Creates a new GuildWarGetGuildList instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {msgProto.IGuildWarGetGuildList=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetGuildList} GuildWarGetGuildList instance
         */
        GuildWarGetGuildList.create = function create(properties) {
            return new GuildWarGetGuildList(properties);
        };

        /**
         * Encodes the specified GuildWarGetGuildList message. Does not implicitly {@link msgProto.GuildWarGetGuildList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {msgProto.IGuildWarGetGuildList} message GuildWarGetGuildList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetGuildList message, length delimited. Does not implicitly {@link msgProto.GuildWarGetGuildList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {msgProto.IGuildWarGetGuildList} message GuildWarGetGuildList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetGuildList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetGuildList} GuildWarGetGuildList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetGuildList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetGuildList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetGuildList} GuildWarGetGuildList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetGuildList message.
         * @function verify
         * @memberof msgProto.GuildWarGetGuildList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetGuildList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildWarGetGuildList;
    })();

    msgProto.GuildWarGetWarAttackData = (function() {

        /**
         * Properties of a GuildWarGetWarAttackData.
         * @memberof msgProto
         * @interface IGuildWarGetWarAttackData
         * @property {number|null} [serverId] GuildWarGetWarAttackData serverId
         * @property {number|null} [guildId] GuildWarGetWarAttackData guildId
         */

        /**
         * Constructs a new GuildWarGetWarAttackData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetWarAttackData.
         * @implements IGuildWarGetWarAttackData
         * @constructor
         * @param {msgProto.IGuildWarGetWarAttackData=} [properties] Properties to set
         */
        function GuildWarGetWarAttackData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetWarAttackData serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarGetWarAttackData
         * @instance
         */
        GuildWarGetWarAttackData.prototype.serverId = 0;

        /**
         * GuildWarGetWarAttackData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetWarAttackData
         * @instance
         */
        GuildWarGetWarAttackData.prototype.guildId = 0;

        /**
         * Creates a new GuildWarGetWarAttackData instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {msgProto.IGuildWarGetWarAttackData=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetWarAttackData} GuildWarGetWarAttackData instance
         */
        GuildWarGetWarAttackData.create = function create(properties) {
            return new GuildWarGetWarAttackData(properties);
        };

        /**
         * Encodes the specified GuildWarGetWarAttackData message. Does not implicitly {@link msgProto.GuildWarGetWarAttackData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {msgProto.IGuildWarGetWarAttackData} message GuildWarGetWarAttackData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarAttackData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetWarAttackData message, length delimited. Does not implicitly {@link msgProto.GuildWarGetWarAttackData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {msgProto.IGuildWarGetWarAttackData} message GuildWarGetWarAttackData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarAttackData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetWarAttackData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetWarAttackData} GuildWarGetWarAttackData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarAttackData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetWarAttackData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetWarAttackData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetWarAttackData} GuildWarGetWarAttackData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarAttackData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetWarAttackData message.
         * @function verify
         * @memberof msgProto.GuildWarGetWarAttackData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetWarAttackData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildWarGetWarAttackData;
    })();

    msgProto.GuildWarGetWarDefenceData = (function() {

        /**
         * Properties of a GuildWarGetWarDefenceData.
         * @memberof msgProto
         * @interface IGuildWarGetWarDefenceData
         * @property {number|null} [guildId] GuildWarGetWarDefenceData guildId
         */

        /**
         * Constructs a new GuildWarGetWarDefenceData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetWarDefenceData.
         * @implements IGuildWarGetWarDefenceData
         * @constructor
         * @param {msgProto.IGuildWarGetWarDefenceData=} [properties] Properties to set
         */
        function GuildWarGetWarDefenceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetWarDefenceData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @instance
         */
        GuildWarGetWarDefenceData.prototype.guildId = 0;

        /**
         * Creates a new GuildWarGetWarDefenceData instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {msgProto.IGuildWarGetWarDefenceData=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetWarDefenceData} GuildWarGetWarDefenceData instance
         */
        GuildWarGetWarDefenceData.create = function create(properties) {
            return new GuildWarGetWarDefenceData(properties);
        };

        /**
         * Encodes the specified GuildWarGetWarDefenceData message. Does not implicitly {@link msgProto.GuildWarGetWarDefenceData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {msgProto.IGuildWarGetWarDefenceData} message GuildWarGetWarDefenceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarDefenceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetWarDefenceData message, length delimited. Does not implicitly {@link msgProto.GuildWarGetWarDefenceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {msgProto.IGuildWarGetWarDefenceData} message GuildWarGetWarDefenceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetWarDefenceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetWarDefenceData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetWarDefenceData} GuildWarGetWarDefenceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarDefenceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetWarDefenceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetWarDefenceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetWarDefenceData} GuildWarGetWarDefenceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetWarDefenceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetWarDefenceData message.
         * @function verify
         * @memberof msgProto.GuildWarGetWarDefenceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetWarDefenceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildWarGetWarDefenceData;
    })();

    msgProto.GuildWarGetDefenceRecordList = (function() {

        /**
         * Properties of a GuildWarGetDefenceRecordList.
         * @memberof msgProto
         * @interface IGuildWarGetDefenceRecordList
         */

        /**
         * Constructs a new GuildWarGetDefenceRecordList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetDefenceRecordList.
         * @implements IGuildWarGetDefenceRecordList
         * @constructor
         * @param {msgProto.IGuildWarGetDefenceRecordList=} [properties] Properties to set
         */
        function GuildWarGetDefenceRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarGetDefenceRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {msgProto.IGuildWarGetDefenceRecordList=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetDefenceRecordList} GuildWarGetDefenceRecordList instance
         */
        GuildWarGetDefenceRecordList.create = function create(properties) {
            return new GuildWarGetDefenceRecordList(properties);
        };

        /**
         * Encodes the specified GuildWarGetDefenceRecordList message. Does not implicitly {@link msgProto.GuildWarGetDefenceRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {msgProto.IGuildWarGetDefenceRecordList} message GuildWarGetDefenceRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetDefenceRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetDefenceRecordList message, length delimited. Does not implicitly {@link msgProto.GuildWarGetDefenceRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {msgProto.IGuildWarGetDefenceRecordList} message GuildWarGetDefenceRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetDefenceRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetDefenceRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetDefenceRecordList} GuildWarGetDefenceRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetDefenceRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetDefenceRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetDefenceRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetDefenceRecordList} GuildWarGetDefenceRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetDefenceRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetDefenceRecordList message.
         * @function verify
         * @memberof msgProto.GuildWarGetDefenceRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetDefenceRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarGetDefenceRecordList;
    })();

    msgProto.GuildWarGetAttackRecordList = (function() {

        /**
         * Properties of a GuildWarGetAttackRecordList.
         * @memberof msgProto
         * @interface IGuildWarGetAttackRecordList
         */

        /**
         * Constructs a new GuildWarGetAttackRecordList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetAttackRecordList.
         * @implements IGuildWarGetAttackRecordList
         * @constructor
         * @param {msgProto.IGuildWarGetAttackRecordList=} [properties] Properties to set
         */
        function GuildWarGetAttackRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarGetAttackRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {msgProto.IGuildWarGetAttackRecordList=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetAttackRecordList} GuildWarGetAttackRecordList instance
         */
        GuildWarGetAttackRecordList.create = function create(properties) {
            return new GuildWarGetAttackRecordList(properties);
        };

        /**
         * Encodes the specified GuildWarGetAttackRecordList message. Does not implicitly {@link msgProto.GuildWarGetAttackRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {msgProto.IGuildWarGetAttackRecordList} message GuildWarGetAttackRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetAttackRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetAttackRecordList message, length delimited. Does not implicitly {@link msgProto.GuildWarGetAttackRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {msgProto.IGuildWarGetAttackRecordList} message GuildWarGetAttackRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetAttackRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetAttackRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetAttackRecordList} GuildWarGetAttackRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetAttackRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetAttackRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetAttackRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetAttackRecordList} GuildWarGetAttackRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetAttackRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetAttackRecordList message.
         * @function verify
         * @memberof msgProto.GuildWarGetAttackRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetAttackRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarGetAttackRecordList;
    })();

    msgProto.GuildWarGetGuildWarAllRank = (function() {

        /**
         * Properties of a GuildWarGetGuildWarAllRank.
         * @memberof msgProto
         * @interface IGuildWarGetGuildWarAllRank
         */

        /**
         * Constructs a new GuildWarGetGuildWarAllRank.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetGuildWarAllRank.
         * @implements IGuildWarGetGuildWarAllRank
         * @constructor
         * @param {msgProto.IGuildWarGetGuildWarAllRank=} [properties] Properties to set
         */
        function GuildWarGetGuildWarAllRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarGetGuildWarAllRank instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {msgProto.IGuildWarGetGuildWarAllRank=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetGuildWarAllRank} GuildWarGetGuildWarAllRank instance
         */
        GuildWarGetGuildWarAllRank.create = function create(properties) {
            return new GuildWarGetGuildWarAllRank(properties);
        };

        /**
         * Encodes the specified GuildWarGetGuildWarAllRank message. Does not implicitly {@link msgProto.GuildWarGetGuildWarAllRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {msgProto.IGuildWarGetGuildWarAllRank} message GuildWarGetGuildWarAllRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildWarAllRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetGuildWarAllRank message, length delimited. Does not implicitly {@link msgProto.GuildWarGetGuildWarAllRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {msgProto.IGuildWarGetGuildWarAllRank} message GuildWarGetGuildWarAllRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetGuildWarAllRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetGuildWarAllRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetGuildWarAllRank} GuildWarGetGuildWarAllRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildWarAllRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetGuildWarAllRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetGuildWarAllRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetGuildWarAllRank} GuildWarGetGuildWarAllRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetGuildWarAllRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetGuildWarAllRank message.
         * @function verify
         * @memberof msgProto.GuildWarGetGuildWarAllRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetGuildWarAllRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarGetGuildWarAllRank;
    })();

    msgProto.GuildWarGetLastRankList = (function() {

        /**
         * Properties of a GuildWarGetLastRankList.
         * @memberof msgProto
         * @interface IGuildWarGetLastRankList
         * @property {number|null} [groupId] GuildWarGetLastRankList groupId
         */

        /**
         * Constructs a new GuildWarGetLastRankList.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetLastRankList.
         * @implements IGuildWarGetLastRankList
         * @constructor
         * @param {msgProto.IGuildWarGetLastRankList=} [properties] Properties to set
         */
        function GuildWarGetLastRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetLastRankList groupId.
         * @member {number} groupId
         * @memberof msgProto.GuildWarGetLastRankList
         * @instance
         */
        GuildWarGetLastRankList.prototype.groupId = 0;

        /**
         * Creates a new GuildWarGetLastRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {msgProto.IGuildWarGetLastRankList=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetLastRankList} GuildWarGetLastRankList instance
         */
        GuildWarGetLastRankList.create = function create(properties) {
            return new GuildWarGetLastRankList(properties);
        };

        /**
         * Encodes the specified GuildWarGetLastRankList message. Does not implicitly {@link msgProto.GuildWarGetLastRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {msgProto.IGuildWarGetLastRankList} message GuildWarGetLastRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetLastRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetLastRankList message, length delimited. Does not implicitly {@link msgProto.GuildWarGetLastRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {msgProto.IGuildWarGetLastRankList} message GuildWarGetLastRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetLastRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetLastRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetLastRankList} GuildWarGetLastRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetLastRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetLastRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetLastRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetLastRankList} GuildWarGetLastRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetLastRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetLastRankList message.
         * @function verify
         * @memberof msgProto.GuildWarGetLastRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetLastRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId))
                    return "groupId: integer expected";
            return null;
        };

        return GuildWarGetLastRankList;
    })();

    msgProto.GuildWarGetSignUpData = (function() {

        /**
         * Properties of a GuildWarGetSignUpData.
         * @memberof msgProto
         * @interface IGuildWarGetSignUpData
         * @property {number|null} [guildId] GuildWarGetSignUpData guildId
         */

        /**
         * Constructs a new GuildWarGetSignUpData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarGetSignUpData.
         * @implements IGuildWarGetSignUpData
         * @constructor
         * @param {msgProto.IGuildWarGetSignUpData=} [properties] Properties to set
         */
        function GuildWarGetSignUpData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarGetSignUpData guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarGetSignUpData
         * @instance
         */
        GuildWarGetSignUpData.prototype.guildId = 0;

        /**
         * Creates a new GuildWarGetSignUpData instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {msgProto.IGuildWarGetSignUpData=} [properties] Properties to set
         * @returns {msgProto.GuildWarGetSignUpData} GuildWarGetSignUpData instance
         */
        GuildWarGetSignUpData.create = function create(properties) {
            return new GuildWarGetSignUpData(properties);
        };

        /**
         * Encodes the specified GuildWarGetSignUpData message. Does not implicitly {@link msgProto.GuildWarGetSignUpData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {msgProto.IGuildWarGetSignUpData} message GuildWarGetSignUpData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetSignUpData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarGetSignUpData message, length delimited. Does not implicitly {@link msgProto.GuildWarGetSignUpData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {msgProto.IGuildWarGetSignUpData} message GuildWarGetSignUpData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarGetSignUpData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarGetSignUpData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarGetSignUpData} GuildWarGetSignUpData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetSignUpData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarGetSignUpData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarGetSignUpData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarGetSignUpData} GuildWarGetSignUpData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarGetSignUpData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarGetSignUpData message.
         * @function verify
         * @memberof msgProto.GuildWarGetSignUpData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarGetSignUpData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            return null;
        };

        return GuildWarGetSignUpData;
    })();

    msgProto.GuildWarSignUp = (function() {

        /**
         * Properties of a GuildWarSignUp.
         * @memberof msgProto
         * @interface IGuildWarSignUp
         * @property {number|null} [groupId] GuildWarSignUp groupId
         */

        /**
         * Constructs a new GuildWarSignUp.
         * @memberof msgProto
         * @classdesc Represents a GuildWarSignUp.
         * @implements IGuildWarSignUp
         * @constructor
         * @param {msgProto.IGuildWarSignUp=} [properties] Properties to set
         */
        function GuildWarSignUp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarSignUp groupId.
         * @member {number} groupId
         * @memberof msgProto.GuildWarSignUp
         * @instance
         */
        GuildWarSignUp.prototype.groupId = 0;

        /**
         * Creates a new GuildWarSignUp instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {msgProto.IGuildWarSignUp=} [properties] Properties to set
         * @returns {msgProto.GuildWarSignUp} GuildWarSignUp instance
         */
        GuildWarSignUp.create = function create(properties) {
            return new GuildWarSignUp(properties);
        };

        /**
         * Encodes the specified GuildWarSignUp message. Does not implicitly {@link msgProto.GuildWarSignUp.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {msgProto.IGuildWarSignUp} message GuildWarSignUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSignUp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupId);
            return writer;
        };

        /**
         * Encodes the specified GuildWarSignUp message, length delimited. Does not implicitly {@link msgProto.GuildWarSignUp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {msgProto.IGuildWarSignUp} message GuildWarSignUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSignUp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarSignUp message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarSignUp} GuildWarSignUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSignUp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarSignUp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarSignUp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarSignUp} GuildWarSignUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSignUp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarSignUp message.
         * @function verify
         * @memberof msgProto.GuildWarSignUp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarSignUp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId))
                    return "groupId: integer expected";
            return null;
        };

        return GuildWarSignUp;
    })();

    msgProto.GuildWarFightStartDoor = (function() {

        /**
         * Properties of a GuildWarFightStartDoor.
         * @memberof msgProto
         * @interface IGuildWarFightStartDoor
         * @property {number|null} [serverId] GuildWarFightStartDoor serverId
         * @property {number|null} [guildId] GuildWarFightStartDoor guildId
         * @property {number|null} [door] GuildWarFightStartDoor door
         */

        /**
         * Constructs a new GuildWarFightStartDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarFightStartDoor.
         * @implements IGuildWarFightStartDoor
         * @constructor
         * @param {msgProto.IGuildWarFightStartDoor=} [properties] Properties to set
         */
        function GuildWarFightStartDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarFightStartDoor serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.serverId = 0;

        /**
         * GuildWarFightStartDoor guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.guildId = 0;

        /**
         * GuildWarFightStartDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarFightStartDoor
         * @instance
         */
        GuildWarFightStartDoor.prototype.door = 0;

        /**
         * Creates a new GuildWarFightStartDoor instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {msgProto.IGuildWarFightStartDoor=} [properties] Properties to set
         * @returns {msgProto.GuildWarFightStartDoor} GuildWarFightStartDoor instance
         */
        GuildWarFightStartDoor.create = function create(properties) {
            return new GuildWarFightStartDoor(properties);
        };

        /**
         * Encodes the specified GuildWarFightStartDoor message. Does not implicitly {@link msgProto.GuildWarFightStartDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {msgProto.IGuildWarFightStartDoor} message GuildWarFightStartDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightStartDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.door);
            return writer;
        };

        /**
         * Encodes the specified GuildWarFightStartDoor message, length delimited. Does not implicitly {@link msgProto.GuildWarFightStartDoor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {msgProto.IGuildWarFightStartDoor} message GuildWarFightStartDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightStartDoor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarFightStartDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarFightStartDoor} GuildWarFightStartDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightStartDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarFightStartDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarFightStartDoor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarFightStartDoor} GuildWarFightStartDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightStartDoor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarFightStartDoor message.
         * @function verify
         * @memberof msgProto.GuildWarFightStartDoor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarFightStartDoor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            return null;
        };

        return GuildWarFightStartDoor;
    })();

    msgProto.GuildWarFightEndDoor = (function() {

        /**
         * Properties of a GuildWarFightEndDoor.
         * @memberof msgProto
         * @interface IGuildWarFightEndDoor
         * @property {number|null} [serverId] GuildWarFightEndDoor serverId
         * @property {number|null} [guildId] GuildWarFightEndDoor guildId
         * @property {number|null} [door] GuildWarFightEndDoor door
         * @property {boolean|null} [isWin] GuildWarFightEndDoor isWin
         */

        /**
         * Constructs a new GuildWarFightEndDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarFightEndDoor.
         * @implements IGuildWarFightEndDoor
         * @constructor
         * @param {msgProto.IGuildWarFightEndDoor=} [properties] Properties to set
         */
        function GuildWarFightEndDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarFightEndDoor serverId.
         * @member {number} serverId
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.serverId = 0;

        /**
         * GuildWarFightEndDoor guildId.
         * @member {number} guildId
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.guildId = 0;

        /**
         * GuildWarFightEndDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.door = 0;

        /**
         * GuildWarFightEndDoor isWin.
         * @member {boolean} isWin
         * @memberof msgProto.GuildWarFightEndDoor
         * @instance
         */
        GuildWarFightEndDoor.prototype.isWin = false;

        /**
         * Creates a new GuildWarFightEndDoor instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {msgProto.IGuildWarFightEndDoor=} [properties] Properties to set
         * @returns {msgProto.GuildWarFightEndDoor} GuildWarFightEndDoor instance
         */
        GuildWarFightEndDoor.create = function create(properties) {
            return new GuildWarFightEndDoor(properties);
        };

        /**
         * Encodes the specified GuildWarFightEndDoor message. Does not implicitly {@link msgProto.GuildWarFightEndDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {msgProto.IGuildWarFightEndDoor} message GuildWarFightEndDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightEndDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.door);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isWin);
            return writer;
        };

        /**
         * Encodes the specified GuildWarFightEndDoor message, length delimited. Does not implicitly {@link msgProto.GuildWarFightEndDoor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {msgProto.IGuildWarFightEndDoor} message GuildWarFightEndDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarFightEndDoor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarFightEndDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarFightEndDoor} GuildWarFightEndDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightEndDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarFightEndDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.door = reader.int32();
                    break;
                case 4:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarFightEndDoor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarFightEndDoor} GuildWarFightEndDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarFightEndDoor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarFightEndDoor message.
         * @function verify
         * @memberof msgProto.GuildWarFightEndDoor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarFightEndDoor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            return null;
        };

        return GuildWarFightEndDoor;
    })();

    msgProto.GuildWarUpDoor = (function() {

        /**
         * Properties of a GuildWarUpDoor.
         * @memberof msgProto
         * @interface IGuildWarUpDoor
         * @property {number|null} [door] GuildWarUpDoor door
         */

        /**
         * Constructs a new GuildWarUpDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarUpDoor.
         * @implements IGuildWarUpDoor
         * @constructor
         * @param {msgProto.IGuildWarUpDoor=} [properties] Properties to set
         */
        function GuildWarUpDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarUpDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarUpDoor
         * @instance
         */
        GuildWarUpDoor.prototype.door = 0;

        /**
         * Creates a new GuildWarUpDoor instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {msgProto.IGuildWarUpDoor=} [properties] Properties to set
         * @returns {msgProto.GuildWarUpDoor} GuildWarUpDoor instance
         */
        GuildWarUpDoor.create = function create(properties) {
            return new GuildWarUpDoor(properties);
        };

        /**
         * Encodes the specified GuildWarUpDoor message. Does not implicitly {@link msgProto.GuildWarUpDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {msgProto.IGuildWarUpDoor} message GuildWarUpDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarUpDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.door);
            return writer;
        };

        /**
         * Encodes the specified GuildWarUpDoor message, length delimited. Does not implicitly {@link msgProto.GuildWarUpDoor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {msgProto.IGuildWarUpDoor} message GuildWarUpDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarUpDoor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarUpDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarUpDoor} GuildWarUpDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarUpDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarUpDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarUpDoor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarUpDoor} GuildWarUpDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarUpDoor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarUpDoor message.
         * @function verify
         * @memberof msgProto.GuildWarUpDoor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarUpDoor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            return null;
        };

        return GuildWarUpDoor;
    })();

    msgProto.GuildWarDownDoor = (function() {

        /**
         * Properties of a GuildWarDownDoor.
         * @memberof msgProto
         * @interface IGuildWarDownDoor
         * @property {number|null} [door] GuildWarDownDoor door
         */

        /**
         * Constructs a new GuildWarDownDoor.
         * @memberof msgProto
         * @classdesc Represents a GuildWarDownDoor.
         * @implements IGuildWarDownDoor
         * @constructor
         * @param {msgProto.IGuildWarDownDoor=} [properties] Properties to set
         */
        function GuildWarDownDoor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarDownDoor door.
         * @member {number} door
         * @memberof msgProto.GuildWarDownDoor
         * @instance
         */
        GuildWarDownDoor.prototype.door = 0;

        /**
         * Creates a new GuildWarDownDoor instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {msgProto.IGuildWarDownDoor=} [properties] Properties to set
         * @returns {msgProto.GuildWarDownDoor} GuildWarDownDoor instance
         */
        GuildWarDownDoor.create = function create(properties) {
            return new GuildWarDownDoor(properties);
        };

        /**
         * Encodes the specified GuildWarDownDoor message. Does not implicitly {@link msgProto.GuildWarDownDoor.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {msgProto.IGuildWarDownDoor} message GuildWarDownDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarDownDoor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.door);
            return writer;
        };

        /**
         * Encodes the specified GuildWarDownDoor message, length delimited. Does not implicitly {@link msgProto.GuildWarDownDoor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {msgProto.IGuildWarDownDoor} message GuildWarDownDoor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarDownDoor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarDownDoor message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarDownDoor} GuildWarDownDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarDownDoor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarDownDoor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarDownDoor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarDownDoor} GuildWarDownDoor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarDownDoor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarDownDoor message.
         * @function verify
         * @memberof msgProto.GuildWarDownDoor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarDownDoor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            return null;
        };

        return GuildWarDownDoor;
    })();

    msgProto.GuildWarEnter = (function() {

        /**
         * Properties of a GuildWarEnter.
         * @memberof msgProto
         * @interface IGuildWarEnter
         */

        /**
         * Constructs a new GuildWarEnter.
         * @memberof msgProto
         * @classdesc Represents a GuildWarEnter.
         * @implements IGuildWarEnter
         * @constructor
         * @param {msgProto.IGuildWarEnter=} [properties] Properties to set
         */
        function GuildWarEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarEnter instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {msgProto.IGuildWarEnter=} [properties] Properties to set
         * @returns {msgProto.GuildWarEnter} GuildWarEnter instance
         */
        GuildWarEnter.create = function create(properties) {
            return new GuildWarEnter(properties);
        };

        /**
         * Encodes the specified GuildWarEnter message. Does not implicitly {@link msgProto.GuildWarEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {msgProto.IGuildWarEnter} message GuildWarEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarEnter message, length delimited. Does not implicitly {@link msgProto.GuildWarEnter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {msgProto.IGuildWarEnter} message GuildWarEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarEnter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarEnter} GuildWarEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarEnter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarEnter} GuildWarEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarEnter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarEnter message.
         * @function verify
         * @memberof msgProto.GuildWarEnter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarEnter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarEnter;
    })();

    msgProto.GuildWarClearCd = (function() {

        /**
         * Properties of a GuildWarClearCd.
         * @memberof msgProto
         * @interface IGuildWarClearCd
         */

        /**
         * Constructs a new GuildWarClearCd.
         * @memberof msgProto
         * @classdesc Represents a GuildWarClearCd.
         * @implements IGuildWarClearCd
         * @constructor
         * @param {msgProto.IGuildWarClearCd=} [properties] Properties to set
         */
        function GuildWarClearCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarClearCd instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {msgProto.IGuildWarClearCd=} [properties] Properties to set
         * @returns {msgProto.GuildWarClearCd} GuildWarClearCd instance
         */
        GuildWarClearCd.create = function create(properties) {
            return new GuildWarClearCd(properties);
        };

        /**
         * Encodes the specified GuildWarClearCd message. Does not implicitly {@link msgProto.GuildWarClearCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {msgProto.IGuildWarClearCd} message GuildWarClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarClearCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarClearCd message, length delimited. Does not implicitly {@link msgProto.GuildWarClearCd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {msgProto.IGuildWarClearCd} message GuildWarClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarClearCd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarClearCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarClearCd} GuildWarClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarClearCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarClearCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarClearCd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarClearCd} GuildWarClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarClearCd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarClearCd message.
         * @function verify
         * @memberof msgProto.GuildWarClearCd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarClearCd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarClearCd;
    })();

    msgProto.GuildWarInspire = (function() {

        /**
         * Properties of a GuildWarInspire.
         * @memberof msgProto
         * @interface IGuildWarInspire
         */

        /**
         * Constructs a new GuildWarInspire.
         * @memberof msgProto
         * @classdesc Represents a GuildWarInspire.
         * @implements IGuildWarInspire
         * @constructor
         * @param {msgProto.IGuildWarInspire=} [properties] Properties to set
         */
        function GuildWarInspire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GuildWarInspire instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {msgProto.IGuildWarInspire=} [properties] Properties to set
         * @returns {msgProto.GuildWarInspire} GuildWarInspire instance
         */
        GuildWarInspire.create = function create(properties) {
            return new GuildWarInspire(properties);
        };

        /**
         * Encodes the specified GuildWarInspire message. Does not implicitly {@link msgProto.GuildWarInspire.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {msgProto.IGuildWarInspire} message GuildWarInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarInspire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GuildWarInspire message, length delimited. Does not implicitly {@link msgProto.GuildWarInspire.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {msgProto.IGuildWarInspire} message GuildWarInspire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarInspire.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarInspire message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarInspire} GuildWarInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarInspire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarInspire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarInspire message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarInspire} GuildWarInspire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarInspire.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarInspire message.
         * @function verify
         * @memberof msgProto.GuildWarInspire
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarInspire.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GuildWarInspire;
    })();

    msgProto.GuildWarSyncData = (function() {

        /**
         * Properties of a GuildWarSyncData.
         * @memberof msgProto
         * @interface IGuildWarSyncData
         * @property {number|null} [sceneType] GuildWarSyncData sceneType
         * @property {string|null} [attackData] GuildWarSyncData attackData
         */

        /**
         * Constructs a new GuildWarSyncData.
         * @memberof msgProto
         * @classdesc Represents a GuildWarSyncData.
         * @implements IGuildWarSyncData
         * @constructor
         * @param {msgProto.IGuildWarSyncData=} [properties] Properties to set
         */
        function GuildWarSyncData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuildWarSyncData sceneType.
         * @member {number} sceneType
         * @memberof msgProto.GuildWarSyncData
         * @instance
         */
        GuildWarSyncData.prototype.sceneType = 0;

        /**
         * GuildWarSyncData attackData.
         * @member {string} attackData
         * @memberof msgProto.GuildWarSyncData
         * @instance
         */
        GuildWarSyncData.prototype.attackData = "";

        /**
         * Creates a new GuildWarSyncData instance using the specified properties.
         * @function create
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {msgProto.IGuildWarSyncData=} [properties] Properties to set
         * @returns {msgProto.GuildWarSyncData} GuildWarSyncData instance
         */
        GuildWarSyncData.create = function create(properties) {
            return new GuildWarSyncData(properties);
        };

        /**
         * Encodes the specified GuildWarSyncData message. Does not implicitly {@link msgProto.GuildWarSyncData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {msgProto.IGuildWarSyncData} message GuildWarSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSyncData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sceneType != null && message.hasOwnProperty("sceneType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sceneType);
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.attackData);
            return writer;
        };

        /**
         * Encodes the specified GuildWarSyncData message, length delimited. Does not implicitly {@link msgProto.GuildWarSyncData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {msgProto.IGuildWarSyncData} message GuildWarSyncData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuildWarSyncData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuildWarSyncData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GuildWarSyncData} GuildWarSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSyncData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GuildWarSyncData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sceneType = reader.int32();
                    break;
                case 2:
                    message.attackData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuildWarSyncData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GuildWarSyncData} GuildWarSyncData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuildWarSyncData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuildWarSyncData message.
         * @function verify
         * @memberof msgProto.GuildWarSyncData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuildWarSyncData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sceneType != null && message.hasOwnProperty("sceneType"))
                if (!$util.isInteger(message.sceneType))
                    return "sceneType: integer expected";
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                if (!$util.isString(message.attackData))
                    return "attackData: string expected";
            return null;
        };

        return GuildWarSyncData;
    })();

    msgProto.HonorGetInfo = (function() {

        /**
         * Properties of an HonorGetInfo.
         * @memberof msgProto
         * @interface IHonorGetInfo
         */

        /**
         * Constructs a new HonorGetInfo.
         * @memberof msgProto
         * @classdesc Represents an HonorGetInfo.
         * @implements IHonorGetInfo
         * @constructor
         * @param {msgProto.IHonorGetInfo=} [properties] Properties to set
         */
        function HonorGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HonorGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {msgProto.IHonorGetInfo=} [properties] Properties to set
         * @returns {msgProto.HonorGetInfo} HonorGetInfo instance
         */
        HonorGetInfo.create = function create(properties) {
            return new HonorGetInfo(properties);
        };

        /**
         * Encodes the specified HonorGetInfo message. Does not implicitly {@link msgProto.HonorGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {msgProto.IHonorGetInfo} message HonorGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HonorGetInfo message, length delimited. Does not implicitly {@link msgProto.HonorGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {msgProto.IHonorGetInfo} message HonorGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an HonorGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorGetInfo} HonorGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an HonorGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HonorGetInfo} HonorGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an HonorGetInfo message.
         * @function verify
         * @memberof msgProto.HonorGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HonorGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HonorGetInfo;
    })();

    msgProto.HonorGetAward = (function() {

        /**
         * Properties of an HonorGetAward.
         * @memberof msgProto
         * @interface IHonorGetAward
         * @property {number|null} [honorId] HonorGetAward honorId
         */

        /**
         * Constructs a new HonorGetAward.
         * @memberof msgProto
         * @classdesc Represents an HonorGetAward.
         * @implements IHonorGetAward
         * @constructor
         * @param {msgProto.IHonorGetAward=} [properties] Properties to set
         */
        function HonorGetAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HonorGetAward honorId.
         * @member {number} honorId
         * @memberof msgProto.HonorGetAward
         * @instance
         */
        HonorGetAward.prototype.honorId = 0;

        /**
         * Creates a new HonorGetAward instance using the specified properties.
         * @function create
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {msgProto.IHonorGetAward=} [properties] Properties to set
         * @returns {msgProto.HonorGetAward} HonorGetAward instance
         */
        HonorGetAward.create = function create(properties) {
            return new HonorGetAward(properties);
        };

        /**
         * Encodes the specified HonorGetAward message. Does not implicitly {@link msgProto.HonorGetAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {msgProto.IHonorGetAward} message HonorGetAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.honorId != null && message.hasOwnProperty("honorId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.honorId);
            return writer;
        };

        /**
         * Encodes the specified HonorGetAward message, length delimited. Does not implicitly {@link msgProto.HonorGetAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {msgProto.IHonorGetAward} message HonorGetAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorGetAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an HonorGetAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorGetAward} HonorGetAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorGetAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.honorId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an HonorGetAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HonorGetAward} HonorGetAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorGetAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an HonorGetAward message.
         * @function verify
         * @memberof msgProto.HonorGetAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HonorGetAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.honorId != null && message.hasOwnProperty("honorId"))
                if (!$util.isInteger(message.honorId))
                    return "honorId: integer expected";
            return null;
        };

        return HonorGetAward;
    })();

    msgProto.HonorBugAlter = (function() {

        /**
         * Properties of an HonorBugAlter.
         * @memberof msgProto
         * @interface IHonorBugAlter
         */

        /**
         * Constructs a new HonorBugAlter.
         * @memberof msgProto
         * @classdesc Represents an HonorBugAlter.
         * @implements IHonorBugAlter
         * @constructor
         * @param {msgProto.IHonorBugAlter=} [properties] Properties to set
         */
        function HonorBugAlter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HonorBugAlter instance using the specified properties.
         * @function create
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {msgProto.IHonorBugAlter=} [properties] Properties to set
         * @returns {msgProto.HonorBugAlter} HonorBugAlter instance
         */
        HonorBugAlter.create = function create(properties) {
            return new HonorBugAlter(properties);
        };

        /**
         * Encodes the specified HonorBugAlter message. Does not implicitly {@link msgProto.HonorBugAlter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {msgProto.IHonorBugAlter} message HonorBugAlter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorBugAlter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HonorBugAlter message, length delimited. Does not implicitly {@link msgProto.HonorBugAlter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {msgProto.IHonorBugAlter} message HonorBugAlter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HonorBugAlter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an HonorBugAlter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HonorBugAlter} HonorBugAlter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorBugAlter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HonorBugAlter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an HonorBugAlter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HonorBugAlter} HonorBugAlter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HonorBugAlter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an HonorBugAlter message.
         * @function verify
         * @memberof msgProto.HonorBugAlter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HonorBugAlter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HonorBugAlter;
    })();

    msgProto.HeartStuntGetInfo = (function() {

        /**
         * Properties of a HeartStuntGetInfo.
         * @memberof msgProto
         * @interface IHeartStuntGetInfo
         */

        /**
         * Constructs a new HeartStuntGetInfo.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntGetInfo.
         * @implements IHeartStuntGetInfo
         * @constructor
         * @param {msgProto.IHeartStuntGetInfo=} [properties] Properties to set
         */
        function HeartStuntGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HeartStuntGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {msgProto.IHeartStuntGetInfo=} [properties] Properties to set
         * @returns {msgProto.HeartStuntGetInfo} HeartStuntGetInfo instance
         */
        HeartStuntGetInfo.create = function create(properties) {
            return new HeartStuntGetInfo(properties);
        };

        /**
         * Encodes the specified HeartStuntGetInfo message. Does not implicitly {@link msgProto.HeartStuntGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {msgProto.IHeartStuntGetInfo} message HeartStuntGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HeartStuntGetInfo message, length delimited. Does not implicitly {@link msgProto.HeartStuntGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {msgProto.IHeartStuntGetInfo} message HeartStuntGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartStuntGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntGetInfo} HeartStuntGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartStuntGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeartStuntGetInfo} HeartStuntGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartStuntGetInfo message.
         * @function verify
         * @memberof msgProto.HeartStuntGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartStuntGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HeartStuntGetInfo;
    })();

    msgProto.HeartStuntChoMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntChoMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntChoMenCulMethods
         * @property {number|null} [index] HeartStuntChoMenCulMethods index
         * @property {number|null} [heartStuntId] HeartStuntChoMenCulMethods heartStuntId
         */

        /**
         * Constructs a new HeartStuntChoMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntChoMenCulMethods.
         * @implements IHeartStuntChoMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntChoMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntChoMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntChoMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @instance
         */
        HeartStuntChoMenCulMethods.prototype.index = 0;

        /**
         * HeartStuntChoMenCulMethods heartStuntId.
         * @member {number} heartStuntId
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @instance
         */
        HeartStuntChoMenCulMethods.prototype.heartStuntId = 0;

        /**
         * Creates a new HeartStuntChoMenCulMethods instance using the specified properties.
         * @function create
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChoMenCulMethods=} [properties] Properties to set
         * @returns {msgProto.HeartStuntChoMenCulMethods} HeartStuntChoMenCulMethods instance
         */
        HeartStuntChoMenCulMethods.create = function create(properties) {
            return new HeartStuntChoMenCulMethods(properties);
        };

        /**
         * Encodes the specified HeartStuntChoMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntChoMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChoMenCulMethods} message HeartStuntChoMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChoMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heartStuntId);
            return writer;
        };

        /**
         * Encodes the specified HeartStuntChoMenCulMethods message, length delimited. Does not implicitly {@link msgProto.HeartStuntChoMenCulMethods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChoMenCulMethods} message HeartStuntChoMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChoMenCulMethods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartStuntChoMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntChoMenCulMethods} HeartStuntChoMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChoMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntChoMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.heartStuntId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartStuntChoMenCulMethods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeartStuntChoMenCulMethods} HeartStuntChoMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChoMenCulMethods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartStuntChoMenCulMethods message.
         * @function verify
         * @memberof msgProto.HeartStuntChoMenCulMethods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartStuntChoMenCulMethods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                if (!$util.isInteger(message.heartStuntId))
                    return "heartStuntId: integer expected";
            return null;
        };

        return HeartStuntChoMenCulMethods;
    })();

    msgProto.HeartStuntStuMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntStuMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntStuMenCulMethods
         * @property {number|null} [index] HeartStuntStuMenCulMethods index
         */

        /**
         * Constructs a new HeartStuntStuMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntStuMenCulMethods.
         * @implements IHeartStuntStuMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntStuMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntStuMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntStuMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @instance
         */
        HeartStuntStuMenCulMethods.prototype.index = 0;

        /**
         * Creates a new HeartStuntStuMenCulMethods instance using the specified properties.
         * @function create
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntStuMenCulMethods=} [properties] Properties to set
         * @returns {msgProto.HeartStuntStuMenCulMethods} HeartStuntStuMenCulMethods instance
         */
        HeartStuntStuMenCulMethods.create = function create(properties) {
            return new HeartStuntStuMenCulMethods(properties);
        };

        /**
         * Encodes the specified HeartStuntStuMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntStuMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntStuMenCulMethods} message HeartStuntStuMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntStuMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeartStuntStuMenCulMethods message, length delimited. Does not implicitly {@link msgProto.HeartStuntStuMenCulMethods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntStuMenCulMethods} message HeartStuntStuMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntStuMenCulMethods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartStuntStuMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntStuMenCulMethods} HeartStuntStuMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntStuMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntStuMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartStuntStuMenCulMethods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeartStuntStuMenCulMethods} HeartStuntStuMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntStuMenCulMethods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartStuntStuMenCulMethods message.
         * @function verify
         * @memberof msgProto.HeartStuntStuMenCulMethods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartStuntStuMenCulMethods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeartStuntStuMenCulMethods;
    })();

    msgProto.HeartStuntChaMenCulMethods = (function() {

        /**
         * Properties of a HeartStuntChaMenCulMethods.
         * @memberof msgProto
         * @interface IHeartStuntChaMenCulMethods
         * @property {number|null} [index] HeartStuntChaMenCulMethods index
         * @property {number|null} [heartStuntId] HeartStuntChaMenCulMethods heartStuntId
         */

        /**
         * Constructs a new HeartStuntChaMenCulMethods.
         * @memberof msgProto
         * @classdesc Represents a HeartStuntChaMenCulMethods.
         * @implements IHeartStuntChaMenCulMethods
         * @constructor
         * @param {msgProto.IHeartStuntChaMenCulMethods=} [properties] Properties to set
         */
        function HeartStuntChaMenCulMethods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartStuntChaMenCulMethods index.
         * @member {number} index
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @instance
         */
        HeartStuntChaMenCulMethods.prototype.index = 0;

        /**
         * HeartStuntChaMenCulMethods heartStuntId.
         * @member {number} heartStuntId
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @instance
         */
        HeartStuntChaMenCulMethods.prototype.heartStuntId = 0;

        /**
         * Creates a new HeartStuntChaMenCulMethods instance using the specified properties.
         * @function create
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChaMenCulMethods=} [properties] Properties to set
         * @returns {msgProto.HeartStuntChaMenCulMethods} HeartStuntChaMenCulMethods instance
         */
        HeartStuntChaMenCulMethods.create = function create(properties) {
            return new HeartStuntChaMenCulMethods(properties);
        };

        /**
         * Encodes the specified HeartStuntChaMenCulMethods message. Does not implicitly {@link msgProto.HeartStuntChaMenCulMethods.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChaMenCulMethods} message HeartStuntChaMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChaMenCulMethods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heartStuntId);
            return writer;
        };

        /**
         * Encodes the specified HeartStuntChaMenCulMethods message, length delimited. Does not implicitly {@link msgProto.HeartStuntChaMenCulMethods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {msgProto.IHeartStuntChaMenCulMethods} message HeartStuntChaMenCulMethods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartStuntChaMenCulMethods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartStuntChaMenCulMethods message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeartStuntChaMenCulMethods} HeartStuntChaMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChaMenCulMethods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeartStuntChaMenCulMethods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.heartStuntId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartStuntChaMenCulMethods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeartStuntChaMenCulMethods} HeartStuntChaMenCulMethods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartStuntChaMenCulMethods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartStuntChaMenCulMethods message.
         * @function verify
         * @memberof msgProto.HeartStuntChaMenCulMethods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartStuntChaMenCulMethods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.heartStuntId != null && message.hasOwnProperty("heartStuntId"))
                if (!$util.isInteger(message.heartStuntId))
                    return "heartStuntId: integer expected";
            return null;
        };

        return HeartStuntChaMenCulMethods;
    })();

    msgProto.HeroCallHero = (function() {

        /**
         * Properties of a HeroCallHero.
         * @memberof msgProto
         * @interface IHeroCallHero
         * @property {number|null} [tempId] HeroCallHero tempId
         * @property {number|null} [sex] HeroCallHero sex
         */

        /**
         * Constructs a new HeroCallHero.
         * @memberof msgProto
         * @classdesc Represents a HeroCallHero.
         * @implements IHeroCallHero
         * @constructor
         * @param {msgProto.IHeroCallHero=} [properties] Properties to set
         */
        function HeroCallHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroCallHero tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroCallHero
         * @instance
         */
        HeroCallHero.prototype.tempId = 0;

        /**
         * HeroCallHero sex.
         * @member {number} sex
         * @memberof msgProto.HeroCallHero
         * @instance
         */
        HeroCallHero.prototype.sex = 0;

        /**
         * Creates a new HeroCallHero instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {msgProto.IHeroCallHero=} [properties] Properties to set
         * @returns {msgProto.HeroCallHero} HeroCallHero instance
         */
        HeroCallHero.create = function create(properties) {
            return new HeroCallHero(properties);
        };

        /**
         * Encodes the specified HeroCallHero message. Does not implicitly {@link msgProto.HeroCallHero.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {msgProto.IHeroCallHero} message HeroCallHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCallHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.sex != null && message.hasOwnProperty("sex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sex);
            return writer;
        };

        /**
         * Encodes the specified HeroCallHero message, length delimited. Does not implicitly {@link msgProto.HeroCallHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {msgProto.IHeroCallHero} message HeroCallHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCallHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroCallHero message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroCallHero} HeroCallHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCallHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroCallHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.sex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroCallHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroCallHero} HeroCallHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCallHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroCallHero message.
         * @function verify
         * @memberof msgProto.HeroCallHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroCallHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.sex != null && message.hasOwnProperty("sex"))
                if (!$util.isInteger(message.sex))
                    return "sex: integer expected";
            return null;
        };

        return HeroCallHero;
    })();

    msgProto.HeroUpSkill = (function() {

        /**
         * Properties of a HeroUpSkill.
         * @memberof msgProto
         * @interface IHeroUpSkill
         * @property {number|null} [tempId] HeroUpSkill tempId
         * @property {number|null} [index] HeroUpSkill index
         */

        /**
         * Constructs a new HeroUpSkill.
         * @memberof msgProto
         * @classdesc Represents a HeroUpSkill.
         * @implements IHeroUpSkill
         * @constructor
         * @param {msgProto.IHeroUpSkill=} [properties] Properties to set
         */
        function HeroUpSkill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpSkill tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpSkill
         * @instance
         */
        HeroUpSkill.prototype.tempId = 0;

        /**
         * HeroUpSkill index.
         * @member {number} index
         * @memberof msgProto.HeroUpSkill
         * @instance
         */
        HeroUpSkill.prototype.index = 0;

        /**
         * Creates a new HeroUpSkill instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {msgProto.IHeroUpSkill=} [properties] Properties to set
         * @returns {msgProto.HeroUpSkill} HeroUpSkill instance
         */
        HeroUpSkill.create = function create(properties) {
            return new HeroUpSkill(properties);
        };

        /**
         * Encodes the specified HeroUpSkill message. Does not implicitly {@link msgProto.HeroUpSkill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {msgProto.IHeroUpSkill} message HeroUpSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpSkill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroUpSkill message, length delimited. Does not implicitly {@link msgProto.HeroUpSkill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {msgProto.IHeroUpSkill} message HeroUpSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpSkill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroUpSkill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpSkill} HeroUpSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpSkill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpSkill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroUpSkill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroUpSkill} HeroUpSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpSkill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroUpSkill message.
         * @function verify
         * @memberof msgProto.HeroUpSkill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroUpSkill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroUpSkill;
    })();

    msgProto.HeroClearSkillCd = (function() {

        /**
         * Properties of a HeroClearSkillCd.
         * @memberof msgProto
         * @interface IHeroClearSkillCd
         */

        /**
         * Constructs a new HeroClearSkillCd.
         * @memberof msgProto
         * @classdesc Represents a HeroClearSkillCd.
         * @implements IHeroClearSkillCd
         * @constructor
         * @param {msgProto.IHeroClearSkillCd=} [properties] Properties to set
         */
        function HeroClearSkillCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HeroClearSkillCd instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {msgProto.IHeroClearSkillCd=} [properties] Properties to set
         * @returns {msgProto.HeroClearSkillCd} HeroClearSkillCd instance
         */
        HeroClearSkillCd.create = function create(properties) {
            return new HeroClearSkillCd(properties);
        };

        /**
         * Encodes the specified HeroClearSkillCd message. Does not implicitly {@link msgProto.HeroClearSkillCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {msgProto.IHeroClearSkillCd} message HeroClearSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroClearSkillCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HeroClearSkillCd message, length delimited. Does not implicitly {@link msgProto.HeroClearSkillCd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {msgProto.IHeroClearSkillCd} message HeroClearSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroClearSkillCd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroClearSkillCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroClearSkillCd} HeroClearSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroClearSkillCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroClearSkillCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroClearSkillCd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroClearSkillCd} HeroClearSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroClearSkillCd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroClearSkillCd message.
         * @function verify
         * @memberof msgProto.HeroClearSkillCd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroClearSkillCd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HeroClearSkillCd;
    })();

    msgProto.HeroWearRune = (function() {

        /**
         * Properties of a HeroWearRune.
         * @memberof msgProto
         * @interface IHeroWearRune
         * @property {number|null} [tempId] HeroWearRune tempId
         * @property {number|null} [index] HeroWearRune index
         */

        /**
         * Constructs a new HeroWearRune.
         * @memberof msgProto
         * @classdesc Represents a HeroWearRune.
         * @implements IHeroWearRune
         * @constructor
         * @param {msgProto.IHeroWearRune=} [properties] Properties to set
         */
        function HeroWearRune(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWearRune tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWearRune
         * @instance
         */
        HeroWearRune.prototype.tempId = 0;

        /**
         * HeroWearRune index.
         * @member {number} index
         * @memberof msgProto.HeroWearRune
         * @instance
         */
        HeroWearRune.prototype.index = 0;

        /**
         * Creates a new HeroWearRune instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {msgProto.IHeroWearRune=} [properties] Properties to set
         * @returns {msgProto.HeroWearRune} HeroWearRune instance
         */
        HeroWearRune.create = function create(properties) {
            return new HeroWearRune(properties);
        };

        /**
         * Encodes the specified HeroWearRune message. Does not implicitly {@link msgProto.HeroWearRune.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {msgProto.IHeroWearRune} message HeroWearRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearRune.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroWearRune message, length delimited. Does not implicitly {@link msgProto.HeroWearRune.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {msgProto.IHeroWearRune} message HeroWearRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearRune.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroWearRune message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWearRune} HeroWearRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearRune.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWearRune();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroWearRune message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroWearRune} HeroWearRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearRune.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroWearRune message.
         * @function verify
         * @memberof msgProto.HeroWearRune
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroWearRune.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroWearRune;
    })();

    msgProto.HeroUpRealm = (function() {

        /**
         * Properties of a HeroUpRealm.
         * @memberof msgProto
         * @interface IHeroUpRealm
         * @property {number|null} [tempId] HeroUpRealm tempId
         */

        /**
         * Constructs a new HeroUpRealm.
         * @memberof msgProto
         * @classdesc Represents a HeroUpRealm.
         * @implements IHeroUpRealm
         * @constructor
         * @param {msgProto.IHeroUpRealm=} [properties] Properties to set
         */
        function HeroUpRealm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpRealm tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpRealm
         * @instance
         */
        HeroUpRealm.prototype.tempId = 0;

        /**
         * Creates a new HeroUpRealm instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {msgProto.IHeroUpRealm=} [properties] Properties to set
         * @returns {msgProto.HeroUpRealm} HeroUpRealm instance
         */
        HeroUpRealm.create = function create(properties) {
            return new HeroUpRealm(properties);
        };

        /**
         * Encodes the specified HeroUpRealm message. Does not implicitly {@link msgProto.HeroUpRealm.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {msgProto.IHeroUpRealm} message HeroUpRealm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpRealm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified HeroUpRealm message, length delimited. Does not implicitly {@link msgProto.HeroUpRealm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {msgProto.IHeroUpRealm} message HeroUpRealm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpRealm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroUpRealm message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpRealm} HeroUpRealm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpRealm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpRealm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroUpRealm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroUpRealm} HeroUpRealm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpRealm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroUpRealm message.
         * @function verify
         * @memberof msgProto.HeroUpRealm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroUpRealm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return HeroUpRealm;
    })();

    msgProto.HeroStrength = (function() {

        /**
         * Properties of a HeroStrength.
         * @memberof msgProto
         * @interface IHeroStrength
         * @property {number|null} [tempId] HeroStrength tempId
         * @property {number|null} [index] HeroStrength index
         */

        /**
         * Constructs a new HeroStrength.
         * @memberof msgProto
         * @classdesc Represents a HeroStrength.
         * @implements IHeroStrength
         * @constructor
         * @param {msgProto.IHeroStrength=} [properties] Properties to set
         */
        function HeroStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroStrength tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroStrength
         * @instance
         */
        HeroStrength.prototype.tempId = 0;

        /**
         * HeroStrength index.
         * @member {number} index
         * @memberof msgProto.HeroStrength
         * @instance
         */
        HeroStrength.prototype.index = 0;

        /**
         * Creates a new HeroStrength instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroStrength
         * @static
         * @param {msgProto.IHeroStrength=} [properties] Properties to set
         * @returns {msgProto.HeroStrength} HeroStrength instance
         */
        HeroStrength.create = function create(properties) {
            return new HeroStrength(properties);
        };

        /**
         * Encodes the specified HeroStrength message. Does not implicitly {@link msgProto.HeroStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroStrength
         * @static
         * @param {msgProto.IHeroStrength} message HeroStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroStrength message, length delimited. Does not implicitly {@link msgProto.HeroStrength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroStrength
         * @static
         * @param {msgProto.IHeroStrength} message HeroStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStrength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroStrength} HeroStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroStrength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroStrength} HeroStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStrength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroStrength message.
         * @function verify
         * @memberof msgProto.HeroStrength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroStrength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroStrength;
    })();

    msgProto.HeroEquipRefine = (function() {

        /**
         * Properties of a HeroEquipRefine.
         * @memberof msgProto
         * @interface IHeroEquipRefine
         * @property {number|null} [tempId] HeroEquipRefine tempId
         * @property {number|null} [index] HeroEquipRefine index
         */

        /**
         * Constructs a new HeroEquipRefine.
         * @memberof msgProto
         * @classdesc Represents a HeroEquipRefine.
         * @implements IHeroEquipRefine
         * @constructor
         * @param {msgProto.IHeroEquipRefine=} [properties] Properties to set
         */
        function HeroEquipRefine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroEquipRefine tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroEquipRefine
         * @instance
         */
        HeroEquipRefine.prototype.tempId = 0;

        /**
         * HeroEquipRefine index.
         * @member {number} index
         * @memberof msgProto.HeroEquipRefine
         * @instance
         */
        HeroEquipRefine.prototype.index = 0;

        /**
         * Creates a new HeroEquipRefine instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {msgProto.IHeroEquipRefine=} [properties] Properties to set
         * @returns {msgProto.HeroEquipRefine} HeroEquipRefine instance
         */
        HeroEquipRefine.create = function create(properties) {
            return new HeroEquipRefine(properties);
        };

        /**
         * Encodes the specified HeroEquipRefine message. Does not implicitly {@link msgProto.HeroEquipRefine.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {msgProto.IHeroEquipRefine} message HeroEquipRefine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroEquipRefine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroEquipRefine message, length delimited. Does not implicitly {@link msgProto.HeroEquipRefine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {msgProto.IHeroEquipRefine} message HeroEquipRefine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroEquipRefine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroEquipRefine message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroEquipRefine} HeroEquipRefine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroEquipRefine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroEquipRefine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroEquipRefine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroEquipRefine} HeroEquipRefine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroEquipRefine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroEquipRefine message.
         * @function verify
         * @memberof msgProto.HeroEquipRefine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroEquipRefine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroEquipRefine;
    })();

    msgProto.HeroUpStar = (function() {

        /**
         * Properties of a HeroUpStar.
         * @memberof msgProto
         * @interface IHeroUpStar
         * @property {number|null} [tempId] HeroUpStar tempId
         * @property {number|null} [index] HeroUpStar index
         */

        /**
         * Constructs a new HeroUpStar.
         * @memberof msgProto
         * @classdesc Represents a HeroUpStar.
         * @implements IHeroUpStar
         * @constructor
         * @param {msgProto.IHeroUpStar=} [properties] Properties to set
         */
        function HeroUpStar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpStar tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpStar
         * @instance
         */
        HeroUpStar.prototype.tempId = 0;

        /**
         * HeroUpStar index.
         * @member {number} index
         * @memberof msgProto.HeroUpStar
         * @instance
         */
        HeroUpStar.prototype.index = 0;

        /**
         * Creates a new HeroUpStar instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {msgProto.IHeroUpStar=} [properties] Properties to set
         * @returns {msgProto.HeroUpStar} HeroUpStar instance
         */
        HeroUpStar.create = function create(properties) {
            return new HeroUpStar(properties);
        };

        /**
         * Encodes the specified HeroUpStar message. Does not implicitly {@link msgProto.HeroUpStar.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {msgProto.IHeroUpStar} message HeroUpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpStar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroUpStar message, length delimited. Does not implicitly {@link msgProto.HeroUpStar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {msgProto.IHeroUpStar} message HeroUpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpStar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroUpStar message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpStar} HeroUpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpStar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpStar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroUpStar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroUpStar} HeroUpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpStar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroUpStar message.
         * @function verify
         * @memberof msgProto.HeroUpStar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroUpStar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroUpStar;
    })();

    msgProto.HeroStarTop = (function() {

        /**
         * Properties of a HeroStarTop.
         * @memberof msgProto
         * @interface IHeroStarTop
         * @property {number|null} [tempId] HeroStarTop tempId
         * @property {number|null} [index] HeroStarTop index
         */

        /**
         * Constructs a new HeroStarTop.
         * @memberof msgProto
         * @classdesc Represents a HeroStarTop.
         * @implements IHeroStarTop
         * @constructor
         * @param {msgProto.IHeroStarTop=} [properties] Properties to set
         */
        function HeroStarTop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroStarTop tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroStarTop
         * @instance
         */
        HeroStarTop.prototype.tempId = 0;

        /**
         * HeroStarTop index.
         * @member {number} index
         * @memberof msgProto.HeroStarTop
         * @instance
         */
        HeroStarTop.prototype.index = 0;

        /**
         * Creates a new HeroStarTop instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {msgProto.IHeroStarTop=} [properties] Properties to set
         * @returns {msgProto.HeroStarTop} HeroStarTop instance
         */
        HeroStarTop.create = function create(properties) {
            return new HeroStarTop(properties);
        };

        /**
         * Encodes the specified HeroStarTop message. Does not implicitly {@link msgProto.HeroStarTop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {msgProto.IHeroStarTop} message HeroStarTop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStarTop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroStarTop message, length delimited. Does not implicitly {@link msgProto.HeroStarTop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {msgProto.IHeroStarTop} message HeroStarTop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroStarTop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroStarTop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroStarTop} HeroStarTop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStarTop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroStarTop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroStarTop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroStarTop} HeroStarTop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroStarTop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroStarTop message.
         * @function verify
         * @memberof msgProto.HeroStarTop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroStarTop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroStarTop;
    })();

    msgProto.heroUpGem = (function() {

        /**
         * Properties of a heroUpGem.
         * @memberof msgProto
         * @interface IheroUpGem
         * @property {number|null} [tempId] heroUpGem tempId
         * @property {number|null} [index] heroUpGem index
         */

        /**
         * Constructs a new heroUpGem.
         * @memberof msgProto
         * @classdesc Represents a heroUpGem.
         * @implements IheroUpGem
         * @constructor
         * @param {msgProto.IheroUpGem=} [properties] Properties to set
         */
        function heroUpGem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * heroUpGem tempId.
         * @member {number} tempId
         * @memberof msgProto.heroUpGem
         * @instance
         */
        heroUpGem.prototype.tempId = 0;

        /**
         * heroUpGem index.
         * @member {number} index
         * @memberof msgProto.heroUpGem
         * @instance
         */
        heroUpGem.prototype.index = 0;

        /**
         * Creates a new heroUpGem instance using the specified properties.
         * @function create
         * @memberof msgProto.heroUpGem
         * @static
         * @param {msgProto.IheroUpGem=} [properties] Properties to set
         * @returns {msgProto.heroUpGem} heroUpGem instance
         */
        heroUpGem.create = function create(properties) {
            return new heroUpGem(properties);
        };

        /**
         * Encodes the specified heroUpGem message. Does not implicitly {@link msgProto.heroUpGem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.heroUpGem
         * @static
         * @param {msgProto.IheroUpGem} message heroUpGem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroUpGem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified heroUpGem message, length delimited. Does not implicitly {@link msgProto.heroUpGem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.heroUpGem
         * @static
         * @param {msgProto.IheroUpGem} message heroUpGem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroUpGem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a heroUpGem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.heroUpGem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.heroUpGem} heroUpGem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroUpGem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.heroUpGem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a heroUpGem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.heroUpGem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.heroUpGem} heroUpGem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroUpGem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a heroUpGem message.
         * @function verify
         * @memberof msgProto.heroUpGem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        heroUpGem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return heroUpGem;
    })();

    msgProto.heroWingFos = (function() {

        /**
         * Properties of a heroWingFos.
         * @memberof msgProto
         * @interface IheroWingFos
         * @property {number|null} [tempId] heroWingFos tempId
         * @property {number|null} [fosType] heroWingFos fosType
         */

        /**
         * Constructs a new heroWingFos.
         * @memberof msgProto
         * @classdesc Represents a heroWingFos.
         * @implements IheroWingFos
         * @constructor
         * @param {msgProto.IheroWingFos=} [properties] Properties to set
         */
        function heroWingFos(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * heroWingFos tempId.
         * @member {number} tempId
         * @memberof msgProto.heroWingFos
         * @instance
         */
        heroWingFos.prototype.tempId = 0;

        /**
         * heroWingFos fosType.
         * @member {number} fosType
         * @memberof msgProto.heroWingFos
         * @instance
         */
        heroWingFos.prototype.fosType = 0;

        /**
         * Creates a new heroWingFos instance using the specified properties.
         * @function create
         * @memberof msgProto.heroWingFos
         * @static
         * @param {msgProto.IheroWingFos=} [properties] Properties to set
         * @returns {msgProto.heroWingFos} heroWingFos instance
         */
        heroWingFos.create = function create(properties) {
            return new heroWingFos(properties);
        };

        /**
         * Encodes the specified heroWingFos message. Does not implicitly {@link msgProto.heroWingFos.verify|verify} messages.
         * @function encode
         * @memberof msgProto.heroWingFos
         * @static
         * @param {msgProto.IheroWingFos} message heroWingFos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroWingFos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fosType);
            return writer;
        };

        /**
         * Encodes the specified heroWingFos message, length delimited. Does not implicitly {@link msgProto.heroWingFos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.heroWingFos
         * @static
         * @param {msgProto.IheroWingFos} message heroWingFos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        heroWingFos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a heroWingFos message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.heroWingFos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.heroWingFos} heroWingFos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroWingFos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.heroWingFos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.fosType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a heroWingFos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.heroWingFos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.heroWingFos} heroWingFos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        heroWingFos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a heroWingFos message.
         * @function verify
         * @memberof msgProto.heroWingFos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        heroWingFos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                if (!$util.isInteger(message.fosType))
                    return "fosType: integer expected";
            return null;
        };

        return heroWingFos;
    })();

    msgProto.Hero_wingStrength = (function() {

        /**
         * Properties of a Hero_wingStrength.
         * @memberof msgProto
         * @interface IHero_wingStrength
         * @property {number|null} [tempId] Hero_wingStrength tempId
         * @property {number|null} [part] Hero_wingStrength part
         * @property {boolean|null} [isReplace] Hero_wingStrength isReplace
         */

        /**
         * Constructs a new Hero_wingStrength.
         * @memberof msgProto
         * @classdesc Represents a Hero_wingStrength.
         * @implements IHero_wingStrength
         * @constructor
         * @param {msgProto.IHero_wingStrength=} [properties] Properties to set
         */
        function Hero_wingStrength(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hero_wingStrength tempId.
         * @member {number} tempId
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.tempId = 0;

        /**
         * Hero_wingStrength part.
         * @member {number} part
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.part = 0;

        /**
         * Hero_wingStrength isReplace.
         * @member {boolean} isReplace
         * @memberof msgProto.Hero_wingStrength
         * @instance
         */
        Hero_wingStrength.prototype.isReplace = false;

        /**
         * Creates a new Hero_wingStrength instance using the specified properties.
         * @function create
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {msgProto.IHero_wingStrength=} [properties] Properties to set
         * @returns {msgProto.Hero_wingStrength} Hero_wingStrength instance
         */
        Hero_wingStrength.create = function create(properties) {
            return new Hero_wingStrength(properties);
        };

        /**
         * Encodes the specified Hero_wingStrength message. Does not implicitly {@link msgProto.Hero_wingStrength.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {msgProto.IHero_wingStrength} message Hero_wingStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero_wingStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.part != null && message.hasOwnProperty("part"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.part);
            if (message.isReplace != null && message.hasOwnProperty("isReplace"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isReplace);
            return writer;
        };

        /**
         * Encodes the specified Hero_wingStrength message, length delimited. Does not implicitly {@link msgProto.Hero_wingStrength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {msgProto.IHero_wingStrength} message Hero_wingStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero_wingStrength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hero_wingStrength message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Hero_wingStrength} Hero_wingStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero_wingStrength.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Hero_wingStrength();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.part = reader.int32();
                    break;
                case 3:
                    message.isReplace = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hero_wingStrength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.Hero_wingStrength} Hero_wingStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero_wingStrength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hero_wingStrength message.
         * @function verify
         * @memberof msgProto.Hero_wingStrength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hero_wingStrength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.part != null && message.hasOwnProperty("part"))
                if (!$util.isInteger(message.part))
                    return "part: integer expected";
            if (message.isReplace != null && message.hasOwnProperty("isReplace"))
                if (typeof message.isReplace !== "boolean")
                    return "isReplace: boolean expected";
            return null;
        };

        return Hero_wingStrength;
    })();

    msgProto.HeroWingFos2Top = (function() {

        /**
         * Properties of a HeroWingFos2Top.
         * @memberof msgProto
         * @interface IHeroWingFos2Top
         * @property {number|null} [tempId] HeroWingFos2Top tempId
         * @property {number|null} [fosType] HeroWingFos2Top fosType
         * @property {boolean|null} [isUseDiamond] HeroWingFos2Top isUseDiamond
         */

        /**
         * Constructs a new HeroWingFos2Top.
         * @memberof msgProto
         * @classdesc Represents a HeroWingFos2Top.
         * @implements IHeroWingFos2Top
         * @constructor
         * @param {msgProto.IHeroWingFos2Top=} [properties] Properties to set
         */
        function HeroWingFos2Top(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWingFos2Top tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.tempId = 0;

        /**
         * HeroWingFos2Top fosType.
         * @member {number} fosType
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.fosType = 0;

        /**
         * HeroWingFos2Top isUseDiamond.
         * @member {boolean} isUseDiamond
         * @memberof msgProto.HeroWingFos2Top
         * @instance
         */
        HeroWingFos2Top.prototype.isUseDiamond = false;

        /**
         * Creates a new HeroWingFos2Top instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {msgProto.IHeroWingFos2Top=} [properties] Properties to set
         * @returns {msgProto.HeroWingFos2Top} HeroWingFos2Top instance
         */
        HeroWingFos2Top.create = function create(properties) {
            return new HeroWingFos2Top(properties);
        };

        /**
         * Encodes the specified HeroWingFos2Top message. Does not implicitly {@link msgProto.HeroWingFos2Top.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {msgProto.IHeroWingFos2Top} message HeroWingFos2Top message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingFos2Top.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fosType);
            if (message.isUseDiamond != null && message.hasOwnProperty("isUseDiamond"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isUseDiamond);
            return writer;
        };

        /**
         * Encodes the specified HeroWingFos2Top message, length delimited. Does not implicitly {@link msgProto.HeroWingFos2Top.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {msgProto.IHeroWingFos2Top} message HeroWingFos2Top message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingFos2Top.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroWingFos2Top message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWingFos2Top} HeroWingFos2Top
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingFos2Top.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWingFos2Top();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.fosType = reader.int32();
                    break;
                case 3:
                    message.isUseDiamond = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroWingFos2Top message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroWingFos2Top} HeroWingFos2Top
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingFos2Top.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroWingFos2Top message.
         * @function verify
         * @memberof msgProto.HeroWingFos2Top
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroWingFos2Top.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.fosType != null && message.hasOwnProperty("fosType"))
                if (!$util.isInteger(message.fosType))
                    return "fosType: integer expected";
            if (message.isUseDiamond != null && message.hasOwnProperty("isUseDiamond"))
                if (typeof message.isUseDiamond !== "boolean")
                    return "isUseDiamond: boolean expected";
            return null;
        };

        return HeroWingFos2Top;
    })();

    msgProto.HeroUpWing = (function() {

        /**
         * Properties of a HeroUpWing.
         * @memberof msgProto
         * @interface IHeroUpWing
         * @property {number|null} [tempId] HeroUpWing tempId
         */

        /**
         * Constructs a new HeroUpWing.
         * @memberof msgProto
         * @classdesc Represents a HeroUpWing.
         * @implements IHeroUpWing
         * @constructor
         * @param {msgProto.IHeroUpWing=} [properties] Properties to set
         */
        function HeroUpWing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroUpWing tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroUpWing
         * @instance
         */
        HeroUpWing.prototype.tempId = 0;

        /**
         * Creates a new HeroUpWing instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {msgProto.IHeroUpWing=} [properties] Properties to set
         * @returns {msgProto.HeroUpWing} HeroUpWing instance
         */
        HeroUpWing.create = function create(properties) {
            return new HeroUpWing(properties);
        };

        /**
         * Encodes the specified HeroUpWing message. Does not implicitly {@link msgProto.HeroUpWing.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {msgProto.IHeroUpWing} message HeroUpWing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpWing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified HeroUpWing message, length delimited. Does not implicitly {@link msgProto.HeroUpWing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {msgProto.IHeroUpWing} message HeroUpWing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroUpWing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroUpWing message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroUpWing} HeroUpWing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpWing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroUpWing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroUpWing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroUpWing} HeroUpWing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroUpWing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroUpWing message.
         * @function verify
         * @memberof msgProto.HeroUpWing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroUpWing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return HeroUpWing;
    })();

    msgProto.HeroWingActivate = (function() {

        /**
         * Properties of a HeroWingActivate.
         * @memberof msgProto
         * @interface IHeroWingActivate
         * @property {number|null} [tempId] HeroWingActivate tempId
         */

        /**
         * Constructs a new HeroWingActivate.
         * @memberof msgProto
         * @classdesc Represents a HeroWingActivate.
         * @implements IHeroWingActivate
         * @constructor
         * @param {msgProto.IHeroWingActivate=} [properties] Properties to set
         */
        function HeroWingActivate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWingActivate tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWingActivate
         * @instance
         */
        HeroWingActivate.prototype.tempId = 0;

        /**
         * Creates a new HeroWingActivate instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {msgProto.IHeroWingActivate=} [properties] Properties to set
         * @returns {msgProto.HeroWingActivate} HeroWingActivate instance
         */
        HeroWingActivate.create = function create(properties) {
            return new HeroWingActivate(properties);
        };

        /**
         * Encodes the specified HeroWingActivate message. Does not implicitly {@link msgProto.HeroWingActivate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {msgProto.IHeroWingActivate} message HeroWingActivate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingActivate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified HeroWingActivate message, length delimited. Does not implicitly {@link msgProto.HeroWingActivate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {msgProto.IHeroWingActivate} message HeroWingActivate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWingActivate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroWingActivate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWingActivate} HeroWingActivate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingActivate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWingActivate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroWingActivate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroWingActivate} HeroWingActivate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWingActivate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroWingActivate message.
         * @function verify
         * @memberof msgProto.HeroWingActivate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroWingActivate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return HeroWingActivate;
    })();

    msgProto.HeroCalPropAndCombat = (function() {

        /**
         * Properties of a HeroCalPropAndCombat.
         * @memberof msgProto
         * @interface IHeroCalPropAndCombat
         */

        /**
         * Constructs a new HeroCalPropAndCombat.
         * @memberof msgProto
         * @classdesc Represents a HeroCalPropAndCombat.
         * @implements IHeroCalPropAndCombat
         * @constructor
         * @param {msgProto.IHeroCalPropAndCombat=} [properties] Properties to set
         */
        function HeroCalPropAndCombat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HeroCalPropAndCombat instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {msgProto.IHeroCalPropAndCombat=} [properties] Properties to set
         * @returns {msgProto.HeroCalPropAndCombat} HeroCalPropAndCombat instance
         */
        HeroCalPropAndCombat.create = function create(properties) {
            return new HeroCalPropAndCombat(properties);
        };

        /**
         * Encodes the specified HeroCalPropAndCombat message. Does not implicitly {@link msgProto.HeroCalPropAndCombat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {msgProto.IHeroCalPropAndCombat} message HeroCalPropAndCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCalPropAndCombat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HeroCalPropAndCombat message, length delimited. Does not implicitly {@link msgProto.HeroCalPropAndCombat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {msgProto.IHeroCalPropAndCombat} message HeroCalPropAndCombat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroCalPropAndCombat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroCalPropAndCombat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroCalPropAndCombat} HeroCalPropAndCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCalPropAndCombat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroCalPropAndCombat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroCalPropAndCombat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroCalPropAndCombat} HeroCalPropAndCombat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroCalPropAndCombat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroCalPropAndCombat message.
         * @function verify
         * @memberof msgProto.HeroCalPropAndCombat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroCalPropAndCombat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HeroCalPropAndCombat;
    })();

    msgProto.HeroGetMainHeroDisplay = (function() {

        /**
         * Properties of a HeroGetMainHeroDisplay.
         * @memberof msgProto
         * @interface IHeroGetMainHeroDisplay
         * @property {number|Long|null} [userId] HeroGetMainHeroDisplay userId
         */

        /**
         * Constructs a new HeroGetMainHeroDisplay.
         * @memberof msgProto
         * @classdesc Represents a HeroGetMainHeroDisplay.
         * @implements IHeroGetMainHeroDisplay
         * @constructor
         * @param {msgProto.IHeroGetMainHeroDisplay=} [properties] Properties to set
         */
        function HeroGetMainHeroDisplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetMainHeroDisplay userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @instance
         */
        HeroGetMainHeroDisplay.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HeroGetMainHeroDisplay instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {msgProto.IHeroGetMainHeroDisplay=} [properties] Properties to set
         * @returns {msgProto.HeroGetMainHeroDisplay} HeroGetMainHeroDisplay instance
         */
        HeroGetMainHeroDisplay.create = function create(properties) {
            return new HeroGetMainHeroDisplay(properties);
        };

        /**
         * Encodes the specified HeroGetMainHeroDisplay message. Does not implicitly {@link msgProto.HeroGetMainHeroDisplay.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {msgProto.IHeroGetMainHeroDisplay} message HeroGetMainHeroDisplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetMainHeroDisplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Encodes the specified HeroGetMainHeroDisplay message, length delimited. Does not implicitly {@link msgProto.HeroGetMainHeroDisplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {msgProto.IHeroGetMainHeroDisplay} message HeroGetMainHeroDisplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetMainHeroDisplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroGetMainHeroDisplay message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetMainHeroDisplay} HeroGetMainHeroDisplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetMainHeroDisplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetMainHeroDisplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroGetMainHeroDisplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroGetMainHeroDisplay} HeroGetMainHeroDisplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetMainHeroDisplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroGetMainHeroDisplay message.
         * @function verify
         * @memberof msgProto.HeroGetMainHeroDisplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroGetMainHeroDisplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            return null;
        };

        return HeroGetMainHeroDisplay;
    })();

    msgProto.HeroGetHeroDisplayByTempId = (function() {

        /**
         * Properties of a HeroGetHeroDisplayByTempId.
         * @memberof msgProto
         * @interface IHeroGetHeroDisplayByTempId
         * @property {number|Long|null} [userId] HeroGetHeroDisplayByTempId userId
         * @property {number|null} [tempId] HeroGetHeroDisplayByTempId tempId
         */

        /**
         * Constructs a new HeroGetHeroDisplayByTempId.
         * @memberof msgProto
         * @classdesc Represents a HeroGetHeroDisplayByTempId.
         * @implements IHeroGetHeroDisplayByTempId
         * @constructor
         * @param {msgProto.IHeroGetHeroDisplayByTempId=} [properties] Properties to set
         */
        function HeroGetHeroDisplayByTempId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetHeroDisplayByTempId userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @instance
         */
        HeroGetHeroDisplayByTempId.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HeroGetHeroDisplayByTempId tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @instance
         */
        HeroGetHeroDisplayByTempId.prototype.tempId = 0;

        /**
         * Creates a new HeroGetHeroDisplayByTempId instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {msgProto.IHeroGetHeroDisplayByTempId=} [properties] Properties to set
         * @returns {msgProto.HeroGetHeroDisplayByTempId} HeroGetHeroDisplayByTempId instance
         */
        HeroGetHeroDisplayByTempId.create = function create(properties) {
            return new HeroGetHeroDisplayByTempId(properties);
        };

        /**
         * Encodes the specified HeroGetHeroDisplayByTempId message. Does not implicitly {@link msgProto.HeroGetHeroDisplayByTempId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {msgProto.IHeroGetHeroDisplayByTempId} message HeroGetHeroDisplayByTempId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetHeroDisplayByTempId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified HeroGetHeroDisplayByTempId message, length delimited. Does not implicitly {@link msgProto.HeroGetHeroDisplayByTempId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {msgProto.IHeroGetHeroDisplayByTempId} message HeroGetHeroDisplayByTempId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetHeroDisplayByTempId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroGetHeroDisplayByTempId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetHeroDisplayByTempId} HeroGetHeroDisplayByTempId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetHeroDisplayByTempId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetHeroDisplayByTempId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                case 2:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroGetHeroDisplayByTempId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroGetHeroDisplayByTempId} HeroGetHeroDisplayByTempId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetHeroDisplayByTempId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroGetHeroDisplayByTempId message.
         * @function verify
         * @memberof msgProto.HeroGetHeroDisplayByTempId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroGetHeroDisplayByTempId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return HeroGetHeroDisplayByTempId;
    })();

    msgProto.HeroGetShowHeroData = (function() {

        /**
         * Properties of a HeroGetShowHeroData.
         * @memberof msgProto
         * @interface IHeroGetShowHeroData
         * @property {number|Long|null} [userId] HeroGetShowHeroData userId
         */

        /**
         * Constructs a new HeroGetShowHeroData.
         * @memberof msgProto
         * @classdesc Represents a HeroGetShowHeroData.
         * @implements IHeroGetShowHeroData
         * @constructor
         * @param {msgProto.IHeroGetShowHeroData=} [properties] Properties to set
         */
        function HeroGetShowHeroData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroGetShowHeroData userId.
         * @member {number|Long} userId
         * @memberof msgProto.HeroGetShowHeroData
         * @instance
         */
        HeroGetShowHeroData.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HeroGetShowHeroData instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {msgProto.IHeroGetShowHeroData=} [properties] Properties to set
         * @returns {msgProto.HeroGetShowHeroData} HeroGetShowHeroData instance
         */
        HeroGetShowHeroData.create = function create(properties) {
            return new HeroGetShowHeroData(properties);
        };

        /**
         * Encodes the specified HeroGetShowHeroData message. Does not implicitly {@link msgProto.HeroGetShowHeroData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {msgProto.IHeroGetShowHeroData} message HeroGetShowHeroData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetShowHeroData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Encodes the specified HeroGetShowHeroData message, length delimited. Does not implicitly {@link msgProto.HeroGetShowHeroData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {msgProto.IHeroGetShowHeroData} message HeroGetShowHeroData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroGetShowHeroData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroGetShowHeroData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroGetShowHeroData} HeroGetShowHeroData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetShowHeroData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroGetShowHeroData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroGetShowHeroData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroGetShowHeroData} HeroGetShowHeroData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroGetShowHeroData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroGetShowHeroData message.
         * @function verify
         * @memberof msgProto.HeroGetShowHeroData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroGetShowHeroData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            return null;
        };

        return HeroGetShowHeroData;
    })();

    msgProto.HeroWearAllRune = (function() {

        /**
         * Properties of a HeroWearAllRune.
         * @memberof msgProto
         * @interface IHeroWearAllRune
         * @property {number|null} [tempId] HeroWearAllRune tempId
         */

        /**
         * Constructs a new HeroWearAllRune.
         * @memberof msgProto
         * @classdesc Represents a HeroWearAllRune.
         * @implements IHeroWearAllRune
         * @constructor
         * @param {msgProto.IHeroWearAllRune=} [properties] Properties to set
         */
        function HeroWearAllRune(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroWearAllRune tempId.
         * @member {number} tempId
         * @memberof msgProto.HeroWearAllRune
         * @instance
         */
        HeroWearAllRune.prototype.tempId = 0;

        /**
         * Creates a new HeroWearAllRune instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {msgProto.IHeroWearAllRune=} [properties] Properties to set
         * @returns {msgProto.HeroWearAllRune} HeroWearAllRune instance
         */
        HeroWearAllRune.create = function create(properties) {
            return new HeroWearAllRune(properties);
        };

        /**
         * Encodes the specified HeroWearAllRune message. Does not implicitly {@link msgProto.HeroWearAllRune.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {msgProto.IHeroWearAllRune} message HeroWearAllRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearAllRune.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            return writer;
        };

        /**
         * Encodes the specified HeroWearAllRune message, length delimited. Does not implicitly {@link msgProto.HeroWearAllRune.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {msgProto.IHeroWearAllRune} message HeroWearAllRune message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroWearAllRune.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroWearAllRune message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroWearAllRune} HeroWearAllRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearAllRune.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroWearAllRune();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroWearAllRune message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroWearAllRune} HeroWearAllRune
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroWearAllRune.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroWearAllRune message.
         * @function verify
         * @memberof msgProto.HeroWearAllRune
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroWearAllRune.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            return null;
        };

        return HeroWearAllRune;
    })();

    msgProto.HeroAutoInfuseSwitch = (function() {

        /**
         * Properties of a HeroAutoInfuseSwitch.
         * @memberof msgProto
         * @interface IHeroAutoInfuseSwitch
         * @property {boolean|null} [isOpenIn] HeroAutoInfuseSwitch isOpenIn
         */

        /**
         * Constructs a new HeroAutoInfuseSwitch.
         * @memberof msgProto
         * @classdesc Represents a HeroAutoInfuseSwitch.
         * @implements IHeroAutoInfuseSwitch
         * @constructor
         * @param {msgProto.IHeroAutoInfuseSwitch=} [properties] Properties to set
         */
        function HeroAutoInfuseSwitch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroAutoInfuseSwitch isOpenIn.
         * @member {boolean} isOpenIn
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @instance
         */
        HeroAutoInfuseSwitch.prototype.isOpenIn = false;

        /**
         * Creates a new HeroAutoInfuseSwitch instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {msgProto.IHeroAutoInfuseSwitch=} [properties] Properties to set
         * @returns {msgProto.HeroAutoInfuseSwitch} HeroAutoInfuseSwitch instance
         */
        HeroAutoInfuseSwitch.create = function create(properties) {
            return new HeroAutoInfuseSwitch(properties);
        };

        /**
         * Encodes the specified HeroAutoInfuseSwitch message. Does not implicitly {@link msgProto.HeroAutoInfuseSwitch.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {msgProto.IHeroAutoInfuseSwitch} message HeroAutoInfuseSwitch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroAutoInfuseSwitch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isOpenIn != null && message.hasOwnProperty("isOpenIn"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isOpenIn);
            return writer;
        };

        /**
         * Encodes the specified HeroAutoInfuseSwitch message, length delimited. Does not implicitly {@link msgProto.HeroAutoInfuseSwitch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {msgProto.IHeroAutoInfuseSwitch} message HeroAutoInfuseSwitch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroAutoInfuseSwitch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroAutoInfuseSwitch message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroAutoInfuseSwitch} HeroAutoInfuseSwitch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroAutoInfuseSwitch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroAutoInfuseSwitch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isOpenIn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroAutoInfuseSwitch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroAutoInfuseSwitch} HeroAutoInfuseSwitch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroAutoInfuseSwitch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroAutoInfuseSwitch message.
         * @function verify
         * @memberof msgProto.HeroAutoInfuseSwitch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroAutoInfuseSwitch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isOpenIn != null && message.hasOwnProperty("isOpenIn"))
                if (typeof message.isOpenIn !== "boolean")
                    return "isOpenIn: boolean expected";
            return null;
        };

        return HeroAutoInfuseSwitch;
    })();

    msgProto.HeroExtraInfuse = (function() {

        /**
         * Properties of a HeroExtraInfuse.
         * @memberof msgProto
         * @interface IHeroExtraInfuse
         * @property {number|null} [type] HeroExtraInfuse type
         */

        /**
         * Constructs a new HeroExtraInfuse.
         * @memberof msgProto
         * @classdesc Represents a HeroExtraInfuse.
         * @implements IHeroExtraInfuse
         * @constructor
         * @param {msgProto.IHeroExtraInfuse=} [properties] Properties to set
         */
        function HeroExtraInfuse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroExtraInfuse type.
         * @member {number} type
         * @memberof msgProto.HeroExtraInfuse
         * @instance
         */
        HeroExtraInfuse.prototype.type = 0;

        /**
         * Creates a new HeroExtraInfuse instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {msgProto.IHeroExtraInfuse=} [properties] Properties to set
         * @returns {msgProto.HeroExtraInfuse} HeroExtraInfuse instance
         */
        HeroExtraInfuse.create = function create(properties) {
            return new HeroExtraInfuse(properties);
        };

        /**
         * Encodes the specified HeroExtraInfuse message. Does not implicitly {@link msgProto.HeroExtraInfuse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {msgProto.IHeroExtraInfuse} message HeroExtraInfuse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroExtraInfuse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified HeroExtraInfuse message, length delimited. Does not implicitly {@link msgProto.HeroExtraInfuse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {msgProto.IHeroExtraInfuse} message HeroExtraInfuse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroExtraInfuse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroExtraInfuse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroExtraInfuse} HeroExtraInfuse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroExtraInfuse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroExtraInfuse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroExtraInfuse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroExtraInfuse} HeroExtraInfuse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroExtraInfuse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroExtraInfuse message.
         * @function verify
         * @memberof msgProto.HeroExtraInfuse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroExtraInfuse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return HeroExtraInfuse;
    })();

    msgProto.HeroSaveFightList = (function() {

        /**
         * Properties of a HeroSaveFightList.
         * @memberof msgProto
         * @interface IHeroSaveFightList
         * @property {string|null} [fightArr] HeroSaveFightList fightArr
         */

        /**
         * Constructs a new HeroSaveFightList.
         * @memberof msgProto
         * @classdesc Represents a HeroSaveFightList.
         * @implements IHeroSaveFightList
         * @constructor
         * @param {msgProto.IHeroSaveFightList=} [properties] Properties to set
         */
        function HeroSaveFightList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroSaveFightList fightArr.
         * @member {string} fightArr
         * @memberof msgProto.HeroSaveFightList
         * @instance
         */
        HeroSaveFightList.prototype.fightArr = "";

        /**
         * Creates a new HeroSaveFightList instance using the specified properties.
         * @function create
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {msgProto.IHeroSaveFightList=} [properties] Properties to set
         * @returns {msgProto.HeroSaveFightList} HeroSaveFightList instance
         */
        HeroSaveFightList.create = function create(properties) {
            return new HeroSaveFightList(properties);
        };

        /**
         * Encodes the specified HeroSaveFightList message. Does not implicitly {@link msgProto.HeroSaveFightList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {msgProto.IHeroSaveFightList} message HeroSaveFightList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroSaveFightList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightArr != null && message.hasOwnProperty("fightArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fightArr);
            return writer;
        };

        /**
         * Encodes the specified HeroSaveFightList message, length delimited. Does not implicitly {@link msgProto.HeroSaveFightList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {msgProto.IHeroSaveFightList} message HeroSaveFightList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroSaveFightList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroSaveFightList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.HeroSaveFightList} HeroSaveFightList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroSaveFightList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.HeroSaveFightList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fightArr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroSaveFightList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.HeroSaveFightList} HeroSaveFightList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroSaveFightList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroSaveFightList message.
         * @function verify
         * @memberof msgProto.HeroSaveFightList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroSaveFightList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fightArr != null && message.hasOwnProperty("fightArr"))
                if (!$util.isString(message.fightArr))
                    return "fightArr: string expected";
            return null;
        };

        return HeroSaveFightList;
    })();

    msgProto.LotteryLottery = (function() {

        /**
         * Properties of a LotteryLottery.
         * @memberof msgProto
         * @interface ILotteryLottery
         * @property {number|null} [type] LotteryLottery type
         * @property {number|null} [count] LotteryLottery count
         */

        /**
         * Constructs a new LotteryLottery.
         * @memberof msgProto
         * @classdesc Represents a LotteryLottery.
         * @implements ILotteryLottery
         * @constructor
         * @param {msgProto.ILotteryLottery=} [properties] Properties to set
         */
        function LotteryLottery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LotteryLottery type.
         * @member {number} type
         * @memberof msgProto.LotteryLottery
         * @instance
         */
        LotteryLottery.prototype.type = 0;

        /**
         * LotteryLottery count.
         * @member {number} count
         * @memberof msgProto.LotteryLottery
         * @instance
         */
        LotteryLottery.prototype.count = 0;

        /**
         * Creates a new LotteryLottery instance using the specified properties.
         * @function create
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {msgProto.ILotteryLottery=} [properties] Properties to set
         * @returns {msgProto.LotteryLottery} LotteryLottery instance
         */
        LotteryLottery.create = function create(properties) {
            return new LotteryLottery(properties);
        };

        /**
         * Encodes the specified LotteryLottery message. Does not implicitly {@link msgProto.LotteryLottery.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {msgProto.ILotteryLottery} message LotteryLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryLottery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified LotteryLottery message, length delimited. Does not implicitly {@link msgProto.LotteryLottery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {msgProto.ILotteryLottery} message LotteryLottery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryLottery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LotteryLottery message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryLottery} LotteryLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryLottery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryLottery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LotteryLottery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LotteryLottery} LotteryLottery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryLottery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LotteryLottery message.
         * @function verify
         * @memberof msgProto.LotteryLottery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LotteryLottery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return LotteryLottery;
    })();

    msgProto.LotteryGetTreasureChest = (function() {

        /**
         * Properties of a LotteryGetTreasureChest.
         * @memberof msgProto
         * @interface ILotteryGetTreasureChest
         */

        /**
         * Constructs a new LotteryGetTreasureChest.
         * @memberof msgProto
         * @classdesc Represents a LotteryGetTreasureChest.
         * @implements ILotteryGetTreasureChest
         * @constructor
         * @param {msgProto.ILotteryGetTreasureChest=} [properties] Properties to set
         */
        function LotteryGetTreasureChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LotteryGetTreasureChest instance using the specified properties.
         * @function create
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {msgProto.ILotteryGetTreasureChest=} [properties] Properties to set
         * @returns {msgProto.LotteryGetTreasureChest} LotteryGetTreasureChest instance
         */
        LotteryGetTreasureChest.create = function create(properties) {
            return new LotteryGetTreasureChest(properties);
        };

        /**
         * Encodes the specified LotteryGetTreasureChest message. Does not implicitly {@link msgProto.LotteryGetTreasureChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {msgProto.ILotteryGetTreasureChest} message LotteryGetTreasureChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetTreasureChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LotteryGetTreasureChest message, length delimited. Does not implicitly {@link msgProto.LotteryGetTreasureChest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {msgProto.ILotteryGetTreasureChest} message LotteryGetTreasureChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetTreasureChest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LotteryGetTreasureChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryGetTreasureChest} LotteryGetTreasureChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetTreasureChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryGetTreasureChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LotteryGetTreasureChest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LotteryGetTreasureChest} LotteryGetTreasureChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetTreasureChest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LotteryGetTreasureChest message.
         * @function verify
         * @memberof msgProto.LotteryGetTreasureChest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LotteryGetTreasureChest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return LotteryGetTreasureChest;
    })();

    msgProto.LotteryGetInfo = (function() {

        /**
         * Properties of a LotteryGetInfo.
         * @memberof msgProto
         * @interface ILotteryGetInfo
         */

        /**
         * Constructs a new LotteryGetInfo.
         * @memberof msgProto
         * @classdesc Represents a LotteryGetInfo.
         * @implements ILotteryGetInfo
         * @constructor
         * @param {msgProto.ILotteryGetInfo=} [properties] Properties to set
         */
        function LotteryGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LotteryGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {msgProto.ILotteryGetInfo=} [properties] Properties to set
         * @returns {msgProto.LotteryGetInfo} LotteryGetInfo instance
         */
        LotteryGetInfo.create = function create(properties) {
            return new LotteryGetInfo(properties);
        };

        /**
         * Encodes the specified LotteryGetInfo message. Does not implicitly {@link msgProto.LotteryGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {msgProto.ILotteryGetInfo} message LotteryGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LotteryGetInfo message, length delimited. Does not implicitly {@link msgProto.LotteryGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {msgProto.ILotteryGetInfo} message LotteryGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LotteryGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LotteryGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LotteryGetInfo} LotteryGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LotteryGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LotteryGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LotteryGetInfo} LotteryGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LotteryGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LotteryGetInfo message.
         * @function verify
         * @memberof msgProto.LotteryGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LotteryGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return LotteryGetInfo;
    })();

    msgProto.TaskGetInfo = (function() {

        /**
         * Properties of a TaskGetInfo.
         * @memberof msgProto
         * @interface ITaskGetInfo
         */

        /**
         * Constructs a new TaskGetInfo.
         * @memberof msgProto
         * @classdesc Represents a TaskGetInfo.
         * @implements ITaskGetInfo
         * @constructor
         * @param {msgProto.ITaskGetInfo=} [properties] Properties to set
         */
        function TaskGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TaskGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {msgProto.ITaskGetInfo=} [properties] Properties to set
         * @returns {msgProto.TaskGetInfo} TaskGetInfo instance
         */
        TaskGetInfo.create = function create(properties) {
            return new TaskGetInfo(properties);
        };

        /**
         * Encodes the specified TaskGetInfo message. Does not implicitly {@link msgProto.TaskGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {msgProto.ITaskGetInfo} message TaskGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TaskGetInfo message, length delimited. Does not implicitly {@link msgProto.TaskGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {msgProto.ITaskGetInfo} message TaskGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskGetInfo} TaskGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TaskGetInfo} TaskGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskGetInfo message.
         * @function verify
         * @memberof msgProto.TaskGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TaskGetInfo;
    })();

    msgProto.TaskTaskAward = (function() {

        /**
         * Properties of a TaskTaskAward.
         * @memberof msgProto
         * @interface ITaskTaskAward
         * @property {number|null} [taskId] TaskTaskAward taskId
         */

        /**
         * Constructs a new TaskTaskAward.
         * @memberof msgProto
         * @classdesc Represents a TaskTaskAward.
         * @implements ITaskTaskAward
         * @constructor
         * @param {msgProto.ITaskTaskAward=} [properties] Properties to set
         */
        function TaskTaskAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskTaskAward taskId.
         * @member {number} taskId
         * @memberof msgProto.TaskTaskAward
         * @instance
         */
        TaskTaskAward.prototype.taskId = 0;

        /**
         * Creates a new TaskTaskAward instance using the specified properties.
         * @function create
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {msgProto.ITaskTaskAward=} [properties] Properties to set
         * @returns {msgProto.TaskTaskAward} TaskTaskAward instance
         */
        TaskTaskAward.create = function create(properties) {
            return new TaskTaskAward(properties);
        };

        /**
         * Encodes the specified TaskTaskAward message. Does not implicitly {@link msgProto.TaskTaskAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {msgProto.ITaskTaskAward} message TaskTaskAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskTaskAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            return writer;
        };

        /**
         * Encodes the specified TaskTaskAward message, length delimited. Does not implicitly {@link msgProto.TaskTaskAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {msgProto.ITaskTaskAward} message TaskTaskAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskTaskAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskTaskAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskTaskAward} TaskTaskAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskTaskAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskTaskAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskTaskAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TaskTaskAward} TaskTaskAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskTaskAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskTaskAward message.
         * @function verify
         * @memberof msgProto.TaskTaskAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskTaskAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
            return null;
        };

        return TaskTaskAward;
    })();

    msgProto.TaskGetVitalityChest = (function() {

        /**
         * Properties of a TaskGetVitalityChest.
         * @memberof msgProto
         * @interface ITaskGetVitalityChest
         * @property {number|null} [index] TaskGetVitalityChest index
         */

        /**
         * Constructs a new TaskGetVitalityChest.
         * @memberof msgProto
         * @classdesc Represents a TaskGetVitalityChest.
         * @implements ITaskGetVitalityChest
         * @constructor
         * @param {msgProto.ITaskGetVitalityChest=} [properties] Properties to set
         */
        function TaskGetVitalityChest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskGetVitalityChest index.
         * @member {number} index
         * @memberof msgProto.TaskGetVitalityChest
         * @instance
         */
        TaskGetVitalityChest.prototype.index = 0;

        /**
         * Creates a new TaskGetVitalityChest instance using the specified properties.
         * @function create
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {msgProto.ITaskGetVitalityChest=} [properties] Properties to set
         * @returns {msgProto.TaskGetVitalityChest} TaskGetVitalityChest instance
         */
        TaskGetVitalityChest.create = function create(properties) {
            return new TaskGetVitalityChest(properties);
        };

        /**
         * Encodes the specified TaskGetVitalityChest message. Does not implicitly {@link msgProto.TaskGetVitalityChest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {msgProto.ITaskGetVitalityChest} message TaskGetVitalityChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetVitalityChest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified TaskGetVitalityChest message, length delimited. Does not implicitly {@link msgProto.TaskGetVitalityChest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {msgProto.ITaskGetVitalityChest} message TaskGetVitalityChest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGetVitalityChest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskGetVitalityChest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TaskGetVitalityChest} TaskGetVitalityChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetVitalityChest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TaskGetVitalityChest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskGetVitalityChest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TaskGetVitalityChest} TaskGetVitalityChest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGetVitalityChest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskGetVitalityChest message.
         * @function verify
         * @memberof msgProto.TaskGetVitalityChest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskGetVitalityChest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return TaskGetVitalityChest;
    })();

    msgProto.PkBuyPKNum = (function() {

        /**
         * Properties of a PkBuyPKNum.
         * @memberof msgProto
         * @interface IPkBuyPKNum
         */

        /**
         * Constructs a new PkBuyPKNum.
         * @memberof msgProto
         * @classdesc Represents a PkBuyPKNum.
         * @implements IPkBuyPKNum
         * @constructor
         * @param {msgProto.IPkBuyPKNum=} [properties] Properties to set
         */
        function PkBuyPKNum(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkBuyPKNum instance using the specified properties.
         * @function create
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {msgProto.IPkBuyPKNum=} [properties] Properties to set
         * @returns {msgProto.PkBuyPKNum} PkBuyPKNum instance
         */
        PkBuyPKNum.create = function create(properties) {
            return new PkBuyPKNum(properties);
        };

        /**
         * Encodes the specified PkBuyPKNum message. Does not implicitly {@link msgProto.PkBuyPKNum.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {msgProto.IPkBuyPKNum} message PkBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkBuyPKNum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkBuyPKNum message, length delimited. Does not implicitly {@link msgProto.PkBuyPKNum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {msgProto.IPkBuyPKNum} message PkBuyPKNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkBuyPKNum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkBuyPKNum message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkBuyPKNum} PkBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkBuyPKNum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkBuyPKNum();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkBuyPKNum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkBuyPKNum} PkBuyPKNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkBuyPKNum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkBuyPKNum message.
         * @function verify
         * @memberof msgProto.PkBuyPKNum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkBuyPKNum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkBuyPKNum;
    })();

    msgProto.PkGetPKUserList = (function() {

        /**
         * Properties of a PkGetPKUserList.
         * @memberof msgProto
         * @interface IPkGetPKUserList
         */

        /**
         * Constructs a new PkGetPKUserList.
         * @memberof msgProto
         * @classdesc Represents a PkGetPKUserList.
         * @implements IPkGetPKUserList
         * @constructor
         * @param {msgProto.IPkGetPKUserList=} [properties] Properties to set
         */
        function PkGetPKUserList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkGetPKUserList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {msgProto.IPkGetPKUserList=} [properties] Properties to set
         * @returns {msgProto.PkGetPKUserList} PkGetPKUserList instance
         */
        PkGetPKUserList.create = function create(properties) {
            return new PkGetPKUserList(properties);
        };

        /**
         * Encodes the specified PkGetPKUserList message. Does not implicitly {@link msgProto.PkGetPKUserList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {msgProto.IPkGetPKUserList} message PkGetPKUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkGetPKUserList message, length delimited. Does not implicitly {@link msgProto.PkGetPKUserList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {msgProto.IPkGetPKUserList} message PkGetPKUserList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetPKUserList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetPKUserList} PkGetPKUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetPKUserList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetPKUserList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetPKUserList} PkGetPKUserList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetPKUserList message.
         * @function verify
         * @memberof msgProto.PkGetPKUserList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetPKUserList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkGetPKUserList;
    })();

    msgProto.PkGetPKUserData = (function() {

        /**
         * Properties of a PkGetPKUserData.
         * @memberof msgProto
         * @interface IPkGetPKUserData
         * @property {number|Long|null} [userId] PkGetPKUserData userId
         */

        /**
         * Constructs a new PkGetPKUserData.
         * @memberof msgProto
         * @classdesc Represents a PkGetPKUserData.
         * @implements IPkGetPKUserData
         * @constructor
         * @param {msgProto.IPkGetPKUserData=} [properties] Properties to set
         */
        function PkGetPKUserData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkGetPKUserData userId.
         * @member {number|Long} userId
         * @memberof msgProto.PkGetPKUserData
         * @instance
         */
        PkGetPKUserData.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PkGetPKUserData instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {msgProto.IPkGetPKUserData=} [properties] Properties to set
         * @returns {msgProto.PkGetPKUserData} PkGetPKUserData instance
         */
        PkGetPKUserData.create = function create(properties) {
            return new PkGetPKUserData(properties);
        };

        /**
         * Encodes the specified PkGetPKUserData message. Does not implicitly {@link msgProto.PkGetPKUserData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {msgProto.IPkGetPKUserData} message PkGetPKUserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Encodes the specified PkGetPKUserData message, length delimited. Does not implicitly {@link msgProto.PkGetPKUserData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {msgProto.IPkGetPKUserData} message PkGetPKUserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetPKUserData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetPKUserData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetPKUserData} PkGetPKUserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetPKUserData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetPKUserData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetPKUserData} PkGetPKUserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetPKUserData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetPKUserData message.
         * @function verify
         * @memberof msgProto.PkGetPKUserData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetPKUserData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            return null;
        };

        return PkGetPKUserData;
    })();

    msgProto.PkFight = (function() {

        /**
         * Properties of a PkFight.
         * @memberof msgProto
         * @interface IPkFight
         * @property {number|Long|null} [enemyId] PkFight enemyId
         * @property {boolean|null} [isNPC] PkFight isNPC
         * @property {number|null} [fightType] PkFight fightType
         */

        /**
         * Constructs a new PkFight.
         * @memberof msgProto
         * @classdesc Represents a PkFight.
         * @implements IPkFight
         * @constructor
         * @param {msgProto.IPkFight=} [properties] Properties to set
         */
        function PkFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkFight enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkFight isNPC.
         * @member {boolean} isNPC
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.isNPC = false;

        /**
         * PkFight fightType.
         * @member {number} fightType
         * @memberof msgProto.PkFight
         * @instance
         */
        PkFight.prototype.fightType = 0;

        /**
         * Creates a new PkFight instance using the specified properties.
         * @function create
         * @memberof msgProto.PkFight
         * @static
         * @param {msgProto.IPkFight=} [properties] Properties to set
         * @returns {msgProto.PkFight} PkFight instance
         */
        PkFight.create = function create(properties) {
            return new PkFight(properties);
        };

        /**
         * Encodes the specified PkFight message. Does not implicitly {@link msgProto.PkFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkFight
         * @static
         * @param {msgProto.IPkFight} message PkFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            if (message.isNPC != null && message.hasOwnProperty("isNPC"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isNPC);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fightType);
            return writer;
        };

        /**
         * Encodes the specified PkFight message, length delimited. Does not implicitly {@link msgProto.PkFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkFight
         * @static
         * @param {msgProto.IPkFight} message PkFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkFight} PkFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                case 2:
                    message.isNPC = reader.bool();
                    break;
                case 3:
                    message.fightType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkFight} PkFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkFight message.
         * @function verify
         * @memberof msgProto.PkFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (!$util.isInteger(message.enemyId) && !(message.enemyId && $util.isInteger(message.enemyId.low) && $util.isInteger(message.enemyId.high)))
                    return "enemyId: integer|Long expected";
            if (message.isNPC != null && message.hasOwnProperty("isNPC"))
                if (typeof message.isNPC !== "boolean")
                    return "isNPC: boolean expected";
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                if (!$util.isInteger(message.fightType))
                    return "fightType: integer expected";
            return null;
        };

        return PkFight;
    })();

    msgProto.PkGetEnemyList = (function() {

        /**
         * Properties of a PkGetEnemyList.
         * @memberof msgProto
         * @interface IPkGetEnemyList
         */

        /**
         * Constructs a new PkGetEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkGetEnemyList.
         * @implements IPkGetEnemyList
         * @constructor
         * @param {msgProto.IPkGetEnemyList=} [properties] Properties to set
         */
        function PkGetEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkGetEnemyList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {msgProto.IPkGetEnemyList=} [properties] Properties to set
         * @returns {msgProto.PkGetEnemyList} PkGetEnemyList instance
         */
        PkGetEnemyList.create = function create(properties) {
            return new PkGetEnemyList(properties);
        };

        /**
         * Encodes the specified PkGetEnemyList message. Does not implicitly {@link msgProto.PkGetEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {msgProto.IPkGetEnemyList} message PkGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkGetEnemyList message, length delimited. Does not implicitly {@link msgProto.PkGetEnemyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {msgProto.IPkGetEnemyList} message PkGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetEnemyList} PkGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetEnemyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetEnemyList} PkGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetEnemyList message.
         * @function verify
         * @memberof msgProto.PkGetEnemyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetEnemyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkGetEnemyList;
    })();

    msgProto.PkGetUserRanks = (function() {

        /**
         * Properties of a PkGetUserRanks.
         * @memberof msgProto
         * @interface IPkGetUserRanks
         */

        /**
         * Constructs a new PkGetUserRanks.
         * @memberof msgProto
         * @classdesc Represents a PkGetUserRanks.
         * @implements IPkGetUserRanks
         * @constructor
         * @param {msgProto.IPkGetUserRanks=} [properties] Properties to set
         */
        function PkGetUserRanks(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkGetUserRanks instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {msgProto.IPkGetUserRanks=} [properties] Properties to set
         * @returns {msgProto.PkGetUserRanks} PkGetUserRanks instance
         */
        PkGetUserRanks.create = function create(properties) {
            return new PkGetUserRanks(properties);
        };

        /**
         * Encodes the specified PkGetUserRanks message. Does not implicitly {@link msgProto.PkGetUserRanks.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {msgProto.IPkGetUserRanks} message PkGetUserRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetUserRanks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkGetUserRanks message, length delimited. Does not implicitly {@link msgProto.PkGetUserRanks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {msgProto.IPkGetUserRanks} message PkGetUserRanks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetUserRanks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetUserRanks message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetUserRanks} PkGetUserRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetUserRanks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetUserRanks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetUserRanks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetUserRanks} PkGetUserRanks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetUserRanks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetUserRanks message.
         * @function verify
         * @memberof msgProto.PkGetUserRanks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetUserRanks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkGetUserRanks;
    })();

    msgProto.PkGetRank = (function() {

        /**
         * Properties of a PkGetRank.
         * @memberof msgProto
         * @interface IPkGetRank
         */

        /**
         * Constructs a new PkGetRank.
         * @memberof msgProto
         * @classdesc Represents a PkGetRank.
         * @implements IPkGetRank
         * @constructor
         * @param {msgProto.IPkGetRank=} [properties] Properties to set
         */
        function PkGetRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkGetRank instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetRank
         * @static
         * @param {msgProto.IPkGetRank=} [properties] Properties to set
         * @returns {msgProto.PkGetRank} PkGetRank instance
         */
        PkGetRank.create = function create(properties) {
            return new PkGetRank(properties);
        };

        /**
         * Encodes the specified PkGetRank message. Does not implicitly {@link msgProto.PkGetRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetRank
         * @static
         * @param {msgProto.IPkGetRank} message PkGetRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkGetRank message, length delimited. Does not implicitly {@link msgProto.PkGetRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetRank
         * @static
         * @param {msgProto.IPkGetRank} message PkGetRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetRank} PkGetRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetRank} PkGetRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetRank message.
         * @function verify
         * @memberof msgProto.PkGetRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkGetRank;
    })();

    msgProto.PkChangeSign = (function() {

        /**
         * Properties of a PkChangeSign.
         * @memberof msgProto
         * @interface IPkChangeSign
         * @property {string|null} [sign] PkChangeSign sign
         */

        /**
         * Constructs a new PkChangeSign.
         * @memberof msgProto
         * @classdesc Represents a PkChangeSign.
         * @implements IPkChangeSign
         * @constructor
         * @param {msgProto.IPkChangeSign=} [properties] Properties to set
         */
        function PkChangeSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkChangeSign sign.
         * @member {string} sign
         * @memberof msgProto.PkChangeSign
         * @instance
         */
        PkChangeSign.prototype.sign = "";

        /**
         * Creates a new PkChangeSign instance using the specified properties.
         * @function create
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {msgProto.IPkChangeSign=} [properties] Properties to set
         * @returns {msgProto.PkChangeSign} PkChangeSign instance
         */
        PkChangeSign.create = function create(properties) {
            return new PkChangeSign(properties);
        };

        /**
         * Encodes the specified PkChangeSign message. Does not implicitly {@link msgProto.PkChangeSign.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {msgProto.IPkChangeSign} message PkChangeSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkChangeSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sign != null && message.hasOwnProperty("sign"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sign);
            return writer;
        };

        /**
         * Encodes the specified PkChangeSign message, length delimited. Does not implicitly {@link msgProto.PkChangeSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {msgProto.IPkChangeSign} message PkChangeSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkChangeSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkChangeSign message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkChangeSign} PkChangeSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkChangeSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkChangeSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sign = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkChangeSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkChangeSign} PkChangeSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkChangeSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkChangeSign message.
         * @function verify
         * @memberof msgProto.PkChangeSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkChangeSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sign != null && message.hasOwnProperty("sign"))
                if (!$util.isString(message.sign))
                    return "sign: string expected";
            return null;
        };

        return PkChangeSign;
    })();

    msgProto.PkSetRead = (function() {

        /**
         * Properties of a PkSetRead.
         * @memberof msgProto
         * @interface IPkSetRead
         */

        /**
         * Constructs a new PkSetRead.
         * @memberof msgProto
         * @classdesc Represents a PkSetRead.
         * @implements IPkSetRead
         * @constructor
         * @param {msgProto.IPkSetRead=} [properties] Properties to set
         */
        function PkSetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkSetRead instance using the specified properties.
         * @function create
         * @memberof msgProto.PkSetRead
         * @static
         * @param {msgProto.IPkSetRead=} [properties] Properties to set
         * @returns {msgProto.PkSetRead} PkSetRead instance
         */
        PkSetRead.create = function create(properties) {
            return new PkSetRead(properties);
        };

        /**
         * Encodes the specified PkSetRead message. Does not implicitly {@link msgProto.PkSetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkSetRead
         * @static
         * @param {msgProto.IPkSetRead} message PkSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkSetRead message, length delimited. Does not implicitly {@link msgProto.PkSetRead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkSetRead
         * @static
         * @param {msgProto.IPkSetRead} message PkSetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSetRead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkSetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkSetRead} PkSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkSetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkSetRead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkSetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkSetRead} PkSetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSetRead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkSetRead message.
         * @function verify
         * @memberof msgProto.PkSetRead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkSetRead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkSetRead;
    })();

    msgProto.PkSkip = (function() {

        /**
         * Properties of a PkSkip.
         * @memberof msgProto
         * @interface IPkSkip
         */

        /**
         * Constructs a new PkSkip.
         * @memberof msgProto
         * @classdesc Represents a PkSkip.
         * @implements IPkSkip
         * @constructor
         * @param {msgProto.IPkSkip=} [properties] Properties to set
         */
        function PkSkip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkSkip instance using the specified properties.
         * @function create
         * @memberof msgProto.PkSkip
         * @static
         * @param {msgProto.IPkSkip=} [properties] Properties to set
         * @returns {msgProto.PkSkip} PkSkip instance
         */
        PkSkip.create = function create(properties) {
            return new PkSkip(properties);
        };

        /**
         * Encodes the specified PkSkip message. Does not implicitly {@link msgProto.PkSkip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkSkip
         * @static
         * @param {msgProto.IPkSkip} message PkSkip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSkip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkSkip message, length delimited. Does not implicitly {@link msgProto.PkSkip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkSkip
         * @static
         * @param {msgProto.IPkSkip} message PkSkip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkSkip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkSkip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkSkip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkSkip} PkSkip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSkip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkSkip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkSkip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkSkip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkSkip} PkSkip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkSkip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkSkip message.
         * @function verify
         * @memberof msgProto.PkSkip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkSkip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkSkip;
    })();

    msgProto.PkPickRankAward = (function() {

        /**
         * Properties of a PkPickRankAward.
         * @memberof msgProto
         * @interface IPkPickRankAward
         */

        /**
         * Constructs a new PkPickRankAward.
         * @memberof msgProto
         * @classdesc Represents a PkPickRankAward.
         * @implements IPkPickRankAward
         * @constructor
         * @param {msgProto.IPkPickRankAward=} [properties] Properties to set
         */
        function PkPickRankAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkPickRankAward instance using the specified properties.
         * @function create
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {msgProto.IPkPickRankAward=} [properties] Properties to set
         * @returns {msgProto.PkPickRankAward} PkPickRankAward instance
         */
        PkPickRankAward.create = function create(properties) {
            return new PkPickRankAward(properties);
        };

        /**
         * Encodes the specified PkPickRankAward message. Does not implicitly {@link msgProto.PkPickRankAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {msgProto.IPkPickRankAward} message PkPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkPickRankAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkPickRankAward message, length delimited. Does not implicitly {@link msgProto.PkPickRankAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {msgProto.IPkPickRankAward} message PkPickRankAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkPickRankAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkPickRankAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkPickRankAward} PkPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkPickRankAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkPickRankAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkPickRankAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkPickRankAward} PkPickRankAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkPickRankAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkPickRankAward message.
         * @function verify
         * @memberof msgProto.PkPickRankAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkPickRankAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkPickRankAward;
    })();

    msgProto.PkGetEnemyRecord = (function() {

        /**
         * Properties of a PkGetEnemyRecord.
         * @memberof msgProto
         * @interface IPkGetEnemyRecord
         * @property {number|Long|null} [enemyId] PkGetEnemyRecord enemyId
         */

        /**
         * Constructs a new PkGetEnemyRecord.
         * @memberof msgProto
         * @classdesc Represents a PkGetEnemyRecord.
         * @implements IPkGetEnemyRecord
         * @constructor
         * @param {msgProto.IPkGetEnemyRecord=} [properties] Properties to set
         */
        function PkGetEnemyRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkGetEnemyRecord enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkGetEnemyRecord
         * @instance
         */
        PkGetEnemyRecord.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PkGetEnemyRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {msgProto.IPkGetEnemyRecord=} [properties] Properties to set
         * @returns {msgProto.PkGetEnemyRecord} PkGetEnemyRecord instance
         */
        PkGetEnemyRecord.create = function create(properties) {
            return new PkGetEnemyRecord(properties);
        };

        /**
         * Encodes the specified PkGetEnemyRecord message. Does not implicitly {@link msgProto.PkGetEnemyRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {msgProto.IPkGetEnemyRecord} message PkGetEnemyRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            return writer;
        };

        /**
         * Encodes the specified PkGetEnemyRecord message, length delimited. Does not implicitly {@link msgProto.PkGetEnemyRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {msgProto.IPkGetEnemyRecord} message PkGetEnemyRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetEnemyRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetEnemyRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetEnemyRecord} PkGetEnemyRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetEnemyRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetEnemyRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetEnemyRecord} PkGetEnemyRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetEnemyRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetEnemyRecord message.
         * @function verify
         * @memberof msgProto.PkGetEnemyRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetEnemyRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (!$util.isInteger(message.enemyId) && !(message.enemyId && $util.isInteger(message.enemyId.low) && $util.isInteger(message.enemyId.high)))
                    return "enemyId: integer|Long expected";
            return null;
        };

        return PkGetEnemyRecord;
    })();

    msgProto.PkGetList = (function() {

        /**
         * Properties of a PkGetList.
         * @memberof msgProto
         * @interface IPkGetList
         */

        /**
         * Constructs a new PkGetList.
         * @memberof msgProto
         * @classdesc Represents a PkGetList.
         * @implements IPkGetList
         * @constructor
         * @param {msgProto.IPkGetList=} [properties] Properties to set
         */
        function PkGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkGetList
         * @static
         * @param {msgProto.IPkGetList=} [properties] Properties to set
         * @returns {msgProto.PkGetList} PkGetList instance
         */
        PkGetList.create = function create(properties) {
            return new PkGetList(properties);
        };

        /**
         * Encodes the specified PkGetList message. Does not implicitly {@link msgProto.PkGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkGetList
         * @static
         * @param {msgProto.IPkGetList} message PkGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkGetList message, length delimited. Does not implicitly {@link msgProto.PkGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkGetList
         * @static
         * @param {msgProto.IPkGetList} message PkGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkGetList} PkGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkGetList} PkGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkGetList message.
         * @function verify
         * @memberof msgProto.PkGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkGetList;
    })();

    msgProto.PkOutOpen = (function() {

        /**
         * Properties of a PkOutOpen.
         * @memberof msgProto
         * @interface IPkOutOpen
         */

        /**
         * Constructs a new PkOutOpen.
         * @memberof msgProto
         * @classdesc Represents a PkOutOpen.
         * @implements IPkOutOpen
         * @constructor
         * @param {msgProto.IPkOutOpen=} [properties] Properties to set
         */
        function PkOutOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutOpen instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {msgProto.IPkOutOpen=} [properties] Properties to set
         * @returns {msgProto.PkOutOpen} PkOutOpen instance
         */
        PkOutOpen.create = function create(properties) {
            return new PkOutOpen(properties);
        };

        /**
         * Encodes the specified PkOutOpen message. Does not implicitly {@link msgProto.PkOutOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {msgProto.IPkOutOpen} message PkOutOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutOpen message, length delimited. Does not implicitly {@link msgProto.PkOutOpen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {msgProto.IPkOutOpen} message PkOutOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutOpen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutOpen} PkOutOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutOpen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutOpen} PkOutOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutOpen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutOpen message.
         * @function verify
         * @memberof msgProto.PkOutOpen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutOpen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutOpen;
    })();

    msgProto.PkOutGetEnemyList = (function() {

        /**
         * Properties of a PkOutGetEnemyList.
         * @memberof msgProto
         * @interface IPkOutGetEnemyList
         */

        /**
         * Constructs a new PkOutGetEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetEnemyList.
         * @implements IPkOutGetEnemyList
         * @constructor
         * @param {msgProto.IPkOutGetEnemyList=} [properties] Properties to set
         */
        function PkOutGetEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetEnemyList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {msgProto.IPkOutGetEnemyList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetEnemyList} PkOutGetEnemyList instance
         */
        PkOutGetEnemyList.create = function create(properties) {
            return new PkOutGetEnemyList(properties);
        };

        /**
         * Encodes the specified PkOutGetEnemyList message. Does not implicitly {@link msgProto.PkOutGetEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {msgProto.IPkOutGetEnemyList} message PkOutGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetEnemyList message, length delimited. Does not implicitly {@link msgProto.PkOutGetEnemyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {msgProto.IPkOutGetEnemyList} message PkOutGetEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetEnemyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetEnemyList} PkOutGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetEnemyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetEnemyList} PkOutGetEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetEnemyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetEnemyList message.
         * @function verify
         * @memberof msgProto.PkOutGetEnemyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetEnemyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetEnemyList;
    })();

    msgProto.PkOutGetRevengeEnemyList = (function() {

        /**
         * Properties of a PkOutGetRevengeEnemyList.
         * @memberof msgProto
         * @interface IPkOutGetRevengeEnemyList
         */

        /**
         * Constructs a new PkOutGetRevengeEnemyList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRevengeEnemyList.
         * @implements IPkOutGetRevengeEnemyList
         * @constructor
         * @param {msgProto.IPkOutGetRevengeEnemyList=} [properties] Properties to set
         */
        function PkOutGetRevengeEnemyList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetRevengeEnemyList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {msgProto.IPkOutGetRevengeEnemyList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetRevengeEnemyList} PkOutGetRevengeEnemyList instance
         */
        PkOutGetRevengeEnemyList.create = function create(properties) {
            return new PkOutGetRevengeEnemyList(properties);
        };

        /**
         * Encodes the specified PkOutGetRevengeEnemyList message. Does not implicitly {@link msgProto.PkOutGetRevengeEnemyList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {msgProto.IPkOutGetRevengeEnemyList} message PkOutGetRevengeEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRevengeEnemyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetRevengeEnemyList message, length delimited. Does not implicitly {@link msgProto.PkOutGetRevengeEnemyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {msgProto.IPkOutGetRevengeEnemyList} message PkOutGetRevengeEnemyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRevengeEnemyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetRevengeEnemyList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRevengeEnemyList} PkOutGetRevengeEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRevengeEnemyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRevengeEnemyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetRevengeEnemyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetRevengeEnemyList} PkOutGetRevengeEnemyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRevengeEnemyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetRevengeEnemyList message.
         * @function verify
         * @memberof msgProto.PkOutGetRevengeEnemyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetRevengeEnemyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetRevengeEnemyList;
    })();

    msgProto.PkOutRefreshEnemy = (function() {

        /**
         * Properties of a PkOutRefreshEnemy.
         * @memberof msgProto
         * @interface IPkOutRefreshEnemy
         */

        /**
         * Constructs a new PkOutRefreshEnemy.
         * @memberof msgProto
         * @classdesc Represents a PkOutRefreshEnemy.
         * @implements IPkOutRefreshEnemy
         * @constructor
         * @param {msgProto.IPkOutRefreshEnemy=} [properties] Properties to set
         */
        function PkOutRefreshEnemy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutRefreshEnemy instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {msgProto.IPkOutRefreshEnemy=} [properties] Properties to set
         * @returns {msgProto.PkOutRefreshEnemy} PkOutRefreshEnemy instance
         */
        PkOutRefreshEnemy.create = function create(properties) {
            return new PkOutRefreshEnemy(properties);
        };

        /**
         * Encodes the specified PkOutRefreshEnemy message. Does not implicitly {@link msgProto.PkOutRefreshEnemy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {msgProto.IPkOutRefreshEnemy} message PkOutRefreshEnemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutRefreshEnemy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutRefreshEnemy message, length delimited. Does not implicitly {@link msgProto.PkOutRefreshEnemy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {msgProto.IPkOutRefreshEnemy} message PkOutRefreshEnemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutRefreshEnemy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutRefreshEnemy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutRefreshEnemy} PkOutRefreshEnemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutRefreshEnemy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutRefreshEnemy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutRefreshEnemy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutRefreshEnemy} PkOutRefreshEnemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutRefreshEnemy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutRefreshEnemy message.
         * @function verify
         * @memberof msgProto.PkOutRefreshEnemy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutRefreshEnemy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutRefreshEnemy;
    })();

    msgProto.PkOutStart = (function() {

        /**
         * Properties of a PkOutStart.
         * @memberof msgProto
         * @interface IPkOutStart
         * @property {number|Long|null} [enemyId] PkOutStart enemyId
         * @property {number|null} [fightType] PkOutStart fightType
         * @property {boolean|null} [isRevenge] PkOutStart isRevenge
         */

        /**
         * Constructs a new PkOutStart.
         * @memberof msgProto
         * @classdesc Represents a PkOutStart.
         * @implements IPkOutStart
         * @constructor
         * @param {msgProto.IPkOutStart=} [properties] Properties to set
         */
        function PkOutStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutStart enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkOutStart fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.fightType = 0;

        /**
         * PkOutStart isRevenge.
         * @member {boolean} isRevenge
         * @memberof msgProto.PkOutStart
         * @instance
         */
        PkOutStart.prototype.isRevenge = false;

        /**
         * Creates a new PkOutStart instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutStart
         * @static
         * @param {msgProto.IPkOutStart=} [properties] Properties to set
         * @returns {msgProto.PkOutStart} PkOutStart instance
         */
        PkOutStart.create = function create(properties) {
            return new PkOutStart(properties);
        };

        /**
         * Encodes the specified PkOutStart message. Does not implicitly {@link msgProto.PkOutStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutStart
         * @static
         * @param {msgProto.IPkOutStart} message PkOutStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.enemyId);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fightType);
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isRevenge);
            return writer;
        };

        /**
         * Encodes the specified PkOutStart message, length delimited. Does not implicitly {@link msgProto.PkOutStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutStart
         * @static
         * @param {msgProto.IPkOutStart} message PkOutStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutStart} PkOutStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enemyId = reader.uint64();
                    break;
                case 2:
                    message.fightType = reader.int32();
                    break;
                case 3:
                    message.isRevenge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutStart} PkOutStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutStart message.
         * @function verify
         * @memberof msgProto.PkOutStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (!$util.isInteger(message.enemyId) && !(message.enemyId && $util.isInteger(message.enemyId.low) && $util.isInteger(message.enemyId.high)))
                    return "enemyId: integer|Long expected";
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                if (!$util.isInteger(message.fightType))
                    return "fightType: integer expected";
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                if (typeof message.isRevenge !== "boolean")
                    return "isRevenge: boolean expected";
            return null;
        };

        return PkOutStart;
    })();

    msgProto.PkOutEnd = (function() {

        /**
         * Properties of a PkOutEnd.
         * @memberof msgProto
         * @interface IPkOutEnd
         * @property {boolean|null} [isWin] PkOutEnd isWin
         * @property {number|Long|null} [enemyId] PkOutEnd enemyId
         * @property {string|null} [fightData] PkOutEnd fightData
         * @property {number|null} [fightType] PkOutEnd fightType
         * @property {boolean|null} [isRevenge] PkOutEnd isRevenge
         */

        /**
         * Constructs a new PkOutEnd.
         * @memberof msgProto
         * @classdesc Represents a PkOutEnd.
         * @implements IPkOutEnd
         * @constructor
         * @param {msgProto.IPkOutEnd=} [properties] Properties to set
         */
        function PkOutEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.isWin = false;

        /**
         * PkOutEnd enemyId.
         * @member {number|Long} enemyId
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.enemyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PkOutEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.fightData = "";

        /**
         * PkOutEnd fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.fightType = 0;

        /**
         * PkOutEnd isRevenge.
         * @member {boolean} isRevenge
         * @memberof msgProto.PkOutEnd
         * @instance
         */
        PkOutEnd.prototype.isRevenge = false;

        /**
         * Creates a new PkOutEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {msgProto.IPkOutEnd=} [properties] Properties to set
         * @returns {msgProto.PkOutEnd} PkOutEnd instance
         */
        PkOutEnd.create = function create(properties) {
            return new PkOutEnd(properties);
        };

        /**
         * Encodes the specified PkOutEnd message. Does not implicitly {@link msgProto.PkOutEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {msgProto.IPkOutEnd} message PkOutEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.enemyId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fightType);
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isRevenge);
            return writer;
        };

        /**
         * Encodes the specified PkOutEnd message, length delimited. Does not implicitly {@link msgProto.PkOutEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {msgProto.IPkOutEnd} message PkOutEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutEnd} PkOutEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                case 2:
                    message.enemyId = reader.uint64();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                case 4:
                    message.fightType = reader.int32();
                    break;
                case 5:
                    message.isRevenge = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutEnd} PkOutEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutEnd message.
         * @function verify
         * @memberof msgProto.PkOutEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.enemyId != null && message.hasOwnProperty("enemyId"))
                if (!$util.isInteger(message.enemyId) && !(message.enemyId && $util.isInteger(message.enemyId.low) && $util.isInteger(message.enemyId.high)))
                    return "enemyId: integer|Long expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                if (!$util.isInteger(message.fightType))
                    return "fightType: integer expected";
            if (message.isRevenge != null && message.hasOwnProperty("isRevenge"))
                if (typeof message.isRevenge !== "boolean")
                    return "isRevenge: boolean expected";
            return null;
        };

        return PkOutEnd;
    })();

    msgProto.PkOutGetRankList = (function() {

        /**
         * Properties of a PkOutGetRankList.
         * @memberof msgProto
         * @interface IPkOutGetRankList
         */

        /**
         * Constructs a new PkOutGetRankList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRankList.
         * @implements IPkOutGetRankList
         * @constructor
         * @param {msgProto.IPkOutGetRankList=} [properties] Properties to set
         */
        function PkOutGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {msgProto.IPkOutGetRankList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetRankList} PkOutGetRankList instance
         */
        PkOutGetRankList.create = function create(properties) {
            return new PkOutGetRankList(properties);
        };

        /**
         * Encodes the specified PkOutGetRankList message. Does not implicitly {@link msgProto.PkOutGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {msgProto.IPkOutGetRankList} message PkOutGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetRankList message, length delimited. Does not implicitly {@link msgProto.PkOutGetRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {msgProto.IPkOutGetRankList} message PkOutGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRankList} PkOutGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetRankList} PkOutGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetRankList message.
         * @function verify
         * @memberof msgProto.PkOutGetRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetRankList;
    })();

    msgProto.PkOutGetMyRank = (function() {

        /**
         * Properties of a PkOutGetMyRank.
         * @memberof msgProto
         * @interface IPkOutGetMyRank
         */

        /**
         * Constructs a new PkOutGetMyRank.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetMyRank.
         * @implements IPkOutGetMyRank
         * @constructor
         * @param {msgProto.IPkOutGetMyRank=} [properties] Properties to set
         */
        function PkOutGetMyRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetMyRank instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {msgProto.IPkOutGetMyRank=} [properties] Properties to set
         * @returns {msgProto.PkOutGetMyRank} PkOutGetMyRank instance
         */
        PkOutGetMyRank.create = function create(properties) {
            return new PkOutGetMyRank(properties);
        };

        /**
         * Encodes the specified PkOutGetMyRank message. Does not implicitly {@link msgProto.PkOutGetMyRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {msgProto.IPkOutGetMyRank} message PkOutGetMyRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetMyRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetMyRank message, length delimited. Does not implicitly {@link msgProto.PkOutGetMyRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {msgProto.IPkOutGetMyRank} message PkOutGetMyRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetMyRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetMyRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetMyRank} PkOutGetMyRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetMyRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetMyRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetMyRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetMyRank} PkOutGetMyRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetMyRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetMyRank message.
         * @function verify
         * @memberof msgProto.PkOutGetMyRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetMyRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetMyRank;
    })();

    msgProto.PkOutGetPkRecordList = (function() {

        /**
         * Properties of a PkOutGetPkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetPkRecordList
         */

        /**
         * Constructs a new PkOutGetPkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetPkRecordList.
         * @implements IPkOutGetPkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetPkRecordList=} [properties] Properties to set
         */
        function PkOutGetPkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetPkRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {msgProto.IPkOutGetPkRecordList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetPkRecordList} PkOutGetPkRecordList instance
         */
        PkOutGetPkRecordList.create = function create(properties) {
            return new PkOutGetPkRecordList(properties);
        };

        /**
         * Encodes the specified PkOutGetPkRecordList message. Does not implicitly {@link msgProto.PkOutGetPkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {msgProto.IPkOutGetPkRecordList} message PkOutGetPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetPkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetPkRecordList message, length delimited. Does not implicitly {@link msgProto.PkOutGetPkRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {msgProto.IPkOutGetPkRecordList} message PkOutGetPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetPkRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetPkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetPkRecordList} PkOutGetPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetPkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetPkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetPkRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetPkRecordList} PkOutGetPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetPkRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetPkRecordList message.
         * @function verify
         * @memberof msgProto.PkOutGetPkRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetPkRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetPkRecordList;
    })();

    msgProto.PkOutGetRankPkRecordList = (function() {

        /**
         * Properties of a PkOutGetRankPkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetRankPkRecordList
         */

        /**
         * Constructs a new PkOutGetRankPkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetRankPkRecordList.
         * @implements IPkOutGetRankPkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetRankPkRecordList=} [properties] Properties to set
         */
        function PkOutGetRankPkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetRankPkRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {msgProto.IPkOutGetRankPkRecordList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetRankPkRecordList} PkOutGetRankPkRecordList instance
         */
        PkOutGetRankPkRecordList.create = function create(properties) {
            return new PkOutGetRankPkRecordList(properties);
        };

        /**
         * Encodes the specified PkOutGetRankPkRecordList message. Does not implicitly {@link msgProto.PkOutGetRankPkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {msgProto.IPkOutGetRankPkRecordList} message PkOutGetRankPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankPkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetRankPkRecordList message, length delimited. Does not implicitly {@link msgProto.PkOutGetRankPkRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {msgProto.IPkOutGetRankPkRecordList} message PkOutGetRankPkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetRankPkRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetRankPkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetRankPkRecordList} PkOutGetRankPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankPkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetRankPkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetRankPkRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetRankPkRecordList} PkOutGetRankPkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetRankPkRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetRankPkRecordList message.
         * @function verify
         * @memberof msgProto.PkOutGetRankPkRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetRankPkRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetRankPkRecordList;
    })();

    msgProto.PkOutSetPkRecordRead = (function() {

        /**
         * Properties of a PkOutSetPkRecordRead.
         * @memberof msgProto
         * @interface IPkOutSetPkRecordRead
         */

        /**
         * Constructs a new PkOutSetPkRecordRead.
         * @memberof msgProto
         * @classdesc Represents a PkOutSetPkRecordRead.
         * @implements IPkOutSetPkRecordRead
         * @constructor
         * @param {msgProto.IPkOutSetPkRecordRead=} [properties] Properties to set
         */
        function PkOutSetPkRecordRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutSetPkRecordRead instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {msgProto.IPkOutSetPkRecordRead=} [properties] Properties to set
         * @returns {msgProto.PkOutSetPkRecordRead} PkOutSetPkRecordRead instance
         */
        PkOutSetPkRecordRead.create = function create(properties) {
            return new PkOutSetPkRecordRead(properties);
        };

        /**
         * Encodes the specified PkOutSetPkRecordRead message. Does not implicitly {@link msgProto.PkOutSetPkRecordRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {msgProto.IPkOutSetPkRecordRead} message PkOutSetPkRecordRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutSetPkRecordRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutSetPkRecordRead message, length delimited. Does not implicitly {@link msgProto.PkOutSetPkRecordRead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {msgProto.IPkOutSetPkRecordRead} message PkOutSetPkRecordRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutSetPkRecordRead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutSetPkRecordRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutSetPkRecordRead} PkOutSetPkRecordRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutSetPkRecordRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutSetPkRecordRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutSetPkRecordRead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutSetPkRecordRead} PkOutSetPkRecordRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutSetPkRecordRead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutSetPkRecordRead message.
         * @function verify
         * @memberof msgProto.PkOutSetPkRecordRead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutSetPkRecordRead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutSetPkRecordRead;
    })();

    msgProto.PkOutDealRecord = (function() {

        /**
         * Properties of a PkOutDealRecord.
         * @memberof msgProto
         * @interface IPkOutDealRecord
         * @property {number|null} [fightType] PkOutDealRecord fightType
         */

        /**
         * Constructs a new PkOutDealRecord.
         * @memberof msgProto
         * @classdesc Represents a PkOutDealRecord.
         * @implements IPkOutDealRecord
         * @constructor
         * @param {msgProto.IPkOutDealRecord=} [properties] Properties to set
         */
        function PkOutDealRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PkOutDealRecord fightType.
         * @member {number} fightType
         * @memberof msgProto.PkOutDealRecord
         * @instance
         */
        PkOutDealRecord.prototype.fightType = 0;

        /**
         * Creates a new PkOutDealRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {msgProto.IPkOutDealRecord=} [properties] Properties to set
         * @returns {msgProto.PkOutDealRecord} PkOutDealRecord instance
         */
        PkOutDealRecord.create = function create(properties) {
            return new PkOutDealRecord(properties);
        };

        /**
         * Encodes the specified PkOutDealRecord message. Does not implicitly {@link msgProto.PkOutDealRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {msgProto.IPkOutDealRecord} message PkOutDealRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutDealRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fightType);
            return writer;
        };

        /**
         * Encodes the specified PkOutDealRecord message, length delimited. Does not implicitly {@link msgProto.PkOutDealRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {msgProto.IPkOutDealRecord} message PkOutDealRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutDealRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutDealRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutDealRecord} PkOutDealRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutDealRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutDealRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fightType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutDealRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutDealRecord} PkOutDealRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutDealRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutDealRecord message.
         * @function verify
         * @memberof msgProto.PkOutDealRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutDealRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fightType != null && message.hasOwnProperty("fightType"))
                if (!$util.isInteger(message.fightType))
                    return "fightType: integer expected";
            return null;
        };

        return PkOutDealRecord;
    })();

    msgProto.PkOutClearPkValue = (function() {

        /**
         * Properties of a PkOutClearPkValue.
         * @memberof msgProto
         * @interface IPkOutClearPkValue
         */

        /**
         * Constructs a new PkOutClearPkValue.
         * @memberof msgProto
         * @classdesc Represents a PkOutClearPkValue.
         * @implements IPkOutClearPkValue
         * @constructor
         * @param {msgProto.IPkOutClearPkValue=} [properties] Properties to set
         */
        function PkOutClearPkValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutClearPkValue instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {msgProto.IPkOutClearPkValue=} [properties] Properties to set
         * @returns {msgProto.PkOutClearPkValue} PkOutClearPkValue instance
         */
        PkOutClearPkValue.create = function create(properties) {
            return new PkOutClearPkValue(properties);
        };

        /**
         * Encodes the specified PkOutClearPkValue message. Does not implicitly {@link msgProto.PkOutClearPkValue.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {msgProto.IPkOutClearPkValue} message PkOutClearPkValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutClearPkValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutClearPkValue message, length delimited. Does not implicitly {@link msgProto.PkOutClearPkValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {msgProto.IPkOutClearPkValue} message PkOutClearPkValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutClearPkValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutClearPkValue message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutClearPkValue} PkOutClearPkValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutClearPkValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutClearPkValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutClearPkValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutClearPkValue} PkOutClearPkValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutClearPkValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutClearPkValue message.
         * @function verify
         * @memberof msgProto.PkOutClearPkValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutClearPkValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutClearPkValue;
    })();

    msgProto.PkOutResetBePkKill = (function() {

        /**
         * Properties of a PkOutResetBePkKill.
         * @memberof msgProto
         * @interface IPkOutResetBePkKill
         */

        /**
         * Constructs a new PkOutResetBePkKill.
         * @memberof msgProto
         * @classdesc Represents a PkOutResetBePkKill.
         * @implements IPkOutResetBePkKill
         * @constructor
         * @param {msgProto.IPkOutResetBePkKill=} [properties] Properties to set
         */
        function PkOutResetBePkKill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutResetBePkKill instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {msgProto.IPkOutResetBePkKill=} [properties] Properties to set
         * @returns {msgProto.PkOutResetBePkKill} PkOutResetBePkKill instance
         */
        PkOutResetBePkKill.create = function create(properties) {
            return new PkOutResetBePkKill(properties);
        };

        /**
         * Encodes the specified PkOutResetBePkKill message. Does not implicitly {@link msgProto.PkOutResetBePkKill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {msgProto.IPkOutResetBePkKill} message PkOutResetBePkKill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutResetBePkKill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutResetBePkKill message, length delimited. Does not implicitly {@link msgProto.PkOutResetBePkKill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {msgProto.IPkOutResetBePkKill} message PkOutResetBePkKill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutResetBePkKill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutResetBePkKill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutResetBePkKill} PkOutResetBePkKill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutResetBePkKill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutResetBePkKill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutResetBePkKill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutResetBePkKill} PkOutResetBePkKill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutResetBePkKill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutResetBePkKill message.
         * @function verify
         * @memberof msgProto.PkOutResetBePkKill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutResetBePkKill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutResetBePkKill;
    })();

    msgProto.PkOutIncognito = (function() {

        /**
         * Properties of a PkOutIncognito.
         * @memberof msgProto
         * @interface IPkOutIncognito
         */

        /**
         * Constructs a new PkOutIncognito.
         * @memberof msgProto
         * @classdesc Represents a PkOutIncognito.
         * @implements IPkOutIncognito
         * @constructor
         * @param {msgProto.IPkOutIncognito=} [properties] Properties to set
         */
        function PkOutIncognito(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutIncognito instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {msgProto.IPkOutIncognito=} [properties] Properties to set
         * @returns {msgProto.PkOutIncognito} PkOutIncognito instance
         */
        PkOutIncognito.create = function create(properties) {
            return new PkOutIncognito(properties);
        };

        /**
         * Encodes the specified PkOutIncognito message. Does not implicitly {@link msgProto.PkOutIncognito.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {msgProto.IPkOutIncognito} message PkOutIncognito message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutIncognito.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutIncognito message, length delimited. Does not implicitly {@link msgProto.PkOutIncognito.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {msgProto.IPkOutIncognito} message PkOutIncognito message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutIncognito.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutIncognito message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutIncognito} PkOutIncognito
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutIncognito.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutIncognito();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutIncognito message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutIncognito} PkOutIncognito
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutIncognito.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutIncognito message.
         * @function verify
         * @memberof msgProto.PkOutIncognito
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutIncognito.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutIncognito;
    })();

    msgProto.PkOutGetTreasurePkRecordList = (function() {

        /**
         * Properties of a PkOutGetTreasurePkRecordList.
         * @memberof msgProto
         * @interface IPkOutGetTreasurePkRecordList
         */

        /**
         * Constructs a new PkOutGetTreasurePkRecordList.
         * @memberof msgProto
         * @classdesc Represents a PkOutGetTreasurePkRecordList.
         * @implements IPkOutGetTreasurePkRecordList
         * @constructor
         * @param {msgProto.IPkOutGetTreasurePkRecordList=} [properties] Properties to set
         */
        function PkOutGetTreasurePkRecordList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PkOutGetTreasurePkRecordList instance using the specified properties.
         * @function create
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {msgProto.IPkOutGetTreasurePkRecordList=} [properties] Properties to set
         * @returns {msgProto.PkOutGetTreasurePkRecordList} PkOutGetTreasurePkRecordList instance
         */
        PkOutGetTreasurePkRecordList.create = function create(properties) {
            return new PkOutGetTreasurePkRecordList(properties);
        };

        /**
         * Encodes the specified PkOutGetTreasurePkRecordList message. Does not implicitly {@link msgProto.PkOutGetTreasurePkRecordList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {msgProto.IPkOutGetTreasurePkRecordList} message PkOutGetTreasurePkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetTreasurePkRecordList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PkOutGetTreasurePkRecordList message, length delimited. Does not implicitly {@link msgProto.PkOutGetTreasurePkRecordList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {msgProto.IPkOutGetTreasurePkRecordList} message PkOutGetTreasurePkRecordList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PkOutGetTreasurePkRecordList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PkOutGetTreasurePkRecordList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PkOutGetTreasurePkRecordList} PkOutGetTreasurePkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetTreasurePkRecordList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PkOutGetTreasurePkRecordList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PkOutGetTreasurePkRecordList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PkOutGetTreasurePkRecordList} PkOutGetTreasurePkRecordList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PkOutGetTreasurePkRecordList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PkOutGetTreasurePkRecordList message.
         * @function verify
         * @memberof msgProto.PkOutGetTreasurePkRecordList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PkOutGetTreasurePkRecordList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PkOutGetTreasurePkRecordList;
    })();

    msgProto.ShopGetInfo = (function() {

        /**
         * Properties of a ShopGetInfo.
         * @memberof msgProto
         * @interface IShopGetInfo
         * @property {number|null} [type] ShopGetInfo type
         */

        /**
         * Constructs a new ShopGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ShopGetInfo.
         * @implements IShopGetInfo
         * @constructor
         * @param {msgProto.IShopGetInfo=} [properties] Properties to set
         */
        function ShopGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopGetInfo type.
         * @member {number} type
         * @memberof msgProto.ShopGetInfo
         * @instance
         */
        ShopGetInfo.prototype.type = 0;

        /**
         * Creates a new ShopGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {msgProto.IShopGetInfo=} [properties] Properties to set
         * @returns {msgProto.ShopGetInfo} ShopGetInfo instance
         */
        ShopGetInfo.create = function create(properties) {
            return new ShopGetInfo(properties);
        };

        /**
         * Encodes the specified ShopGetInfo message. Does not implicitly {@link msgProto.ShopGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {msgProto.IShopGetInfo} message ShopGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ShopGetInfo message, length delimited. Does not implicitly {@link msgProto.ShopGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {msgProto.IShopGetInfo} message ShopGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopGetInfo} ShopGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ShopGetInfo} ShopGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopGetInfo message.
         * @function verify
         * @memberof msgProto.ShopGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return ShopGetInfo;
    })();

    msgProto.ShopRefreshExShop = (function() {

        /**
         * Properties of a ShopRefreshExShop.
         * @memberof msgProto
         * @interface IShopRefreshExShop
         * @property {number|null} [type] ShopRefreshExShop type
         * @property {boolean|null} [lvlRefresh] ShopRefreshExShop lvlRefresh
         */

        /**
         * Constructs a new ShopRefreshExShop.
         * @memberof msgProto
         * @classdesc Represents a ShopRefreshExShop.
         * @implements IShopRefreshExShop
         * @constructor
         * @param {msgProto.IShopRefreshExShop=} [properties] Properties to set
         */
        function ShopRefreshExShop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopRefreshExShop type.
         * @member {number} type
         * @memberof msgProto.ShopRefreshExShop
         * @instance
         */
        ShopRefreshExShop.prototype.type = 0;

        /**
         * ShopRefreshExShop lvlRefresh.
         * @member {boolean} lvlRefresh
         * @memberof msgProto.ShopRefreshExShop
         * @instance
         */
        ShopRefreshExShop.prototype.lvlRefresh = false;

        /**
         * Creates a new ShopRefreshExShop instance using the specified properties.
         * @function create
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {msgProto.IShopRefreshExShop=} [properties] Properties to set
         * @returns {msgProto.ShopRefreshExShop} ShopRefreshExShop instance
         */
        ShopRefreshExShop.create = function create(properties) {
            return new ShopRefreshExShop(properties);
        };

        /**
         * Encodes the specified ShopRefreshExShop message. Does not implicitly {@link msgProto.ShopRefreshExShop.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {msgProto.IShopRefreshExShop} message ShopRefreshExShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopRefreshExShop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.lvlRefresh != null && message.hasOwnProperty("lvlRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.lvlRefresh);
            return writer;
        };

        /**
         * Encodes the specified ShopRefreshExShop message, length delimited. Does not implicitly {@link msgProto.ShopRefreshExShop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {msgProto.IShopRefreshExShop} message ShopRefreshExShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopRefreshExShop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopRefreshExShop message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopRefreshExShop} ShopRefreshExShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopRefreshExShop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopRefreshExShop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.lvlRefresh = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopRefreshExShop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ShopRefreshExShop} ShopRefreshExShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopRefreshExShop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopRefreshExShop message.
         * @function verify
         * @memberof msgProto.ShopRefreshExShop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopRefreshExShop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.lvlRefresh != null && message.hasOwnProperty("lvlRefresh"))
                if (typeof message.lvlRefresh !== "boolean")
                    return "lvlRefresh: boolean expected";
            return null;
        };

        return ShopRefreshExShop;
    })();

    msgProto.ShopBuy = (function() {

        /**
         * Properties of a ShopBuy.
         * @memberof msgProto
         * @interface IShopBuy
         * @property {number|null} [index] ShopBuy index
         * @property {number|null} [type] ShopBuy type
         * @property {number|null} [num] ShopBuy num
         */

        /**
         * Constructs a new ShopBuy.
         * @memberof msgProto
         * @classdesc Represents a ShopBuy.
         * @implements IShopBuy
         * @constructor
         * @param {msgProto.IShopBuy=} [properties] Properties to set
         */
        function ShopBuy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopBuy index.
         * @member {number} index
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.index = 0;

        /**
         * ShopBuy type.
         * @member {number} type
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.type = 0;

        /**
         * ShopBuy num.
         * @member {number} num
         * @memberof msgProto.ShopBuy
         * @instance
         */
        ShopBuy.prototype.num = 0;

        /**
         * Creates a new ShopBuy instance using the specified properties.
         * @function create
         * @memberof msgProto.ShopBuy
         * @static
         * @param {msgProto.IShopBuy=} [properties] Properties to set
         * @returns {msgProto.ShopBuy} ShopBuy instance
         */
        ShopBuy.create = function create(properties) {
            return new ShopBuy(properties);
        };

        /**
         * Encodes the specified ShopBuy message. Does not implicitly {@link msgProto.ShopBuy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopBuy
         * @static
         * @param {msgProto.IShopBuy} message ShopBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.num != null && message.hasOwnProperty("num"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num);
            return writer;
        };

        /**
         * Encodes the specified ShopBuy message, length delimited. Does not implicitly {@link msgProto.ShopBuy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ShopBuy
         * @static
         * @param {msgProto.IShopBuy} message ShopBuy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopBuy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopBuy} ShopBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopBuy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopBuy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ShopBuy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ShopBuy} ShopBuy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopBuy message.
         * @function verify
         * @memberof msgProto.ShopBuy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopBuy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        return ShopBuy;
    })();

    msgProto.ShopBuyAll = (function() {

        /**
         * Properties of a ShopBuyAll.
         * @memberof msgProto
         * @interface IShopBuyAll
         * @property {number|null} [type] ShopBuyAll type
         */

        /**
         * Constructs a new ShopBuyAll.
         * @memberof msgProto
         * @classdesc Represents a ShopBuyAll.
         * @implements IShopBuyAll
         * @constructor
         * @param {msgProto.IShopBuyAll=} [properties] Properties to set
         */
        function ShopBuyAll(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopBuyAll type.
         * @member {number} type
         * @memberof msgProto.ShopBuyAll
         * @instance
         */
        ShopBuyAll.prototype.type = 0;

        /**
         * Creates a new ShopBuyAll instance using the specified properties.
         * @function create
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {msgProto.IShopBuyAll=} [properties] Properties to set
         * @returns {msgProto.ShopBuyAll} ShopBuyAll instance
         */
        ShopBuyAll.create = function create(properties) {
            return new ShopBuyAll(properties);
        };

        /**
         * Encodes the specified ShopBuyAll message. Does not implicitly {@link msgProto.ShopBuyAll.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {msgProto.IShopBuyAll} message ShopBuyAll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuyAll.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ShopBuyAll message, length delimited. Does not implicitly {@link msgProto.ShopBuyAll.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {msgProto.IShopBuyAll} message ShopBuyAll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopBuyAll.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopBuyAll message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ShopBuyAll} ShopBuyAll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuyAll.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ShopBuyAll();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopBuyAll message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ShopBuyAll} ShopBuyAll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopBuyAll.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopBuyAll message.
         * @function verify
         * @memberof msgProto.ShopBuyAll
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopBuyAll.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return ShopBuyAll;
    })();

    msgProto.CopyGetInfo = (function() {

        /**
         * Properties of a CopyGetInfo.
         * @memberof msgProto
         * @interface ICopyGetInfo
         * @property {number|null} [type] CopyGetInfo type
         */

        /**
         * Constructs a new CopyGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CopyGetInfo.
         * @implements ICopyGetInfo
         * @constructor
         * @param {msgProto.ICopyGetInfo=} [properties] Properties to set
         */
        function CopyGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGetInfo type.
         * @member {number} type
         * @memberof msgProto.CopyGetInfo
         * @instance
         */
        CopyGetInfo.prototype.type = 0;

        /**
         * Creates a new CopyGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {msgProto.ICopyGetInfo=} [properties] Properties to set
         * @returns {msgProto.CopyGetInfo} CopyGetInfo instance
         */
        CopyGetInfo.create = function create(properties) {
            return new CopyGetInfo(properties);
        };

        /**
         * Encodes the specified CopyGetInfo message. Does not implicitly {@link msgProto.CopyGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {msgProto.ICopyGetInfo} message CopyGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified CopyGetInfo message, length delimited. Does not implicitly {@link msgProto.CopyGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {msgProto.ICopyGetInfo} message CopyGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGetInfo} CopyGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyGetInfo} CopyGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyGetInfo message.
         * @function verify
         * @memberof msgProto.CopyGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return CopyGetInfo;
    })();

    msgProto.CopyBuyCopyCount = (function() {

        /**
         * Properties of a CopyBuyCopyCount.
         * @memberof msgProto
         * @interface ICopyBuyCopyCount
         * @property {number|null} [type] CopyBuyCopyCount type
         * @property {number|null} [copyId] CopyBuyCopyCount copyId
         */

        /**
         * Constructs a new CopyBuyCopyCount.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyCopyCount.
         * @implements ICopyBuyCopyCount
         * @constructor
         * @param {msgProto.ICopyBuyCopyCount=} [properties] Properties to set
         */
        function CopyBuyCopyCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyBuyCopyCount type.
         * @member {number} type
         * @memberof msgProto.CopyBuyCopyCount
         * @instance
         */
        CopyBuyCopyCount.prototype.type = 0;

        /**
         * CopyBuyCopyCount copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyBuyCopyCount
         * @instance
         */
        CopyBuyCopyCount.prototype.copyId = 0;

        /**
         * Creates a new CopyBuyCopyCount instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {msgProto.ICopyBuyCopyCount=} [properties] Properties to set
         * @returns {msgProto.CopyBuyCopyCount} CopyBuyCopyCount instance
         */
        CopyBuyCopyCount.create = function create(properties) {
            return new CopyBuyCopyCount(properties);
        };

        /**
         * Encodes the specified CopyBuyCopyCount message. Does not implicitly {@link msgProto.CopyBuyCopyCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {msgProto.ICopyBuyCopyCount} message CopyBuyCopyCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyCopyCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.copyId);
            return writer;
        };

        /**
         * Encodes the specified CopyBuyCopyCount message, length delimited. Does not implicitly {@link msgProto.CopyBuyCopyCount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {msgProto.ICopyBuyCopyCount} message CopyBuyCopyCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyCopyCount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyBuyCopyCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyCopyCount} CopyBuyCopyCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyCopyCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyCopyCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyBuyCopyCount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyBuyCopyCount} CopyBuyCopyCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyCopyCount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyBuyCopyCount message.
         * @function verify
         * @memberof msgProto.CopyBuyCopyCount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyBuyCopyCount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            return null;
        };

        return CopyBuyCopyCount;
    })();

    msgProto.CopyBuyEquipTessera = (function() {

        /**
         * Properties of a CopyBuyEquipTessera.
         * @memberof msgProto
         * @interface ICopyBuyEquipTessera
         */

        /**
         * Constructs a new CopyBuyEquipTessera.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyEquipTessera.
         * @implements ICopyBuyEquipTessera
         * @constructor
         * @param {msgProto.ICopyBuyEquipTessera=} [properties] Properties to set
         */
        function CopyBuyEquipTessera(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CopyBuyEquipTessera instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {msgProto.ICopyBuyEquipTessera=} [properties] Properties to set
         * @returns {msgProto.CopyBuyEquipTessera} CopyBuyEquipTessera instance
         */
        CopyBuyEquipTessera.create = function create(properties) {
            return new CopyBuyEquipTessera(properties);
        };

        /**
         * Encodes the specified CopyBuyEquipTessera message. Does not implicitly {@link msgProto.CopyBuyEquipTessera.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {msgProto.ICopyBuyEquipTessera} message CopyBuyEquipTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyEquipTessera.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CopyBuyEquipTessera message, length delimited. Does not implicitly {@link msgProto.CopyBuyEquipTessera.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {msgProto.ICopyBuyEquipTessera} message CopyBuyEquipTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyEquipTessera.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyBuyEquipTessera message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyEquipTessera} CopyBuyEquipTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyEquipTessera.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyEquipTessera();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyBuyEquipTessera message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyBuyEquipTessera} CopyBuyEquipTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyEquipTessera.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyBuyEquipTessera message.
         * @function verify
         * @memberof msgProto.CopyBuyEquipTessera
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyBuyEquipTessera.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CopyBuyEquipTessera;
    })();

    msgProto.CopyBuyRealmTessera = (function() {

        /**
         * Properties of a CopyBuyRealmTessera.
         * @memberof msgProto
         * @interface ICopyBuyRealmTessera
         */

        /**
         * Constructs a new CopyBuyRealmTessera.
         * @memberof msgProto
         * @classdesc Represents a CopyBuyRealmTessera.
         * @implements ICopyBuyRealmTessera
         * @constructor
         * @param {msgProto.ICopyBuyRealmTessera=} [properties] Properties to set
         */
        function CopyBuyRealmTessera(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CopyBuyRealmTessera instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {msgProto.ICopyBuyRealmTessera=} [properties] Properties to set
         * @returns {msgProto.CopyBuyRealmTessera} CopyBuyRealmTessera instance
         */
        CopyBuyRealmTessera.create = function create(properties) {
            return new CopyBuyRealmTessera(properties);
        };

        /**
         * Encodes the specified CopyBuyRealmTessera message. Does not implicitly {@link msgProto.CopyBuyRealmTessera.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {msgProto.ICopyBuyRealmTessera} message CopyBuyRealmTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyRealmTessera.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CopyBuyRealmTessera message, length delimited. Does not implicitly {@link msgProto.CopyBuyRealmTessera.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {msgProto.ICopyBuyRealmTessera} message CopyBuyRealmTessera message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyBuyRealmTessera.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyBuyRealmTessera message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyBuyRealmTessera} CopyBuyRealmTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyRealmTessera.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyBuyRealmTessera();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyBuyRealmTessera message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyBuyRealmTessera} CopyBuyRealmTessera
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyBuyRealmTessera.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyBuyRealmTessera message.
         * @function verify
         * @memberof msgProto.CopyBuyRealmTessera
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyBuyRealmTessera.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CopyBuyRealmTessera;
    })();

    msgProto.CopyCopyWipe = (function() {

        /**
         * Properties of a CopyCopyWipe.
         * @memberof msgProto
         * @interface ICopyCopyWipe
         * @property {number|null} [copyId] CopyCopyWipe copyId
         */

        /**
         * Constructs a new CopyCopyWipe.
         * @memberof msgProto
         * @classdesc Represents a CopyCopyWipe.
         * @implements ICopyCopyWipe
         * @constructor
         * @param {msgProto.ICopyCopyWipe=} [properties] Properties to set
         */
        function CopyCopyWipe(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyCopyWipe copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyCopyWipe
         * @instance
         */
        CopyCopyWipe.prototype.copyId = 0;

        /**
         * Creates a new CopyCopyWipe instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {msgProto.ICopyCopyWipe=} [properties] Properties to set
         * @returns {msgProto.CopyCopyWipe} CopyCopyWipe instance
         */
        CopyCopyWipe.create = function create(properties) {
            return new CopyCopyWipe(properties);
        };

        /**
         * Encodes the specified CopyCopyWipe message. Does not implicitly {@link msgProto.CopyCopyWipe.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {msgProto.ICopyCopyWipe} message CopyCopyWipe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyCopyWipe.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Encodes the specified CopyCopyWipe message, length delimited. Does not implicitly {@link msgProto.CopyCopyWipe.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {msgProto.ICopyCopyWipe} message CopyCopyWipe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyCopyWipe.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyCopyWipe message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyCopyWipe} CopyCopyWipe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyCopyWipe.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyCopyWipe();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyCopyWipe message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyCopyWipe} CopyCopyWipe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyCopyWipe.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyCopyWipe message.
         * @function verify
         * @memberof msgProto.CopyCopyWipe
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyCopyWipe.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            return null;
        };

        return CopyCopyWipe;
    })();

    msgProto.Copy_start = (function() {

        /**
         * Properties of a Copy_start.
         * @memberof msgProto
         * @interface ICopy_start
         * @property {number|null} [copyId] Copy_start copyId
         * @property {string|null} [biCost] Copy_start biCost
         */

        /**
         * Constructs a new Copy_start.
         * @memberof msgProto
         * @classdesc Represents a Copy_start.
         * @implements ICopy_start
         * @constructor
         * @param {msgProto.ICopy_start=} [properties] Properties to set
         */
        function Copy_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Copy_start copyId.
         * @member {number} copyId
         * @memberof msgProto.Copy_start
         * @instance
         */
        Copy_start.prototype.copyId = 0;

        /**
         * Copy_start biCost.
         * @member {string} biCost
         * @memberof msgProto.Copy_start
         * @instance
         */
        Copy_start.prototype.biCost = "";

        /**
         * Creates a new Copy_start instance using the specified properties.
         * @function create
         * @memberof msgProto.Copy_start
         * @static
         * @param {msgProto.ICopy_start=} [properties] Properties to set
         * @returns {msgProto.Copy_start} Copy_start instance
         */
        Copy_start.create = function create(properties) {
            return new Copy_start(properties);
        };

        /**
         * Encodes the specified Copy_start message. Does not implicitly {@link msgProto.Copy_start.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Copy_start
         * @static
         * @param {msgProto.ICopy_start} message Copy_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Copy_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.biCost != null && message.hasOwnProperty("biCost"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.biCost);
            return writer;
        };

        /**
         * Encodes the specified Copy_start message, length delimited. Does not implicitly {@link msgProto.Copy_start.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.Copy_start
         * @static
         * @param {msgProto.ICopy_start} message Copy_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Copy_start.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Copy_start message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Copy_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Copy_start} Copy_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Copy_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Copy_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.biCost = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Copy_start message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.Copy_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.Copy_start} Copy_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Copy_start.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Copy_start message.
         * @function verify
         * @memberof msgProto.Copy_start
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Copy_start.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.biCost != null && message.hasOwnProperty("biCost"))
                if (!$util.isString(message.biCost))
                    return "biCost: string expected";
            return null;
        };

        return Copy_start;
    })();

    msgProto.CopyEnd = (function() {

        /**
         * Properties of a CopyEnd.
         * @memberof msgProto
         * @interface ICopyEnd
         * @property {number|null} [copyId] CopyEnd copyId
         * @property {string|null} [fightData] CopyEnd fightData
         * @property {boolean|null} [isWin] CopyEnd isWin
         */

        /**
         * Constructs a new CopyEnd.
         * @memberof msgProto
         * @classdesc Represents a CopyEnd.
         * @implements ICopyEnd
         * @constructor
         * @param {msgProto.ICopyEnd=} [properties] Properties to set
         */
        function CopyEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyEnd copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.copyId = 0;

        /**
         * CopyEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.fightData = "";

        /**
         * CopyEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CopyEnd
         * @instance
         */
        CopyEnd.prototype.isWin = false;

        /**
         * Creates a new CopyEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyEnd
         * @static
         * @param {msgProto.ICopyEnd=} [properties] Properties to set
         * @returns {msgProto.CopyEnd} CopyEnd instance
         */
        CopyEnd.create = function create(properties) {
            return new CopyEnd(properties);
        };

        /**
         * Encodes the specified CopyEnd message. Does not implicitly {@link msgProto.CopyEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyEnd
         * @static
         * @param {msgProto.ICopyEnd} message CopyEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fightData);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            return writer;
        };

        /**
         * Encodes the specified CopyEnd message, length delimited. Does not implicitly {@link msgProto.CopyEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyEnd
         * @static
         * @param {msgProto.ICopyEnd} message CopyEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyEnd} CopyEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.fightData = reader.string();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyEnd} CopyEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyEnd message.
         * @function verify
         * @memberof msgProto.CopyEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            return null;
        };

        return CopyEnd;
    })();

    msgProto.CopyUpdateWinningStreak = (function() {

        /**
         * Properties of a CopyUpdateWinningStreak.
         * @memberof msgProto
         * @interface ICopyUpdateWinningStreak
         * @property {number|null} [copyId] CopyUpdateWinningStreak copyId
         */

        /**
         * Constructs a new CopyUpdateWinningStreak.
         * @memberof msgProto
         * @classdesc Represents a CopyUpdateWinningStreak.
         * @implements ICopyUpdateWinningStreak
         * @constructor
         * @param {msgProto.ICopyUpdateWinningStreak=} [properties] Properties to set
         */
        function CopyUpdateWinningStreak(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyUpdateWinningStreak copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyUpdateWinningStreak
         * @instance
         */
        CopyUpdateWinningStreak.prototype.copyId = 0;

        /**
         * Creates a new CopyUpdateWinningStreak instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {msgProto.ICopyUpdateWinningStreak=} [properties] Properties to set
         * @returns {msgProto.CopyUpdateWinningStreak} CopyUpdateWinningStreak instance
         */
        CopyUpdateWinningStreak.create = function create(properties) {
            return new CopyUpdateWinningStreak(properties);
        };

        /**
         * Encodes the specified CopyUpdateWinningStreak message. Does not implicitly {@link msgProto.CopyUpdateWinningStreak.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {msgProto.ICopyUpdateWinningStreak} message CopyUpdateWinningStreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyUpdateWinningStreak.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Encodes the specified CopyUpdateWinningStreak message, length delimited. Does not implicitly {@link msgProto.CopyUpdateWinningStreak.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {msgProto.ICopyUpdateWinningStreak} message CopyUpdateWinningStreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyUpdateWinningStreak.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyUpdateWinningStreak message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyUpdateWinningStreak} CopyUpdateWinningStreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyUpdateWinningStreak.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyUpdateWinningStreak();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyUpdateWinningStreak message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyUpdateWinningStreak} CopyUpdateWinningStreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyUpdateWinningStreak.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyUpdateWinningStreak message.
         * @function verify
         * @memberof msgProto.CopyUpdateWinningStreak
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyUpdateWinningStreak.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            return null;
        };

        return CopyUpdateWinningStreak;
    })();

    msgProto.CopySetRead = (function() {

        /**
         * Properties of a CopySetRead.
         * @memberof msgProto
         * @interface ICopySetRead
         * @property {number|null} [copyId] CopySetRead copyId
         */

        /**
         * Constructs a new CopySetRead.
         * @memberof msgProto
         * @classdesc Represents a CopySetRead.
         * @implements ICopySetRead
         * @constructor
         * @param {msgProto.ICopySetRead=} [properties] Properties to set
         */
        function CopySetRead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopySetRead copyId.
         * @member {number} copyId
         * @memberof msgProto.CopySetRead
         * @instance
         */
        CopySetRead.prototype.copyId = 0;

        /**
         * Creates a new CopySetRead instance using the specified properties.
         * @function create
         * @memberof msgProto.CopySetRead
         * @static
         * @param {msgProto.ICopySetRead=} [properties] Properties to set
         * @returns {msgProto.CopySetRead} CopySetRead instance
         */
        CopySetRead.create = function create(properties) {
            return new CopySetRead(properties);
        };

        /**
         * Encodes the specified CopySetRead message. Does not implicitly {@link msgProto.CopySetRead.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopySetRead
         * @static
         * @param {msgProto.ICopySetRead} message CopySetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopySetRead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Encodes the specified CopySetRead message, length delimited. Does not implicitly {@link msgProto.CopySetRead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopySetRead
         * @static
         * @param {msgProto.ICopySetRead} message CopySetRead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopySetRead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopySetRead message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopySetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopySetRead} CopySetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopySetRead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopySetRead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopySetRead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopySetRead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopySetRead} CopySetRead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopySetRead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopySetRead message.
         * @function verify
         * @memberof msgProto.CopySetRead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopySetRead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            return null;
        };

        return CopySetRead;
    })();

    msgProto.CopyGuildStart = (function() {

        /**
         * Properties of a CopyGuildStart.
         * @memberof msgProto
         * @interface ICopyGuildStart
         * @property {number|null} [copyId] CopyGuildStart copyId
         * @property {number|null} [bossId] CopyGuildStart bossId
         */

        /**
         * Constructs a new CopyGuildStart.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildStart.
         * @implements ICopyGuildStart
         * @constructor
         * @param {msgProto.ICopyGuildStart=} [properties] Properties to set
         */
        function CopyGuildStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildStart copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyGuildStart
         * @instance
         */
        CopyGuildStart.prototype.copyId = 0;

        /**
         * CopyGuildStart bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyGuildStart
         * @instance
         */
        CopyGuildStart.prototype.bossId = 0;

        /**
         * Creates a new CopyGuildStart instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {msgProto.ICopyGuildStart=} [properties] Properties to set
         * @returns {msgProto.CopyGuildStart} CopyGuildStart instance
         */
        CopyGuildStart.create = function create(properties) {
            return new CopyGuildStart(properties);
        };

        /**
         * Encodes the specified CopyGuildStart message. Does not implicitly {@link msgProto.CopyGuildStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {msgProto.ICopyGuildStart} message CopyGuildStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified CopyGuildStart message, length delimited. Does not implicitly {@link msgProto.CopyGuildStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {msgProto.ICopyGuildStart} message CopyGuildStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyGuildStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildStart} CopyGuildStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyGuildStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyGuildStart} CopyGuildStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyGuildStart message.
         * @function verify
         * @memberof msgProto.CopyGuildStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyGuildStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return CopyGuildStart;
    })();

    msgProto.CopyGuildEnd = (function() {

        /**
         * Properties of a CopyGuildEnd.
         * @memberof msgProto
         * @interface ICopyGuildEnd
         * @property {number|null} [copyId] CopyGuildEnd copyId
         * @property {number|null} [bossId] CopyGuildEnd bossId
         * @property {boolean|null} [isWin] CopyGuildEnd isWin
         */

        /**
         * Constructs a new CopyGuildEnd.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildEnd.
         * @implements ICopyGuildEnd
         * @constructor
         * @param {msgProto.ICopyGuildEnd=} [properties] Properties to set
         */
        function CopyGuildEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildEnd copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.copyId = 0;

        /**
         * CopyGuildEnd bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.bossId = 0;

        /**
         * CopyGuildEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CopyGuildEnd
         * @instance
         */
        CopyGuildEnd.prototype.isWin = false;

        /**
         * Creates a new CopyGuildEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {msgProto.ICopyGuildEnd=} [properties] Properties to set
         * @returns {msgProto.CopyGuildEnd} CopyGuildEnd instance
         */
        CopyGuildEnd.create = function create(properties) {
            return new CopyGuildEnd(properties);
        };

        /**
         * Encodes the specified CopyGuildEnd message. Does not implicitly {@link msgProto.CopyGuildEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {msgProto.ICopyGuildEnd} message CopyGuildEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bossId);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            return writer;
        };

        /**
         * Encodes the specified CopyGuildEnd message, length delimited. Does not implicitly {@link msgProto.CopyGuildEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {msgProto.ICopyGuildEnd} message CopyGuildEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyGuildEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildEnd} CopyGuildEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                case 2:
                    message.bossId = reader.int32();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyGuildEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyGuildEnd} CopyGuildEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyGuildEnd message.
         * @function verify
         * @memberof msgProto.CopyGuildEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyGuildEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            return null;
        };

        return CopyGuildEnd;
    })();

    msgProto.CopyGuildCopyAward = (function() {

        /**
         * Properties of a CopyGuildCopyAward.
         * @memberof msgProto
         * @interface ICopyGuildCopyAward
         * @property {number|null} [type] CopyGuildCopyAward type
         * @property {number|null} [typeId] CopyGuildCopyAward typeId
         */

        /**
         * Constructs a new CopyGuildCopyAward.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildCopyAward.
         * @implements ICopyGuildCopyAward
         * @constructor
         * @param {msgProto.ICopyGuildCopyAward=} [properties] Properties to set
         */
        function CopyGuildCopyAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyGuildCopyAward type.
         * @member {number} type
         * @memberof msgProto.CopyGuildCopyAward
         * @instance
         */
        CopyGuildCopyAward.prototype.type = 0;

        /**
         * CopyGuildCopyAward typeId.
         * @member {number} typeId
         * @memberof msgProto.CopyGuildCopyAward
         * @instance
         */
        CopyGuildCopyAward.prototype.typeId = 0;

        /**
         * Creates a new CopyGuildCopyAward instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {msgProto.ICopyGuildCopyAward=} [properties] Properties to set
         * @returns {msgProto.CopyGuildCopyAward} CopyGuildCopyAward instance
         */
        CopyGuildCopyAward.create = function create(properties) {
            return new CopyGuildCopyAward(properties);
        };

        /**
         * Encodes the specified CopyGuildCopyAward message. Does not implicitly {@link msgProto.CopyGuildCopyAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {msgProto.ICopyGuildCopyAward} message CopyGuildCopyAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.typeId);
            return writer;
        };

        /**
         * Encodes the specified CopyGuildCopyAward message, length delimited. Does not implicitly {@link msgProto.CopyGuildCopyAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {msgProto.ICopyGuildCopyAward} message CopyGuildCopyAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyGuildCopyAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildCopyAward} CopyGuildCopyAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildCopyAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.typeId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyGuildCopyAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyGuildCopyAward} CopyGuildCopyAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyGuildCopyAward message.
         * @function verify
         * @memberof msgProto.CopyGuildCopyAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyGuildCopyAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.typeId != null && message.hasOwnProperty("typeId"))
                if (!$util.isInteger(message.typeId))
                    return "typeId: integer expected";
            return null;
        };

        return CopyGuildCopyAward;
    })();

    msgProto.CopyGuildCopyReset = (function() {

        /**
         * Properties of a CopyGuildCopyReset.
         * @memberof msgProto
         * @interface ICopyGuildCopyReset
         */

        /**
         * Constructs a new CopyGuildCopyReset.
         * @memberof msgProto
         * @classdesc Represents a CopyGuildCopyReset.
         * @implements ICopyGuildCopyReset
         * @constructor
         * @param {msgProto.ICopyGuildCopyReset=} [properties] Properties to set
         */
        function CopyGuildCopyReset(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CopyGuildCopyReset instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {msgProto.ICopyGuildCopyReset=} [properties] Properties to set
         * @returns {msgProto.CopyGuildCopyReset} CopyGuildCopyReset instance
         */
        CopyGuildCopyReset.create = function create(properties) {
            return new CopyGuildCopyReset(properties);
        };

        /**
         * Encodes the specified CopyGuildCopyReset message. Does not implicitly {@link msgProto.CopyGuildCopyReset.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {msgProto.ICopyGuildCopyReset} message CopyGuildCopyReset message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyReset.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CopyGuildCopyReset message, length delimited. Does not implicitly {@link msgProto.CopyGuildCopyReset.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {msgProto.ICopyGuildCopyReset} message CopyGuildCopyReset message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyGuildCopyReset.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyGuildCopyReset message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyGuildCopyReset} CopyGuildCopyReset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyReset.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyGuildCopyReset();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyGuildCopyReset message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyGuildCopyReset} CopyGuildCopyReset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyGuildCopyReset.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyGuildCopyReset message.
         * @function verify
         * @memberof msgProto.CopyGuildCopyReset
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyGuildCopyReset.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CopyGuildCopyReset;
    })();

    msgProto.CopyClearGuildCopy = (function() {

        /**
         * Properties of a CopyClearGuildCopy.
         * @memberof msgProto
         * @interface ICopyClearGuildCopy
         * @property {number|null} [bossId] CopyClearGuildCopy bossId
         */

        /**
         * Constructs a new CopyClearGuildCopy.
         * @memberof msgProto
         * @classdesc Represents a CopyClearGuildCopy.
         * @implements ICopyClearGuildCopy
         * @constructor
         * @param {msgProto.ICopyClearGuildCopy=} [properties] Properties to set
         */
        function CopyClearGuildCopy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyClearGuildCopy bossId.
         * @member {number} bossId
         * @memberof msgProto.CopyClearGuildCopy
         * @instance
         */
        CopyClearGuildCopy.prototype.bossId = 0;

        /**
         * Creates a new CopyClearGuildCopy instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {msgProto.ICopyClearGuildCopy=} [properties] Properties to set
         * @returns {msgProto.CopyClearGuildCopy} CopyClearGuildCopy instance
         */
        CopyClearGuildCopy.create = function create(properties) {
            return new CopyClearGuildCopy(properties);
        };

        /**
         * Encodes the specified CopyClearGuildCopy message. Does not implicitly {@link msgProto.CopyClearGuildCopy.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {msgProto.ICopyClearGuildCopy} message CopyClearGuildCopy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyClearGuildCopy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified CopyClearGuildCopy message, length delimited. Does not implicitly {@link msgProto.CopyClearGuildCopy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {msgProto.ICopyClearGuildCopy} message CopyClearGuildCopy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyClearGuildCopy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyClearGuildCopy message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyClearGuildCopy} CopyClearGuildCopy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyClearGuildCopy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyClearGuildCopy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyClearGuildCopy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyClearGuildCopy} CopyClearGuildCopy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyClearGuildCopy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyClearGuildCopy message.
         * @function verify
         * @memberof msgProto.CopyClearGuildCopy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyClearGuildCopy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return CopyClearGuildCopy;
    })();

    msgProto.CopyPaTaAward = (function() {

        /**
         * Properties of a CopyPaTaAward.
         * @memberof msgProto
         * @interface ICopyPaTaAward
         * @property {number|null} [copyId] CopyPaTaAward copyId
         */

        /**
         * Constructs a new CopyPaTaAward.
         * @memberof msgProto
         * @classdesc Represents a CopyPaTaAward.
         * @implements ICopyPaTaAward
         * @constructor
         * @param {msgProto.ICopyPaTaAward=} [properties] Properties to set
         */
        function CopyPaTaAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyPaTaAward copyId.
         * @member {number} copyId
         * @memberof msgProto.CopyPaTaAward
         * @instance
         */
        CopyPaTaAward.prototype.copyId = 0;

        /**
         * Creates a new CopyPaTaAward instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {msgProto.ICopyPaTaAward=} [properties] Properties to set
         * @returns {msgProto.CopyPaTaAward} CopyPaTaAward instance
         */
        CopyPaTaAward.create = function create(properties) {
            return new CopyPaTaAward(properties);
        };

        /**
         * Encodes the specified CopyPaTaAward message. Does not implicitly {@link msgProto.CopyPaTaAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {msgProto.ICopyPaTaAward} message CopyPaTaAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.copyId);
            return writer;
        };

        /**
         * Encodes the specified CopyPaTaAward message, length delimited. Does not implicitly {@link msgProto.CopyPaTaAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {msgProto.ICopyPaTaAward} message CopyPaTaAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyPaTaAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyPaTaAward} CopyPaTaAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyPaTaAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.copyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyPaTaAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyPaTaAward} CopyPaTaAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyPaTaAward message.
         * @function verify
         * @memberof msgProto.CopyPaTaAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyPaTaAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.copyId != null && message.hasOwnProperty("copyId"))
                if (!$util.isInteger(message.copyId))
                    return "copyId: integer expected";
            return null;
        };

        return CopyPaTaAward;
    })();

    msgProto.CopyPaTaTreasury = (function() {

        /**
         * Properties of a CopyPaTaTreasury.
         * @memberof msgProto
         * @interface ICopyPaTaTreasury
         */

        /**
         * Constructs a new CopyPaTaTreasury.
         * @memberof msgProto
         * @classdesc Represents a CopyPaTaTreasury.
         * @implements ICopyPaTaTreasury
         * @constructor
         * @param {msgProto.ICopyPaTaTreasury=} [properties] Properties to set
         */
        function CopyPaTaTreasury(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CopyPaTaTreasury instance using the specified properties.
         * @function create
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {msgProto.ICopyPaTaTreasury=} [properties] Properties to set
         * @returns {msgProto.CopyPaTaTreasury} CopyPaTaTreasury instance
         */
        CopyPaTaTreasury.create = function create(properties) {
            return new CopyPaTaTreasury(properties);
        };

        /**
         * Encodes the specified CopyPaTaTreasury message. Does not implicitly {@link msgProto.CopyPaTaTreasury.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {msgProto.ICopyPaTaTreasury} message CopyPaTaTreasury message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaTreasury.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CopyPaTaTreasury message, length delimited. Does not implicitly {@link msgProto.CopyPaTaTreasury.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {msgProto.ICopyPaTaTreasury} message CopyPaTaTreasury message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyPaTaTreasury.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyPaTaTreasury message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CopyPaTaTreasury} CopyPaTaTreasury
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaTreasury.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CopyPaTaTreasury();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyPaTaTreasury message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CopyPaTaTreasury} CopyPaTaTreasury
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyPaTaTreasury.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyPaTaTreasury message.
         * @function verify
         * @memberof msgProto.CopyPaTaTreasury
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyPaTaTreasury.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CopyPaTaTreasury;
    })();

    msgProto.ChallengeCupGetInfo = (function() {

        /**
         * Properties of a ChallengeCupGetInfo.
         * @memberof msgProto
         * @interface IChallengeCupGetInfo
         */

        /**
         * Constructs a new ChallengeCupGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetInfo.
         * @implements IChallengeCupGetInfo
         * @constructor
         * @param {msgProto.IChallengeCupGetInfo=} [properties] Properties to set
         */
        function ChallengeCupGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChallengeCupGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {msgProto.IChallengeCupGetInfo=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupGetInfo} ChallengeCupGetInfo instance
         */
        ChallengeCupGetInfo.create = function create(properties) {
            return new ChallengeCupGetInfo(properties);
        };

        /**
         * Encodes the specified ChallengeCupGetInfo message. Does not implicitly {@link msgProto.ChallengeCupGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {msgProto.IChallengeCupGetInfo} message ChallengeCupGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupGetInfo message, length delimited. Does not implicitly {@link msgProto.ChallengeCupGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {msgProto.IChallengeCupGetInfo} message ChallengeCupGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetInfo} ChallengeCupGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupGetInfo} ChallengeCupGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupGetInfo message.
         * @function verify
         * @memberof msgProto.ChallengeCupGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ChallengeCupGetInfo;
    })();

    msgProto.ChallengeCupStartFight = (function() {

        /**
         * Properties of a ChallengeCupStartFight.
         * @memberof msgProto
         * @interface IChallengeCupStartFight
         * @property {number|Long|null} [championUserId] ChallengeCupStartFight championUserId
         */

        /**
         * Constructs a new ChallengeCupStartFight.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupStartFight.
         * @implements IChallengeCupStartFight
         * @constructor
         * @param {msgProto.IChallengeCupStartFight=} [properties] Properties to set
         */
        function ChallengeCupStartFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupStartFight championUserId.
         * @member {number|Long} championUserId
         * @memberof msgProto.ChallengeCupStartFight
         * @instance
         */
        ChallengeCupStartFight.prototype.championUserId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChallengeCupStartFight instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {msgProto.IChallengeCupStartFight=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupStartFight} ChallengeCupStartFight instance
         */
        ChallengeCupStartFight.create = function create(properties) {
            return new ChallengeCupStartFight(properties);
        };

        /**
         * Encodes the specified ChallengeCupStartFight message. Does not implicitly {@link msgProto.ChallengeCupStartFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {msgProto.IChallengeCupStartFight} message ChallengeCupStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupStartFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.championUserId != null && message.hasOwnProperty("championUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.championUserId);
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupStartFight message, length delimited. Does not implicitly {@link msgProto.ChallengeCupStartFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {msgProto.IChallengeCupStartFight} message ChallengeCupStartFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupStartFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupStartFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupStartFight} ChallengeCupStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupStartFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupStartFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.championUserId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupStartFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupStartFight} ChallengeCupStartFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupStartFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupStartFight message.
         * @function verify
         * @memberof msgProto.ChallengeCupStartFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupStartFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.championUserId != null && message.hasOwnProperty("championUserId"))
                if (!$util.isInteger(message.championUserId) && !(message.championUserId && $util.isInteger(message.championUserId.low) && $util.isInteger(message.championUserId.high)))
                    return "championUserId: integer|Long expected";
            return null;
        };

        return ChallengeCupStartFight;
    })();

    msgProto.ChallengeCupEndFight = (function() {

        /**
         * Properties of a ChallengeCupEndFight.
         * @memberof msgProto
         * @interface IChallengeCupEndFight
         * @property {boolean|null} [isWin] ChallengeCupEndFight isWin
         */

        /**
         * Constructs a new ChallengeCupEndFight.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupEndFight.
         * @implements IChallengeCupEndFight
         * @constructor
         * @param {msgProto.IChallengeCupEndFight=} [properties] Properties to set
         */
        function ChallengeCupEndFight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupEndFight isWin.
         * @member {boolean} isWin
         * @memberof msgProto.ChallengeCupEndFight
         * @instance
         */
        ChallengeCupEndFight.prototype.isWin = false;

        /**
         * Creates a new ChallengeCupEndFight instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {msgProto.IChallengeCupEndFight=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupEndFight} ChallengeCupEndFight instance
         */
        ChallengeCupEndFight.create = function create(properties) {
            return new ChallengeCupEndFight(properties);
        };

        /**
         * Encodes the specified ChallengeCupEndFight message. Does not implicitly {@link msgProto.ChallengeCupEndFight.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {msgProto.IChallengeCupEndFight} message ChallengeCupEndFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupEndFight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupEndFight message, length delimited. Does not implicitly {@link msgProto.ChallengeCupEndFight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {msgProto.IChallengeCupEndFight} message ChallengeCupEndFight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupEndFight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupEndFight message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupEndFight} ChallengeCupEndFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupEndFight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupEndFight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupEndFight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupEndFight} ChallengeCupEndFight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupEndFight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupEndFight message.
         * @function verify
         * @memberof msgProto.ChallengeCupEndFight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupEndFight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            return null;
        };

        return ChallengeCupEndFight;
    })();

    msgProto.ChallengeCupClearCd = (function() {

        /**
         * Properties of a ChallengeCupClearCd.
         * @memberof msgProto
         * @interface IChallengeCupClearCd
         */

        /**
         * Constructs a new ChallengeCupClearCd.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupClearCd.
         * @implements IChallengeCupClearCd
         * @constructor
         * @param {msgProto.IChallengeCupClearCd=} [properties] Properties to set
         */
        function ChallengeCupClearCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChallengeCupClearCd instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {msgProto.IChallengeCupClearCd=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupClearCd} ChallengeCupClearCd instance
         */
        ChallengeCupClearCd.create = function create(properties) {
            return new ChallengeCupClearCd(properties);
        };

        /**
         * Encodes the specified ChallengeCupClearCd message. Does not implicitly {@link msgProto.ChallengeCupClearCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {msgProto.IChallengeCupClearCd} message ChallengeCupClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupClearCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupClearCd message, length delimited. Does not implicitly {@link msgProto.ChallengeCupClearCd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {msgProto.IChallengeCupClearCd} message ChallengeCupClearCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupClearCd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupClearCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupClearCd} ChallengeCupClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupClearCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupClearCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupClearCd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupClearCd} ChallengeCupClearCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupClearCd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupClearCd message.
         * @function verify
         * @memberof msgProto.ChallengeCupClearCd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupClearCd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ChallengeCupClearCd;
    })();

    msgProto.ChallengeCupToBeChampion = (function() {

        /**
         * Properties of a ChallengeCupToBeChampion.
         * @memberof msgProto
         * @interface IChallengeCupToBeChampion
         */

        /**
         * Constructs a new ChallengeCupToBeChampion.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupToBeChampion.
         * @implements IChallengeCupToBeChampion
         * @constructor
         * @param {msgProto.IChallengeCupToBeChampion=} [properties] Properties to set
         */
        function ChallengeCupToBeChampion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChallengeCupToBeChampion instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {msgProto.IChallengeCupToBeChampion=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupToBeChampion} ChallengeCupToBeChampion instance
         */
        ChallengeCupToBeChampion.create = function create(properties) {
            return new ChallengeCupToBeChampion(properties);
        };

        /**
         * Encodes the specified ChallengeCupToBeChampion message. Does not implicitly {@link msgProto.ChallengeCupToBeChampion.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {msgProto.IChallengeCupToBeChampion} message ChallengeCupToBeChampion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupToBeChampion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupToBeChampion message, length delimited. Does not implicitly {@link msgProto.ChallengeCupToBeChampion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {msgProto.IChallengeCupToBeChampion} message ChallengeCupToBeChampion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupToBeChampion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupToBeChampion message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupToBeChampion} ChallengeCupToBeChampion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupToBeChampion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupToBeChampion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupToBeChampion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupToBeChampion} ChallengeCupToBeChampion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupToBeChampion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupToBeChampion message.
         * @function verify
         * @memberof msgProto.ChallengeCupToBeChampion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupToBeChampion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ChallengeCupToBeChampion;
    })();

    msgProto.ChallengeCupGetDurationTimeRankList = (function() {

        /**
         * Properties of a ChallengeCupGetDurationTimeRankList.
         * @memberof msgProto
         * @interface IChallengeCupGetDurationTimeRankList
         */

        /**
         * Constructs a new ChallengeCupGetDurationTimeRankList.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetDurationTimeRankList.
         * @implements IChallengeCupGetDurationTimeRankList
         * @constructor
         * @param {msgProto.IChallengeCupGetDurationTimeRankList=} [properties] Properties to set
         */
        function ChallengeCupGetDurationTimeRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChallengeCupGetDurationTimeRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {msgProto.IChallengeCupGetDurationTimeRankList=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupGetDurationTimeRankList} ChallengeCupGetDurationTimeRankList instance
         */
        ChallengeCupGetDurationTimeRankList.create = function create(properties) {
            return new ChallengeCupGetDurationTimeRankList(properties);
        };

        /**
         * Encodes the specified ChallengeCupGetDurationTimeRankList message. Does not implicitly {@link msgProto.ChallengeCupGetDurationTimeRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {msgProto.IChallengeCupGetDurationTimeRankList} message ChallengeCupGetDurationTimeRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetDurationTimeRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupGetDurationTimeRankList message, length delimited. Does not implicitly {@link msgProto.ChallengeCupGetDurationTimeRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {msgProto.IChallengeCupGetDurationTimeRankList} message ChallengeCupGetDurationTimeRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetDurationTimeRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupGetDurationTimeRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetDurationTimeRankList} ChallengeCupGetDurationTimeRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetDurationTimeRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetDurationTimeRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupGetDurationTimeRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupGetDurationTimeRankList} ChallengeCupGetDurationTimeRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetDurationTimeRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupGetDurationTimeRankList message.
         * @function verify
         * @memberof msgProto.ChallengeCupGetDurationTimeRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupGetDurationTimeRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ChallengeCupGetDurationTimeRankList;
    })();

    msgProto.ChallengeCupGetIsOpen = (function() {

        /**
         * Properties of a ChallengeCupGetIsOpen.
         * @memberof msgProto
         * @interface IChallengeCupGetIsOpen
         */

        /**
         * Constructs a new ChallengeCupGetIsOpen.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupGetIsOpen.
         * @implements IChallengeCupGetIsOpen
         * @constructor
         * @param {msgProto.IChallengeCupGetIsOpen=} [properties] Properties to set
         */
        function ChallengeCupGetIsOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChallengeCupGetIsOpen instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {msgProto.IChallengeCupGetIsOpen=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupGetIsOpen} ChallengeCupGetIsOpen instance
         */
        ChallengeCupGetIsOpen.create = function create(properties) {
            return new ChallengeCupGetIsOpen(properties);
        };

        /**
         * Encodes the specified ChallengeCupGetIsOpen message. Does not implicitly {@link msgProto.ChallengeCupGetIsOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {msgProto.IChallengeCupGetIsOpen} message ChallengeCupGetIsOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetIsOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupGetIsOpen message, length delimited. Does not implicitly {@link msgProto.ChallengeCupGetIsOpen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {msgProto.IChallengeCupGetIsOpen} message ChallengeCupGetIsOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupGetIsOpen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupGetIsOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupGetIsOpen} ChallengeCupGetIsOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetIsOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupGetIsOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupGetIsOpen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupGetIsOpen} ChallengeCupGetIsOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupGetIsOpen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupGetIsOpen message.
         * @function verify
         * @memberof msgProto.ChallengeCupGetIsOpen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupGetIsOpen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ChallengeCupGetIsOpen;
    })();

    msgProto.ChallengeCupOp = (function() {

        /**
         * Properties of a ChallengeCupOp.
         * @memberof msgProto
         * @interface IChallengeCupOp
         * @property {number|null} [op] ChallengeCupOp op
         */

        /**
         * Constructs a new ChallengeCupOp.
         * @memberof msgProto
         * @classdesc Represents a ChallengeCupOp.
         * @implements IChallengeCupOp
         * @constructor
         * @param {msgProto.IChallengeCupOp=} [properties] Properties to set
         */
        function ChallengeCupOp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChallengeCupOp op.
         * @member {number} op
         * @memberof msgProto.ChallengeCupOp
         * @instance
         */
        ChallengeCupOp.prototype.op = 0;

        /**
         * Creates a new ChallengeCupOp instance using the specified properties.
         * @function create
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {msgProto.IChallengeCupOp=} [properties] Properties to set
         * @returns {msgProto.ChallengeCupOp} ChallengeCupOp instance
         */
        ChallengeCupOp.create = function create(properties) {
            return new ChallengeCupOp(properties);
        };

        /**
         * Encodes the specified ChallengeCupOp message. Does not implicitly {@link msgProto.ChallengeCupOp.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {msgProto.IChallengeCupOp} message ChallengeCupOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupOp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.op != null && message.hasOwnProperty("op"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.op);
            return writer;
        };

        /**
         * Encodes the specified ChallengeCupOp message, length delimited. Does not implicitly {@link msgProto.ChallengeCupOp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {msgProto.IChallengeCupOp} message ChallengeCupOp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChallengeCupOp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChallengeCupOp message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChallengeCupOp} ChallengeCupOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupOp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChallengeCupOp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChallengeCupOp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChallengeCupOp} ChallengeCupOp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChallengeCupOp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChallengeCupOp message.
         * @function verify
         * @memberof msgProto.ChallengeCupOp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChallengeCupOp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.op != null && message.hasOwnProperty("op"))
                if (!$util.isInteger(message.op))
                    return "op: integer expected";
            return null;
        };

        return ChallengeCupOp;
    })();

    msgProto.CrystalGetInfo = (function() {

        /**
         * Properties of a CrystalGetInfo.
         * @memberof msgProto
         * @interface ICrystalGetInfo
         */

        /**
         * Constructs a new CrystalGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CrystalGetInfo.
         * @implements ICrystalGetInfo
         * @constructor
         * @param {msgProto.ICrystalGetInfo=} [properties] Properties to set
         */
        function CrystalGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CrystalGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {msgProto.ICrystalGetInfo=} [properties] Properties to set
         * @returns {msgProto.CrystalGetInfo} CrystalGetInfo instance
         */
        CrystalGetInfo.create = function create(properties) {
            return new CrystalGetInfo(properties);
        };

        /**
         * Encodes the specified CrystalGetInfo message. Does not implicitly {@link msgProto.CrystalGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {msgProto.ICrystalGetInfo} message CrystalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CrystalGetInfo message, length delimited. Does not implicitly {@link msgProto.CrystalGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {msgProto.ICrystalGetInfo} message CrystalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalGetInfo} CrystalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalGetInfo} CrystalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalGetInfo message.
         * @function verify
         * @memberof msgProto.CrystalGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CrystalGetInfo;
    })();

    msgProto.CrystalSaveProgress = (function() {

        /**
         * Properties of a CrystalSaveProgress.
         * @memberof msgProto
         * @interface ICrystalSaveProgress
         * @property {number|null} [hp] CrystalSaveProgress hp
         * @property {number|null} [hpNum] CrystalSaveProgress hpNum
         * @property {number|null} [nextReplayTime] CrystalSaveProgress nextReplayTime
         */

        /**
         * Constructs a new CrystalSaveProgress.
         * @memberof msgProto
         * @classdesc Represents a CrystalSaveProgress.
         * @implements ICrystalSaveProgress
         * @constructor
         * @param {msgProto.ICrystalSaveProgress=} [properties] Properties to set
         */
        function CrystalSaveProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalSaveProgress hp.
         * @member {number} hp
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.hp = 0;

        /**
         * CrystalSaveProgress hpNum.
         * @member {number} hpNum
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.hpNum = 0;

        /**
         * CrystalSaveProgress nextReplayTime.
         * @member {number} nextReplayTime
         * @memberof msgProto.CrystalSaveProgress
         * @instance
         */
        CrystalSaveProgress.prototype.nextReplayTime = 0;

        /**
         * Creates a new CrystalSaveProgress instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {msgProto.ICrystalSaveProgress=} [properties] Properties to set
         * @returns {msgProto.CrystalSaveProgress} CrystalSaveProgress instance
         */
        CrystalSaveProgress.create = function create(properties) {
            return new CrystalSaveProgress(properties);
        };

        /**
         * Encodes the specified CrystalSaveProgress message. Does not implicitly {@link msgProto.CrystalSaveProgress.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {msgProto.ICrystalSaveProgress} message CrystalSaveProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalSaveProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hp != null && message.hasOwnProperty("hp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hp);
            if (message.hpNum != null && message.hasOwnProperty("hpNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hpNum);
            if (message.nextReplayTime != null && message.hasOwnProperty("nextReplayTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nextReplayTime);
            return writer;
        };

        /**
         * Encodes the specified CrystalSaveProgress message, length delimited. Does not implicitly {@link msgProto.CrystalSaveProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {msgProto.ICrystalSaveProgress} message CrystalSaveProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalSaveProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalSaveProgress message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalSaveProgress} CrystalSaveProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalSaveProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalSaveProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hp = reader.int32();
                    break;
                case 2:
                    message.hpNum = reader.int32();
                    break;
                case 3:
                    message.nextReplayTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalSaveProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalSaveProgress} CrystalSaveProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalSaveProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalSaveProgress message.
         * @function verify
         * @memberof msgProto.CrystalSaveProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalSaveProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.hpNum != null && message.hasOwnProperty("hpNum"))
                if (!$util.isInteger(message.hpNum))
                    return "hpNum: integer expected";
            if (message.nextReplayTime != null && message.hasOwnProperty("nextReplayTime"))
                if (!$util.isInteger(message.nextReplayTime))
                    return "nextReplayTime: integer expected";
            return null;
        };

        return CrystalSaveProgress;
    })();

    msgProto.CrystalFinish = (function() {

        /**
         * Properties of a CrystalFinish.
         * @memberof msgProto
         * @interface ICrystalFinish
         * @property {number|null} [crystalId] CrystalFinish crystalId
         */

        /**
         * Constructs a new CrystalFinish.
         * @memberof msgProto
         * @classdesc Represents a CrystalFinish.
         * @implements ICrystalFinish
         * @constructor
         * @param {msgProto.ICrystalFinish=} [properties] Properties to set
         */
        function CrystalFinish(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalFinish crystalId.
         * @member {number} crystalId
         * @memberof msgProto.CrystalFinish
         * @instance
         */
        CrystalFinish.prototype.crystalId = 0;

        /**
         * Creates a new CrystalFinish instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {msgProto.ICrystalFinish=} [properties] Properties to set
         * @returns {msgProto.CrystalFinish} CrystalFinish instance
         */
        CrystalFinish.create = function create(properties) {
            return new CrystalFinish(properties);
        };

        /**
         * Encodes the specified CrystalFinish message. Does not implicitly {@link msgProto.CrystalFinish.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {msgProto.ICrystalFinish} message CrystalFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalFinish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.crystalId);
            return writer;
        };

        /**
         * Encodes the specified CrystalFinish message, length delimited. Does not implicitly {@link msgProto.CrystalFinish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {msgProto.ICrystalFinish} message CrystalFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalFinish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalFinish message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalFinish} CrystalFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalFinish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalFinish();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.crystalId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalFinish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalFinish} CrystalFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalFinish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalFinish message.
         * @function verify
         * @memberof msgProto.CrystalFinish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalFinish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                if (!$util.isInteger(message.crystalId))
                    return "crystalId: integer expected";
            return null;
        };

        return CrystalFinish;
    })();

    msgProto.CrystalPickAward = (function() {

        /**
         * Properties of a CrystalPickAward.
         * @memberof msgProto
         * @interface ICrystalPickAward
         * @property {number|null} [crystalId] CrystalPickAward crystalId
         */

        /**
         * Constructs a new CrystalPickAward.
         * @memberof msgProto
         * @classdesc Represents a CrystalPickAward.
         * @implements ICrystalPickAward
         * @constructor
         * @param {msgProto.ICrystalPickAward=} [properties] Properties to set
         */
        function CrystalPickAward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalPickAward crystalId.
         * @member {number} crystalId
         * @memberof msgProto.CrystalPickAward
         * @instance
         */
        CrystalPickAward.prototype.crystalId = 0;

        /**
         * Creates a new CrystalPickAward instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {msgProto.ICrystalPickAward=} [properties] Properties to set
         * @returns {msgProto.CrystalPickAward} CrystalPickAward instance
         */
        CrystalPickAward.create = function create(properties) {
            return new CrystalPickAward(properties);
        };

        /**
         * Encodes the specified CrystalPickAward message. Does not implicitly {@link msgProto.CrystalPickAward.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {msgProto.ICrystalPickAward} message CrystalPickAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalPickAward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.crystalId);
            return writer;
        };

        /**
         * Encodes the specified CrystalPickAward message, length delimited. Does not implicitly {@link msgProto.CrystalPickAward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {msgProto.ICrystalPickAward} message CrystalPickAward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalPickAward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalPickAward message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalPickAward} CrystalPickAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalPickAward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalPickAward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.crystalId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalPickAward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalPickAward} CrystalPickAward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalPickAward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalPickAward message.
         * @function verify
         * @memberof msgProto.CrystalPickAward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalPickAward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.crystalId != null && message.hasOwnProperty("crystalId"))
                if (!$util.isInteger(message.crystalId))
                    return "crystalId: integer expected";
            return null;
        };

        return CrystalPickAward;
    })();

    msgProto.CrystalUseSkill = (function() {

        /**
         * Properties of a CrystalUseSkill.
         * @memberof msgProto
         * @interface ICrystalUseSkill
         * @property {number|null} [index] CrystalUseSkill index
         */

        /**
         * Constructs a new CrystalUseSkill.
         * @memberof msgProto
         * @classdesc Represents a CrystalUseSkill.
         * @implements ICrystalUseSkill
         * @constructor
         * @param {msgProto.ICrystalUseSkill=} [properties] Properties to set
         */
        function CrystalUseSkill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalUseSkill index.
         * @member {number} index
         * @memberof msgProto.CrystalUseSkill
         * @instance
         */
        CrystalUseSkill.prototype.index = 0;

        /**
         * Creates a new CrystalUseSkill instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {msgProto.ICrystalUseSkill=} [properties] Properties to set
         * @returns {msgProto.CrystalUseSkill} CrystalUseSkill instance
         */
        CrystalUseSkill.create = function create(properties) {
            return new CrystalUseSkill(properties);
        };

        /**
         * Encodes the specified CrystalUseSkill message. Does not implicitly {@link msgProto.CrystalUseSkill.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {msgProto.ICrystalUseSkill} message CrystalUseSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalUseSkill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified CrystalUseSkill message, length delimited. Does not implicitly {@link msgProto.CrystalUseSkill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {msgProto.ICrystalUseSkill} message CrystalUseSkill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalUseSkill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalUseSkill message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalUseSkill} CrystalUseSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalUseSkill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalUseSkill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalUseSkill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalUseSkill} CrystalUseSkill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalUseSkill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalUseSkill message.
         * @function verify
         * @memberof msgProto.CrystalUseSkill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalUseSkill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return CrystalUseSkill;
    })();

    msgProto.CrystalRefreshSkillCd = (function() {

        /**
         * Properties of a CrystalRefreshSkillCd.
         * @memberof msgProto
         * @interface ICrystalRefreshSkillCd
         * @property {number|null} [index] CrystalRefreshSkillCd index
         */

        /**
         * Constructs a new CrystalRefreshSkillCd.
         * @memberof msgProto
         * @classdesc Represents a CrystalRefreshSkillCd.
         * @implements ICrystalRefreshSkillCd
         * @constructor
         * @param {msgProto.ICrystalRefreshSkillCd=} [properties] Properties to set
         */
        function CrystalRefreshSkillCd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CrystalRefreshSkillCd index.
         * @member {number} index
         * @memberof msgProto.CrystalRefreshSkillCd
         * @instance
         */
        CrystalRefreshSkillCd.prototype.index = 0;

        /**
         * Creates a new CrystalRefreshSkillCd instance using the specified properties.
         * @function create
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {msgProto.ICrystalRefreshSkillCd=} [properties] Properties to set
         * @returns {msgProto.CrystalRefreshSkillCd} CrystalRefreshSkillCd instance
         */
        CrystalRefreshSkillCd.create = function create(properties) {
            return new CrystalRefreshSkillCd(properties);
        };

        /**
         * Encodes the specified CrystalRefreshSkillCd message. Does not implicitly {@link msgProto.CrystalRefreshSkillCd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {msgProto.ICrystalRefreshSkillCd} message CrystalRefreshSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalRefreshSkillCd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified CrystalRefreshSkillCd message, length delimited. Does not implicitly {@link msgProto.CrystalRefreshSkillCd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {msgProto.ICrystalRefreshSkillCd} message CrystalRefreshSkillCd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CrystalRefreshSkillCd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CrystalRefreshSkillCd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CrystalRefreshSkillCd} CrystalRefreshSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalRefreshSkillCd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CrystalRefreshSkillCd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CrystalRefreshSkillCd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CrystalRefreshSkillCd} CrystalRefreshSkillCd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CrystalRefreshSkillCd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CrystalRefreshSkillCd message.
         * @function verify
         * @memberof msgProto.CrystalRefreshSkillCd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CrystalRefreshSkillCd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return CrystalRefreshSkillCd;
    })();

    msgProto.RankGetRankList = (function() {

        /**
         * Properties of a RankGetRankList.
         * @memberof msgProto
         * @interface IRankGetRankList
         * @property {number|null} [rankType] RankGetRankList rankType
         */

        /**
         * Constructs a new RankGetRankList.
         * @memberof msgProto
         * @classdesc Represents a RankGetRankList.
         * @implements IRankGetRankList
         * @constructor
         * @param {msgProto.IRankGetRankList=} [properties] Properties to set
         */
        function RankGetRankList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetRankList rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetRankList
         * @instance
         */
        RankGetRankList.prototype.rankType = 0;

        /**
         * Creates a new RankGetRankList instance using the specified properties.
         * @function create
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {msgProto.IRankGetRankList=} [properties] Properties to set
         * @returns {msgProto.RankGetRankList} RankGetRankList instance
         */
        RankGetRankList.create = function create(properties) {
            return new RankGetRankList(properties);
        };

        /**
         * Encodes the specified RankGetRankList message. Does not implicitly {@link msgProto.RankGetRankList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {msgProto.IRankGetRankList} message RankGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Encodes the specified RankGetRankList message, length delimited. Does not implicitly {@link msgProto.RankGetRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {msgProto.IRankGetRankList} message RankGetRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankGetRankList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetRankList} RankGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankGetRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RankGetRankList} RankGetRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankGetRankList message.
         * @function verify
         * @memberof msgProto.RankGetRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankGetRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                if (!$util.isInteger(message.rankType))
                    return "rankType: integer expected";
            return null;
        };

        return RankGetRankList;
    })();

    msgProto.RankGetUserRank = (function() {

        /**
         * Properties of a RankGetUserRank.
         * @memberof msgProto
         * @interface IRankGetUserRank
         * @property {number|null} [rankType] RankGetUserRank rankType
         */

        /**
         * Constructs a new RankGetUserRank.
         * @memberof msgProto
         * @classdesc Represents a RankGetUserRank.
         * @implements IRankGetUserRank
         * @constructor
         * @param {msgProto.IRankGetUserRank=} [properties] Properties to set
         */
        function RankGetUserRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetUserRank rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetUserRank
         * @instance
         */
        RankGetUserRank.prototype.rankType = 0;

        /**
         * Creates a new RankGetUserRank instance using the specified properties.
         * @function create
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {msgProto.IRankGetUserRank=} [properties] Properties to set
         * @returns {msgProto.RankGetUserRank} RankGetUserRank instance
         */
        RankGetUserRank.create = function create(properties) {
            return new RankGetUserRank(properties);
        };

        /**
         * Encodes the specified RankGetUserRank message. Does not implicitly {@link msgProto.RankGetUserRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {msgProto.IRankGetUserRank} message RankGetUserRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetUserRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Encodes the specified RankGetUserRank message, length delimited. Does not implicitly {@link msgProto.RankGetUserRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {msgProto.IRankGetUserRank} message RankGetUserRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetUserRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankGetUserRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetUserRank} RankGetUserRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetUserRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetUserRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankGetUserRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RankGetUserRank} RankGetUserRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetUserRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankGetUserRank message.
         * @function verify
         * @memberof msgProto.RankGetUserRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankGetUserRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                if (!$util.isInteger(message.rankType))
                    return "rankType: integer expected";
            return null;
        };

        return RankGetUserRank;
    })();

    msgProto.RankAllRankArr = (function() {

        /**
         * Properties of a RankAllRankArr.
         * @memberof msgProto
         * @interface IRankAllRankArr
         * @property {number|null} [rankType] RankAllRankArr rankType
         */

        /**
         * Constructs a new RankAllRankArr.
         * @memberof msgProto
         * @classdesc Represents a RankAllRankArr.
         * @implements IRankAllRankArr
         * @constructor
         * @param {msgProto.IRankAllRankArr=} [properties] Properties to set
         */
        function RankAllRankArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankAllRankArr rankType.
         * @member {number} rankType
         * @memberof msgProto.RankAllRankArr
         * @instance
         */
        RankAllRankArr.prototype.rankType = 0;

        /**
         * Creates a new RankAllRankArr instance using the specified properties.
         * @function create
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {msgProto.IRankAllRankArr=} [properties] Properties to set
         * @returns {msgProto.RankAllRankArr} RankAllRankArr instance
         */
        RankAllRankArr.create = function create(properties) {
            return new RankAllRankArr(properties);
        };

        /**
         * Encodes the specified RankAllRankArr message. Does not implicitly {@link msgProto.RankAllRankArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {msgProto.IRankAllRankArr} message RankAllRankArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankAllRankArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Encodes the specified RankAllRankArr message, length delimited. Does not implicitly {@link msgProto.RankAllRankArr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {msgProto.IRankAllRankArr} message RankAllRankArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankAllRankArr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankAllRankArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankAllRankArr} RankAllRankArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankAllRankArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankAllRankArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankAllRankArr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RankAllRankArr} RankAllRankArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankAllRankArr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankAllRankArr message.
         * @function verify
         * @memberof msgProto.RankAllRankArr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankAllRankArr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                if (!$util.isInteger(message.rankType))
                    return "rankType: integer expected";
            return null;
        };

        return RankAllRankArr;
    })();

    msgProto.RankGetGuildRank = (function() {

        /**
         * Properties of a RankGetGuildRank.
         * @memberof msgProto
         * @interface IRankGetGuildRank
         * @property {number|null} [rankType] RankGetGuildRank rankType
         */

        /**
         * Constructs a new RankGetGuildRank.
         * @memberof msgProto
         * @classdesc Represents a RankGetGuildRank.
         * @implements IRankGetGuildRank
         * @constructor
         * @param {msgProto.IRankGetGuildRank=} [properties] Properties to set
         */
        function RankGetGuildRank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankGetGuildRank rankType.
         * @member {number} rankType
         * @memberof msgProto.RankGetGuildRank
         * @instance
         */
        RankGetGuildRank.prototype.rankType = 0;

        /**
         * Creates a new RankGetGuildRank instance using the specified properties.
         * @function create
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {msgProto.IRankGetGuildRank=} [properties] Properties to set
         * @returns {msgProto.RankGetGuildRank} RankGetGuildRank instance
         */
        RankGetGuildRank.create = function create(properties) {
            return new RankGetGuildRank(properties);
        };

        /**
         * Encodes the specified RankGetGuildRank message. Does not implicitly {@link msgProto.RankGetGuildRank.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {msgProto.IRankGetGuildRank} message RankGetGuildRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetGuildRank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            return writer;
        };

        /**
         * Encodes the specified RankGetGuildRank message, length delimited. Does not implicitly {@link msgProto.RankGetGuildRank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {msgProto.IRankGetGuildRank} message RankGetGuildRank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankGetGuildRank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankGetGuildRank message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RankGetGuildRank} RankGetGuildRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetGuildRank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RankGetGuildRank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankGetGuildRank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RankGetGuildRank} RankGetGuildRank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankGetGuildRank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankGetGuildRank message.
         * @function verify
         * @memberof msgProto.RankGetGuildRank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankGetGuildRank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                if (!$util.isInteger(message.rankType))
                    return "rankType: integer expected";
            return null;
        };

        return RankGetGuildRank;
    })();

    msgProto.RebirthRebirth = (function() {

        /**
         * Properties of a RebirthRebirth.
         * @memberof msgProto
         * @interface IRebirthRebirth
         */

        /**
         * Constructs a new RebirthRebirth.
         * @memberof msgProto
         * @classdesc Represents a RebirthRebirth.
         * @implements IRebirthRebirth
         * @constructor
         * @param {msgProto.IRebirthRebirth=} [properties] Properties to set
         */
        function RebirthRebirth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RebirthRebirth instance using the specified properties.
         * @function create
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {msgProto.IRebirthRebirth=} [properties] Properties to set
         * @returns {msgProto.RebirthRebirth} RebirthRebirth instance
         */
        RebirthRebirth.create = function create(properties) {
            return new RebirthRebirth(properties);
        };

        /**
         * Encodes the specified RebirthRebirth message. Does not implicitly {@link msgProto.RebirthRebirth.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {msgProto.IRebirthRebirth} message RebirthRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthRebirth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RebirthRebirth message, length delimited. Does not implicitly {@link msgProto.RebirthRebirth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {msgProto.IRebirthRebirth} message RebirthRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthRebirth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RebirthRebirth message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RebirthRebirth} RebirthRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthRebirth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RebirthRebirth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RebirthRebirth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RebirthRebirth} RebirthRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthRebirth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RebirthRebirth message.
         * @function verify
         * @memberof msgProto.RebirthRebirth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RebirthRebirth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RebirthRebirth;
    })();

    msgProto.RebirthBuyRebirth = (function() {

        /**
         * Properties of a RebirthBuyRebirth.
         * @memberof msgProto
         * @interface IRebirthBuyRebirth
         * @property {number|null} [index] RebirthBuyRebirth index
         * @property {number|null} [num] RebirthBuyRebirth num
         */

        /**
         * Constructs a new RebirthBuyRebirth.
         * @memberof msgProto
         * @classdesc Represents a RebirthBuyRebirth.
         * @implements IRebirthBuyRebirth
         * @constructor
         * @param {msgProto.IRebirthBuyRebirth=} [properties] Properties to set
         */
        function RebirthBuyRebirth(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RebirthBuyRebirth index.
         * @member {number} index
         * @memberof msgProto.RebirthBuyRebirth
         * @instance
         */
        RebirthBuyRebirth.prototype.index = 0;

        /**
         * RebirthBuyRebirth num.
         * @member {number} num
         * @memberof msgProto.RebirthBuyRebirth
         * @instance
         */
        RebirthBuyRebirth.prototype.num = 0;

        /**
         * Creates a new RebirthBuyRebirth instance using the specified properties.
         * @function create
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {msgProto.IRebirthBuyRebirth=} [properties] Properties to set
         * @returns {msgProto.RebirthBuyRebirth} RebirthBuyRebirth instance
         */
        RebirthBuyRebirth.create = function create(properties) {
            return new RebirthBuyRebirth(properties);
        };

        /**
         * Encodes the specified RebirthBuyRebirth message. Does not implicitly {@link msgProto.RebirthBuyRebirth.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {msgProto.IRebirthBuyRebirth} message RebirthBuyRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthBuyRebirth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.num != null && message.hasOwnProperty("num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };

        /**
         * Encodes the specified RebirthBuyRebirth message, length delimited. Does not implicitly {@link msgProto.RebirthBuyRebirth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {msgProto.IRebirthBuyRebirth} message RebirthBuyRebirth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebirthBuyRebirth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RebirthBuyRebirth message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RebirthBuyRebirth} RebirthBuyRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthBuyRebirth.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RebirthBuyRebirth();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RebirthBuyRebirth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RebirthBuyRebirth} RebirthBuyRebirth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebirthBuyRebirth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RebirthBuyRebirth message.
         * @function verify
         * @memberof msgProto.RebirthBuyRebirth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RebirthBuyRebirth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        return RebirthBuyRebirth;
    })();

    msgProto.RechargeGetInfo = (function() {

        /**
         * Properties of a RechargeGetInfo.
         * @memberof msgProto
         * @interface IRechargeGetInfo
         */

        /**
         * Constructs a new RechargeGetInfo.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetInfo.
         * @implements IRechargeGetInfo
         * @constructor
         * @param {msgProto.IRechargeGetInfo=} [properties] Properties to set
         */
        function RechargeGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RechargeGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {msgProto.IRechargeGetInfo=} [properties] Properties to set
         * @returns {msgProto.RechargeGetInfo} RechargeGetInfo instance
         */
        RechargeGetInfo.create = function create(properties) {
            return new RechargeGetInfo(properties);
        };

        /**
         * Encodes the specified RechargeGetInfo message. Does not implicitly {@link msgProto.RechargeGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {msgProto.IRechargeGetInfo} message RechargeGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RechargeGetInfo message, length delimited. Does not implicitly {@link msgProto.RechargeGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {msgProto.IRechargeGetInfo} message RechargeGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetInfo} RechargeGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeGetInfo} RechargeGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeGetInfo message.
         * @function verify
         * @memberof msgProto.RechargeGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RechargeGetInfo;
    })();

    msgProto.RechargeRecharge = (function() {

        /**
         * Properties of a RechargeRecharge.
         * @memberof msgProto
         * @interface IRechargeRecharge
         * @property {number|null} [rechargeId] RechargeRecharge rechargeId
         * @property {number|null} [channelId] RechargeRecharge channelId
         * @property {string|null} [receiptData] RechargeRecharge receiptData
         */

        /**
         * Constructs a new RechargeRecharge.
         * @memberof msgProto
         * @classdesc Represents a RechargeRecharge.
         * @implements IRechargeRecharge
         * @constructor
         * @param {msgProto.IRechargeRecharge=} [properties] Properties to set
         */
        function RechargeRecharge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeRecharge rechargeId.
         * @member {number} rechargeId
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.rechargeId = 0;

        /**
         * RechargeRecharge channelId.
         * @member {number} channelId
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.channelId = 0;

        /**
         * RechargeRecharge receiptData.
         * @member {string} receiptData
         * @memberof msgProto.RechargeRecharge
         * @instance
         */
        RechargeRecharge.prototype.receiptData = "";

        /**
         * Creates a new RechargeRecharge instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {msgProto.IRechargeRecharge=} [properties] Properties to set
         * @returns {msgProto.RechargeRecharge} RechargeRecharge instance
         */
        RechargeRecharge.create = function create(properties) {
            return new RechargeRecharge(properties);
        };

        /**
         * Encodes the specified RechargeRecharge message. Does not implicitly {@link msgProto.RechargeRecharge.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {msgProto.IRechargeRecharge} message RechargeRecharge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeRecharge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeId);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelId);
            if (message.receiptData != null && message.hasOwnProperty("receiptData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.receiptData);
            return writer;
        };

        /**
         * Encodes the specified RechargeRecharge message, length delimited. Does not implicitly {@link msgProto.RechargeRecharge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {msgProto.IRechargeRecharge} message RechargeRecharge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeRecharge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeRecharge message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeRecharge} RechargeRecharge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeRecharge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeRecharge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rechargeId = reader.int32();
                    break;
                case 2:
                    message.channelId = reader.int32();
                    break;
                case 3:
                    message.receiptData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeRecharge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeRecharge} RechargeRecharge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeRecharge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeRecharge message.
         * @function verify
         * @memberof msgProto.RechargeRecharge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeRecharge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                if (!$util.isInteger(message.rechargeId))
                    return "rechargeId: integer expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId))
                    return "channelId: integer expected";
            if (message.receiptData != null && message.hasOwnProperty("receiptData"))
                if (!$util.isString(message.receiptData))
                    return "receiptData: string expected";
            return null;
        };

        return RechargeRecharge;
    })();

    msgProto.RechargeGetTodayCount = (function() {

        /**
         * Properties of a RechargeGetTodayCount.
         * @memberof msgProto
         * @interface IRechargeGetTodayCount
         */

        /**
         * Constructs a new RechargeGetTodayCount.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetTodayCount.
         * @implements IRechargeGetTodayCount
         * @constructor
         * @param {msgProto.IRechargeGetTodayCount=} [properties] Properties to set
         */
        function RechargeGetTodayCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RechargeGetTodayCount instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {msgProto.IRechargeGetTodayCount=} [properties] Properties to set
         * @returns {msgProto.RechargeGetTodayCount} RechargeGetTodayCount instance
         */
        RechargeGetTodayCount.create = function create(properties) {
            return new RechargeGetTodayCount(properties);
        };

        /**
         * Encodes the specified RechargeGetTodayCount message. Does not implicitly {@link msgProto.RechargeGetTodayCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {msgProto.IRechargeGetTodayCount} message RechargeGetTodayCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetTodayCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RechargeGetTodayCount message, length delimited. Does not implicitly {@link msgProto.RechargeGetTodayCount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {msgProto.IRechargeGetTodayCount} message RechargeGetTodayCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetTodayCount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeGetTodayCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetTodayCount} RechargeGetTodayCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetTodayCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetTodayCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeGetTodayCount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeGetTodayCount} RechargeGetTodayCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetTodayCount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeGetTodayCount message.
         * @function verify
         * @memberof msgProto.RechargeGetTodayCount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeGetTodayCount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RechargeGetTodayCount;
    })();

    msgProto.RechargeGetAllCount = (function() {

        /**
         * Properties of a RechargeGetAllCount.
         * @memberof msgProto
         * @interface IRechargeGetAllCount
         */

        /**
         * Constructs a new RechargeGetAllCount.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetAllCount.
         * @implements IRechargeGetAllCount
         * @constructor
         * @param {msgProto.IRechargeGetAllCount=} [properties] Properties to set
         */
        function RechargeGetAllCount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RechargeGetAllCount instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {msgProto.IRechargeGetAllCount=} [properties] Properties to set
         * @returns {msgProto.RechargeGetAllCount} RechargeGetAllCount instance
         */
        RechargeGetAllCount.create = function create(properties) {
            return new RechargeGetAllCount(properties);
        };

        /**
         * Encodes the specified RechargeGetAllCount message. Does not implicitly {@link msgProto.RechargeGetAllCount.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {msgProto.IRechargeGetAllCount} message RechargeGetAllCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetAllCount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RechargeGetAllCount message, length delimited. Does not implicitly {@link msgProto.RechargeGetAllCount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {msgProto.IRechargeGetAllCount} message RechargeGetAllCount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetAllCount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeGetAllCount message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetAllCount} RechargeGetAllCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetAllCount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetAllCount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeGetAllCount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeGetAllCount} RechargeGetAllCount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetAllCount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeGetAllCount message.
         * @function verify
         * @memberof msgProto.RechargeGetAllCount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeGetAllCount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RechargeGetAllCount;
    })();

    msgProto.RechargeGetRequest = (function() {

        /**
         * Properties of a RechargeGetRequest.
         * @memberof msgProto
         * @interface IRechargeGetRequest
         * @property {number|null} [rechargeId] RechargeGetRequest rechargeId
         * @property {number|null} [goodsId] RechargeGetRequest goodsId
         */

        /**
         * Constructs a new RechargeGetRequest.
         * @memberof msgProto
         * @classdesc Represents a RechargeGetRequest.
         * @implements IRechargeGetRequest
         * @constructor
         * @param {msgProto.IRechargeGetRequest=} [properties] Properties to set
         */
        function RechargeGetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RechargeGetRequest rechargeId.
         * @member {number} rechargeId
         * @memberof msgProto.RechargeGetRequest
         * @instance
         */
        RechargeGetRequest.prototype.rechargeId = 0;

        /**
         * RechargeGetRequest goodsId.
         * @member {number} goodsId
         * @memberof msgProto.RechargeGetRequest
         * @instance
         */
        RechargeGetRequest.prototype.goodsId = 0;

        /**
         * Creates a new RechargeGetRequest instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {msgProto.IRechargeGetRequest=} [properties] Properties to set
         * @returns {msgProto.RechargeGetRequest} RechargeGetRequest instance
         */
        RechargeGetRequest.create = function create(properties) {
            return new RechargeGetRequest(properties);
        };

        /**
         * Encodes the specified RechargeGetRequest message. Does not implicitly {@link msgProto.RechargeGetRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {msgProto.IRechargeGetRequest} message RechargeGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeId);
            if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goodsId);
            return writer;
        };

        /**
         * Encodes the specified RechargeGetRequest message, length delimited. Does not implicitly {@link msgProto.RechargeGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {msgProto.IRechargeGetRequest} message RechargeGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeGetRequest} RechargeGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeGetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rechargeId = reader.int32();
                    break;
                case 2:
                    message.goodsId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeGetRequest} RechargeGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeGetRequest message.
         * @function verify
         * @memberof msgProto.RechargeGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rechargeId != null && message.hasOwnProperty("rechargeId"))
                if (!$util.isInteger(message.rechargeId))
                    return "rechargeId: integer expected";
            if (message.goodsId != null && message.hasOwnProperty("goodsId"))
                if (!$util.isInteger(message.goodsId))
                    return "goodsId: integer expected";
            return null;
        };

        return RechargeGetRequest;
    })();

    msgProto.RechargeHandleRequest = (function() {

        /**
         * Properties of a RechargeHandleRequest.
         * @memberof msgProto
         * @interface IRechargeHandleRequest
         */

        /**
         * Constructs a new RechargeHandleRequest.
         * @memberof msgProto
         * @classdesc Represents a RechargeHandleRequest.
         * @implements IRechargeHandleRequest
         * @constructor
         * @param {msgProto.IRechargeHandleRequest=} [properties] Properties to set
         */
        function RechargeHandleRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RechargeHandleRequest instance using the specified properties.
         * @function create
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {msgProto.IRechargeHandleRequest=} [properties] Properties to set
         * @returns {msgProto.RechargeHandleRequest} RechargeHandleRequest instance
         */
        RechargeHandleRequest.create = function create(properties) {
            return new RechargeHandleRequest(properties);
        };

        /**
         * Encodes the specified RechargeHandleRequest message. Does not implicitly {@link msgProto.RechargeHandleRequest.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {msgProto.IRechargeHandleRequest} message RechargeHandleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeHandleRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RechargeHandleRequest message, length delimited. Does not implicitly {@link msgProto.RechargeHandleRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {msgProto.IRechargeHandleRequest} message RechargeHandleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RechargeHandleRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RechargeHandleRequest message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RechargeHandleRequest} RechargeHandleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeHandleRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RechargeHandleRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RechargeHandleRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RechargeHandleRequest} RechargeHandleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RechargeHandleRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RechargeHandleRequest message.
         * @function verify
         * @memberof msgProto.RechargeHandleRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RechargeHandleRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RechargeHandleRequest;
    })();

    msgProto.RedEnvelopeGetList = (function() {

        /**
         * Properties of a RedEnvelopeGetList.
         * @memberof msgProto
         * @interface IRedEnvelopeGetList
         */

        /**
         * Constructs a new RedEnvelopeGetList.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeGetList.
         * @implements IRedEnvelopeGetList
         * @constructor
         * @param {msgProto.IRedEnvelopeGetList=} [properties] Properties to set
         */
        function RedEnvelopeGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RedEnvelopeGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {msgProto.IRedEnvelopeGetList=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopeGetList} RedEnvelopeGetList instance
         */
        RedEnvelopeGetList.create = function create(properties) {
            return new RedEnvelopeGetList(properties);
        };

        /**
         * Encodes the specified RedEnvelopeGetList message. Does not implicitly {@link msgProto.RedEnvelopeGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {msgProto.IRedEnvelopeGetList} message RedEnvelopeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopeGetList message, length delimited. Does not implicitly {@link msgProto.RedEnvelopeGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {msgProto.IRedEnvelopeGetList} message RedEnvelopeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopeGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeGetList} RedEnvelopeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopeGetList} RedEnvelopeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopeGetList message.
         * @function verify
         * @memberof msgProto.RedEnvelopeGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopeGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RedEnvelopeGetList;
    })();

    msgProto.RedEnvelopeSendRedEnvelope = (function() {

        /**
         * Properties of a RedEnvelopeSendRedEnvelope.
         * @memberof msgProto
         * @interface IRedEnvelopeSendRedEnvelope
         * @property {number|null} [type] RedEnvelopeSendRedEnvelope type
         * @property {number|null} [spItemId] RedEnvelopeSendRedEnvelope spItemId
         * @property {number|null} [amount] RedEnvelopeSendRedEnvelope amount
         * @property {number|null} [personNum] RedEnvelopeSendRedEnvelope personNum
         * @property {string|null} [wish] RedEnvelopeSendRedEnvelope wish
         */

        /**
         * Constructs a new RedEnvelopeSendRedEnvelope.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeSendRedEnvelope.
         * @implements IRedEnvelopeSendRedEnvelope
         * @constructor
         * @param {msgProto.IRedEnvelopeSendRedEnvelope=} [properties] Properties to set
         */
        function RedEnvelopeSendRedEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeSendRedEnvelope type.
         * @member {number} type
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.type = 0;

        /**
         * RedEnvelopeSendRedEnvelope spItemId.
         * @member {number} spItemId
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.spItemId = 0;

        /**
         * RedEnvelopeSendRedEnvelope amount.
         * @member {number} amount
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.amount = 0;

        /**
         * RedEnvelopeSendRedEnvelope personNum.
         * @member {number} personNum
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.personNum = 0;

        /**
         * RedEnvelopeSendRedEnvelope wish.
         * @member {string} wish
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @instance
         */
        RedEnvelopeSendRedEnvelope.prototype.wish = "";

        /**
         * Creates a new RedEnvelopeSendRedEnvelope instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSendRedEnvelope=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopeSendRedEnvelope} RedEnvelopeSendRedEnvelope instance
         */
        RedEnvelopeSendRedEnvelope.create = function create(properties) {
            return new RedEnvelopeSendRedEnvelope(properties);
        };

        /**
         * Encodes the specified RedEnvelopeSendRedEnvelope message. Does not implicitly {@link msgProto.RedEnvelopeSendRedEnvelope.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSendRedEnvelope} message RedEnvelopeSendRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSendRedEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.spItemId != null && message.hasOwnProperty("spItemId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.spItemId);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.amount);
            if (message.personNum != null && message.hasOwnProperty("personNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.personNum);
            if (message.wish != null && message.hasOwnProperty("wish"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.wish);
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopeSendRedEnvelope message, length delimited. Does not implicitly {@link msgProto.RedEnvelopeSendRedEnvelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSendRedEnvelope} message RedEnvelopeSendRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSendRedEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopeSendRedEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeSendRedEnvelope} RedEnvelopeSendRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSendRedEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeSendRedEnvelope();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.spItemId = reader.int32();
                    break;
                case 3:
                    message.amount = reader.int32();
                    break;
                case 4:
                    message.personNum = reader.int32();
                    break;
                case 5:
                    message.wish = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeSendRedEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopeSendRedEnvelope} RedEnvelopeSendRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSendRedEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopeSendRedEnvelope message.
         * @function verify
         * @memberof msgProto.RedEnvelopeSendRedEnvelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopeSendRedEnvelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.spItemId != null && message.hasOwnProperty("spItemId"))
                if (!$util.isInteger(message.spItemId))
                    return "spItemId: integer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.personNum != null && message.hasOwnProperty("personNum"))
                if (!$util.isInteger(message.personNum))
                    return "personNum: integer expected";
            if (message.wish != null && message.hasOwnProperty("wish"))
                if (!$util.isString(message.wish))
                    return "wish: string expected";
            return null;
        };

        return RedEnvelopeSendRedEnvelope;
    })();

    msgProto.RedEnvelopeSyncRedEnvelope = (function() {

        /**
         * Properties of a RedEnvelopeSyncRedEnvelope.
         * @memberof msgProto
         * @interface IRedEnvelopeSyncRedEnvelope
         */

        /**
         * Constructs a new RedEnvelopeSyncRedEnvelope.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeSyncRedEnvelope.
         * @implements IRedEnvelopeSyncRedEnvelope
         * @constructor
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope=} [properties] Properties to set
         */
        function RedEnvelopeSyncRedEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RedEnvelopeSyncRedEnvelope instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopeSyncRedEnvelope} RedEnvelopeSyncRedEnvelope instance
         */
        RedEnvelopeSyncRedEnvelope.create = function create(properties) {
            return new RedEnvelopeSyncRedEnvelope(properties);
        };

        /**
         * Encodes the specified RedEnvelopeSyncRedEnvelope message. Does not implicitly {@link msgProto.RedEnvelopeSyncRedEnvelope.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope} message RedEnvelopeSyncRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSyncRedEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopeSyncRedEnvelope message, length delimited. Does not implicitly {@link msgProto.RedEnvelopeSyncRedEnvelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {msgProto.IRedEnvelopeSyncRedEnvelope} message RedEnvelopeSyncRedEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeSyncRedEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopeSyncRedEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeSyncRedEnvelope} RedEnvelopeSyncRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSyncRedEnvelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeSyncRedEnvelope();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeSyncRedEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopeSyncRedEnvelope} RedEnvelopeSyncRedEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeSyncRedEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopeSyncRedEnvelope message.
         * @function verify
         * @memberof msgProto.RedEnvelopeSyncRedEnvelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopeSyncRedEnvelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RedEnvelopeSyncRedEnvelope;
    })();

    msgProto.RedEnvelopeGetNewList = (function() {

        /**
         * Properties of a RedEnvelopeGetNewList.
         * @memberof msgProto
         * @interface IRedEnvelopeGetNewList
         * @property {number|null} [lastId] RedEnvelopeGetNewList lastId
         */

        /**
         * Constructs a new RedEnvelopeGetNewList.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeGetNewList.
         * @implements IRedEnvelopeGetNewList
         * @constructor
         * @param {msgProto.IRedEnvelopeGetNewList=} [properties] Properties to set
         */
        function RedEnvelopeGetNewList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeGetNewList lastId.
         * @member {number} lastId
         * @memberof msgProto.RedEnvelopeGetNewList
         * @instance
         */
        RedEnvelopeGetNewList.prototype.lastId = 0;

        /**
         * Creates a new RedEnvelopeGetNewList instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {msgProto.IRedEnvelopeGetNewList=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopeGetNewList} RedEnvelopeGetNewList instance
         */
        RedEnvelopeGetNewList.create = function create(properties) {
            return new RedEnvelopeGetNewList(properties);
        };

        /**
         * Encodes the specified RedEnvelopeGetNewList message. Does not implicitly {@link msgProto.RedEnvelopeGetNewList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {msgProto.IRedEnvelopeGetNewList} message RedEnvelopeGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetNewList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopeGetNewList message, length delimited. Does not implicitly {@link msgProto.RedEnvelopeGetNewList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {msgProto.IRedEnvelopeGetNewList} message RedEnvelopeGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeGetNewList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopeGetNewList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeGetNewList} RedEnvelopeGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetNewList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeGetNewList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeGetNewList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopeGetNewList} RedEnvelopeGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeGetNewList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopeGetNewList message.
         * @function verify
         * @memberof msgProto.RedEnvelopeGetNewList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopeGetNewList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            return null;
        };

        return RedEnvelopeGetNewList;
    })();

    msgProto.RedEnvelopeReceiveBonus = (function() {

        /**
         * Properties of a RedEnvelopeReceiveBonus.
         * @memberof msgProto
         * @interface IRedEnvelopeReceiveBonus
         * @property {number|null} [redEnvelopeId] RedEnvelopeReceiveBonus redEnvelopeId
         */

        /**
         * Constructs a new RedEnvelopeReceiveBonus.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopeReceiveBonus.
         * @implements IRedEnvelopeReceiveBonus
         * @constructor
         * @param {msgProto.IRedEnvelopeReceiveBonus=} [properties] Properties to set
         */
        function RedEnvelopeReceiveBonus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedEnvelopeReceiveBonus redEnvelopeId.
         * @member {number} redEnvelopeId
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @instance
         */
        RedEnvelopeReceiveBonus.prototype.redEnvelopeId = 0;

        /**
         * Creates a new RedEnvelopeReceiveBonus instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {msgProto.IRedEnvelopeReceiveBonus=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopeReceiveBonus} RedEnvelopeReceiveBonus instance
         */
        RedEnvelopeReceiveBonus.create = function create(properties) {
            return new RedEnvelopeReceiveBonus(properties);
        };

        /**
         * Encodes the specified RedEnvelopeReceiveBonus message. Does not implicitly {@link msgProto.RedEnvelopeReceiveBonus.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {msgProto.IRedEnvelopeReceiveBonus} message RedEnvelopeReceiveBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeReceiveBonus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.redEnvelopeId != null && message.hasOwnProperty("redEnvelopeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.redEnvelopeId);
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopeReceiveBonus message, length delimited. Does not implicitly {@link msgProto.RedEnvelopeReceiveBonus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {msgProto.IRedEnvelopeReceiveBonus} message RedEnvelopeReceiveBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopeReceiveBonus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopeReceiveBonus message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopeReceiveBonus} RedEnvelopeReceiveBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeReceiveBonus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopeReceiveBonus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.redEnvelopeId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopeReceiveBonus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopeReceiveBonus} RedEnvelopeReceiveBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopeReceiveBonus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopeReceiveBonus message.
         * @function verify
         * @memberof msgProto.RedEnvelopeReceiveBonus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopeReceiveBonus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.redEnvelopeId != null && message.hasOwnProperty("redEnvelopeId"))
                if (!$util.isInteger(message.redEnvelopeId))
                    return "redEnvelopeId: integer expected";
            return null;
        };

        return RedEnvelopeReceiveBonus;
    })();

    msgProto.RedEnvelopePersonalGetInfo = (function() {

        /**
         * Properties of a RedEnvelopePersonalGetInfo.
         * @memberof msgProto
         * @interface IRedEnvelopePersonalGetInfo
         */

        /**
         * Constructs a new RedEnvelopePersonalGetInfo.
         * @memberof msgProto
         * @classdesc Represents a RedEnvelopePersonalGetInfo.
         * @implements IRedEnvelopePersonalGetInfo
         * @constructor
         * @param {msgProto.IRedEnvelopePersonalGetInfo=} [properties] Properties to set
         */
        function RedEnvelopePersonalGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RedEnvelopePersonalGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {msgProto.IRedEnvelopePersonalGetInfo=} [properties] Properties to set
         * @returns {msgProto.RedEnvelopePersonalGetInfo} RedEnvelopePersonalGetInfo instance
         */
        RedEnvelopePersonalGetInfo.create = function create(properties) {
            return new RedEnvelopePersonalGetInfo(properties);
        };

        /**
         * Encodes the specified RedEnvelopePersonalGetInfo message. Does not implicitly {@link msgProto.RedEnvelopePersonalGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {msgProto.IRedEnvelopePersonalGetInfo} message RedEnvelopePersonalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopePersonalGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RedEnvelopePersonalGetInfo message, length delimited. Does not implicitly {@link msgProto.RedEnvelopePersonalGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {msgProto.IRedEnvelopePersonalGetInfo} message RedEnvelopePersonalGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedEnvelopePersonalGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedEnvelopePersonalGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.RedEnvelopePersonalGetInfo} RedEnvelopePersonalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopePersonalGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.RedEnvelopePersonalGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedEnvelopePersonalGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.RedEnvelopePersonalGetInfo} RedEnvelopePersonalGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedEnvelopePersonalGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedEnvelopePersonalGetInfo message.
         * @function verify
         * @memberof msgProto.RedEnvelopePersonalGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedEnvelopePersonalGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return RedEnvelopePersonalGetInfo;
    })();

    msgProto.ChatGetNewList = (function() {

        /**
         * Properties of a ChatGetNewList.
         * @memberof msgProto
         * @interface IChatGetNewList
         * @property {number|null} [lastId] ChatGetNewList lastId
         * @property {number|null} [guildId] ChatGetNewList guildId
         * @property {number|null} [guildLastId] ChatGetNewList guildLastId
         */

        /**
         * Constructs a new ChatGetNewList.
         * @memberof msgProto
         * @classdesc Represents a ChatGetNewList.
         * @implements IChatGetNewList
         * @constructor
         * @param {msgProto.IChatGetNewList=} [properties] Properties to set
         */
        function ChatGetNewList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatGetNewList lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.lastId = 0;

        /**
         * ChatGetNewList guildId.
         * @member {number} guildId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.guildId = 0;

        /**
         * ChatGetNewList guildLastId.
         * @member {number} guildLastId
         * @memberof msgProto.ChatGetNewList
         * @instance
         */
        ChatGetNewList.prototype.guildLastId = 0;

        /**
         * Creates a new ChatGetNewList instance using the specified properties.
         * @function create
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {msgProto.IChatGetNewList=} [properties] Properties to set
         * @returns {msgProto.ChatGetNewList} ChatGetNewList instance
         */
        ChatGetNewList.create = function create(properties) {
            return new ChatGetNewList(properties);
        };

        /**
         * Encodes the specified ChatGetNewList message. Does not implicitly {@link msgProto.ChatGetNewList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {msgProto.IChatGetNewList} message ChatGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.guildId);
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.guildLastId);
            return writer;
        };

        /**
         * Encodes the specified ChatGetNewList message, length delimited. Does not implicitly {@link msgProto.ChatGetNewList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {msgProto.IChatGetNewList} message ChatGetNewList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatGetNewList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatGetNewList} ChatGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatGetNewList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.guildId = reader.int32();
                    break;
                case 3:
                    message.guildLastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatGetNewList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChatGetNewList} ChatGetNewList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatGetNewList message.
         * @function verify
         * @memberof msgProto.ChatGetNewList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatGetNewList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                if (!$util.isInteger(message.guildLastId))
                    return "guildLastId: integer expected";
            return null;
        };

        return ChatGetNewList;
    })();

    msgProto.ChatGetNewSysMsgList = (function() {

        /**
         * Properties of a ChatGetNewSysMsgList.
         * @memberof msgProto
         * @interface IChatGetNewSysMsgList
         * @property {number|null} [lastId] ChatGetNewSysMsgList lastId
         */

        /**
         * Constructs a new ChatGetNewSysMsgList.
         * @memberof msgProto
         * @classdesc Represents a ChatGetNewSysMsgList.
         * @implements IChatGetNewSysMsgList
         * @constructor
         * @param {msgProto.IChatGetNewSysMsgList=} [properties] Properties to set
         */
        function ChatGetNewSysMsgList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatGetNewSysMsgList lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatGetNewSysMsgList
         * @instance
         */
        ChatGetNewSysMsgList.prototype.lastId = 0;

        /**
         * Creates a new ChatGetNewSysMsgList instance using the specified properties.
         * @function create
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {msgProto.IChatGetNewSysMsgList=} [properties] Properties to set
         * @returns {msgProto.ChatGetNewSysMsgList} ChatGetNewSysMsgList instance
         */
        ChatGetNewSysMsgList.create = function create(properties) {
            return new ChatGetNewSysMsgList(properties);
        };

        /**
         * Encodes the specified ChatGetNewSysMsgList message. Does not implicitly {@link msgProto.ChatGetNewSysMsgList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {msgProto.IChatGetNewSysMsgList} message ChatGetNewSysMsgList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewSysMsgList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            return writer;
        };

        /**
         * Encodes the specified ChatGetNewSysMsgList message, length delimited. Does not implicitly {@link msgProto.ChatGetNewSysMsgList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {msgProto.IChatGetNewSysMsgList} message ChatGetNewSysMsgList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatGetNewSysMsgList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatGetNewSysMsgList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatGetNewSysMsgList} ChatGetNewSysMsgList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewSysMsgList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatGetNewSysMsgList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatGetNewSysMsgList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChatGetNewSysMsgList} ChatGetNewSysMsgList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatGetNewSysMsgList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatGetNewSysMsgList message.
         * @function verify
         * @memberof msgProto.ChatGetNewSysMsgList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatGetNewSysMsgList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            return null;
        };

        return ChatGetNewSysMsgList;
    })();

    msgProto.ChatSendData = (function() {

        /**
         * Properties of a ChatSendData.
         * @memberof msgProto
         * @interface IChatSendData
         * @property {string|null} [content] ChatSendData content
         * @property {number|null} [lastId] ChatSendData lastId
         * @property {number|null} [type] ChatSendData type
         * @property {number|null} [guildId] ChatSendData guildId
         * @property {number|null} [guildLastId] ChatSendData guildLastId
         * @property {boolean|null} [isLittleHorn] ChatSendData isLittleHorn
         */

        /**
         * Constructs a new ChatSendData.
         * @memberof msgProto
         * @classdesc Represents a ChatSendData.
         * @implements IChatSendData
         * @constructor
         * @param {msgProto.IChatSendData=} [properties] Properties to set
         */
        function ChatSendData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatSendData content.
         * @member {string} content
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.content = "";

        /**
         * ChatSendData lastId.
         * @member {number} lastId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.lastId = 0;

        /**
         * ChatSendData type.
         * @member {number} type
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.type = 0;

        /**
         * ChatSendData guildId.
         * @member {number} guildId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.guildId = 0;

        /**
         * ChatSendData guildLastId.
         * @member {number} guildLastId
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.guildLastId = 0;

        /**
         * ChatSendData isLittleHorn.
         * @member {boolean} isLittleHorn
         * @memberof msgProto.ChatSendData
         * @instance
         */
        ChatSendData.prototype.isLittleHorn = false;

        /**
         * Creates a new ChatSendData instance using the specified properties.
         * @function create
         * @memberof msgProto.ChatSendData
         * @static
         * @param {msgProto.IChatSendData=} [properties] Properties to set
         * @returns {msgProto.ChatSendData} ChatSendData instance
         */
        ChatSendData.create = function create(properties) {
            return new ChatSendData(properties);
        };

        /**
         * Encodes the specified ChatSendData message. Does not implicitly {@link msgProto.ChatSendData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ChatSendData
         * @static
         * @param {msgProto.IChatSendData} message ChatSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatSendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lastId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.guildId);
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.guildLastId);
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLittleHorn);
            return writer;
        };

        /**
         * Encodes the specified ChatSendData message, length delimited. Does not implicitly {@link msgProto.ChatSendData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ChatSendData
         * @static
         * @param {msgProto.IChatSendData} message ChatSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatSendData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatSendData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ChatSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ChatSendData} ChatSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatSendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ChatSendData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.lastId = reader.int32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.guildId = reader.int32();
                    break;
                case 5:
                    message.guildLastId = reader.int32();
                    break;
                case 6:
                    message.isLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatSendData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ChatSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ChatSendData} ChatSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatSendData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatSendData message.
         * @function verify
         * @memberof msgProto.ChatSendData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatSendData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            if (message.guildLastId != null && message.hasOwnProperty("guildLastId"))
                if (!$util.isInteger(message.guildLastId))
                    return "guildLastId: integer expected";
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                if (typeof message.isLittleHorn !== "boolean")
                    return "isLittleHorn: boolean expected";
            return null;
        };

        return ChatSendData;
    })();

    msgProto.CouponUse = (function() {

        /**
         * Properties of a CouponUse.
         * @memberof msgProto
         * @interface ICouponUse
         * @property {string|null} [code] CouponUse code
         */

        /**
         * Constructs a new CouponUse.
         * @memberof msgProto
         * @classdesc Represents a CouponUse.
         * @implements ICouponUse
         * @constructor
         * @param {msgProto.ICouponUse=} [properties] Properties to set
         */
        function CouponUse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CouponUse code.
         * @member {string} code
         * @memberof msgProto.CouponUse
         * @instance
         */
        CouponUse.prototype.code = "";

        /**
         * Creates a new CouponUse instance using the specified properties.
         * @function create
         * @memberof msgProto.CouponUse
         * @static
         * @param {msgProto.ICouponUse=} [properties] Properties to set
         * @returns {msgProto.CouponUse} CouponUse instance
         */
        CouponUse.create = function create(properties) {
            return new CouponUse(properties);
        };

        /**
         * Encodes the specified CouponUse message. Does not implicitly {@link msgProto.CouponUse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CouponUse
         * @static
         * @param {msgProto.ICouponUse} message CouponUse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CouponUse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified CouponUse message, length delimited. Does not implicitly {@link msgProto.CouponUse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CouponUse
         * @static
         * @param {msgProto.ICouponUse} message CouponUse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CouponUse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CouponUse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CouponUse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CouponUse} CouponUse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CouponUse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CouponUse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CouponUse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CouponUse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CouponUse} CouponUse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CouponUse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CouponUse message.
         * @function verify
         * @memberof msgProto.CouponUse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CouponUse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            return null;
        };

        return CouponUse;
    })();

    msgProto.CoffersGetInfo = (function() {

        /**
         * Properties of a CoffersGetInfo.
         * @memberof msgProto
         * @interface ICoffersGetInfo
         */

        /**
         * Constructs a new CoffersGetInfo.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetInfo.
         * @implements ICoffersGetInfo
         * @constructor
         * @param {msgProto.ICoffersGetInfo=} [properties] Properties to set
         */
        function CoffersGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {msgProto.ICoffersGetInfo=} [properties] Properties to set
         * @returns {msgProto.CoffersGetInfo} CoffersGetInfo instance
         */
        CoffersGetInfo.create = function create(properties) {
            return new CoffersGetInfo(properties);
        };

        /**
         * Encodes the specified CoffersGetInfo message. Does not implicitly {@link msgProto.CoffersGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {msgProto.ICoffersGetInfo} message CoffersGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersGetInfo message, length delimited. Does not implicitly {@link msgProto.CoffersGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {msgProto.ICoffersGetInfo} message CoffersGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetInfo} CoffersGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetInfo} CoffersGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetInfo message.
         * @function verify
         * @memberof msgProto.CoffersGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersGetInfo;
    })();

    msgProto.CoffersBuild = (function() {

        /**
         * Properties of a CoffersBuild.
         * @memberof msgProto
         * @interface ICoffersBuild
         */

        /**
         * Constructs a new CoffersBuild.
         * @memberof msgProto
         * @classdesc Represents a CoffersBuild.
         * @implements ICoffersBuild
         * @constructor
         * @param {msgProto.ICoffersBuild=} [properties] Properties to set
         */
        function CoffersBuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersBuild instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {msgProto.ICoffersBuild=} [properties] Properties to set
         * @returns {msgProto.CoffersBuild} CoffersBuild instance
         */
        CoffersBuild.create = function create(properties) {
            return new CoffersBuild(properties);
        };

        /**
         * Encodes the specified CoffersBuild message. Does not implicitly {@link msgProto.CoffersBuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {msgProto.ICoffersBuild} message CoffersBuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersBuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersBuild message, length delimited. Does not implicitly {@link msgProto.CoffersBuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {msgProto.ICoffersBuild} message CoffersBuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersBuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersBuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersBuild} CoffersBuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersBuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersBuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersBuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersBuild} CoffersBuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersBuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersBuild message.
         * @function verify
         * @memberof msgProto.CoffersBuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersBuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersBuild;
    })();

    msgProto.CoffersAddBuff = (function() {

        /**
         * Properties of a CoffersAddBuff.
         * @memberof msgProto
         * @interface ICoffersAddBuff
         */

        /**
         * Constructs a new CoffersAddBuff.
         * @memberof msgProto
         * @classdesc Represents a CoffersAddBuff.
         * @implements ICoffersAddBuff
         * @constructor
         * @param {msgProto.ICoffersAddBuff=} [properties] Properties to set
         */
        function CoffersAddBuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersAddBuff instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {msgProto.ICoffersAddBuff=} [properties] Properties to set
         * @returns {msgProto.CoffersAddBuff} CoffersAddBuff instance
         */
        CoffersAddBuff.create = function create(properties) {
            return new CoffersAddBuff(properties);
        };

        /**
         * Encodes the specified CoffersAddBuff message. Does not implicitly {@link msgProto.CoffersAddBuff.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {msgProto.ICoffersAddBuff} message CoffersAddBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersAddBuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersAddBuff message, length delimited. Does not implicitly {@link msgProto.CoffersAddBuff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {msgProto.ICoffersAddBuff} message CoffersAddBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersAddBuff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersAddBuff message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersAddBuff} CoffersAddBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersAddBuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersAddBuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersAddBuff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersAddBuff} CoffersAddBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersAddBuff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersAddBuff message.
         * @function verify
         * @memberof msgProto.CoffersAddBuff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersAddBuff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersAddBuff;
    })();

    msgProto.CoffersGetLootRecordArr = (function() {

        /**
         * Properties of a CoffersGetLootRecordArr.
         * @memberof msgProto
         * @interface ICoffersGetLootRecordArr
         */

        /**
         * Constructs a new CoffersGetLootRecordArr.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetLootRecordArr.
         * @implements ICoffersGetLootRecordArr
         * @constructor
         * @param {msgProto.ICoffersGetLootRecordArr=} [properties] Properties to set
         */
        function CoffersGetLootRecordArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersGetLootRecordArr instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {msgProto.ICoffersGetLootRecordArr=} [properties] Properties to set
         * @returns {msgProto.CoffersGetLootRecordArr} CoffersGetLootRecordArr instance
         */
        CoffersGetLootRecordArr.create = function create(properties) {
            return new CoffersGetLootRecordArr(properties);
        };

        /**
         * Encodes the specified CoffersGetLootRecordArr message. Does not implicitly {@link msgProto.CoffersGetLootRecordArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {msgProto.ICoffersGetLootRecordArr} message CoffersGetLootRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetLootRecordArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersGetLootRecordArr message, length delimited. Does not implicitly {@link msgProto.CoffersGetLootRecordArr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {msgProto.ICoffersGetLootRecordArr} message CoffersGetLootRecordArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetLootRecordArr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetLootRecordArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetLootRecordArr} CoffersGetLootRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetLootRecordArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetLootRecordArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetLootRecordArr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetLootRecordArr} CoffersGetLootRecordArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetLootRecordArr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetLootRecordArr message.
         * @function verify
         * @memberof msgProto.CoffersGetLootRecordArr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetLootRecordArr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersGetLootRecordArr;
    })();

    msgProto.CoffersGetDefeseRecord = (function() {

        /**
         * Properties of a CoffersGetDefeseRecord.
         * @memberof msgProto
         * @interface ICoffersGetDefeseRecord
         */

        /**
         * Constructs a new CoffersGetDefeseRecord.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetDefeseRecord.
         * @implements ICoffersGetDefeseRecord
         * @constructor
         * @param {msgProto.ICoffersGetDefeseRecord=} [properties] Properties to set
         */
        function CoffersGetDefeseRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersGetDefeseRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {msgProto.ICoffersGetDefeseRecord=} [properties] Properties to set
         * @returns {msgProto.CoffersGetDefeseRecord} CoffersGetDefeseRecord instance
         */
        CoffersGetDefeseRecord.create = function create(properties) {
            return new CoffersGetDefeseRecord(properties);
        };

        /**
         * Encodes the specified CoffersGetDefeseRecord message. Does not implicitly {@link msgProto.CoffersGetDefeseRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {msgProto.ICoffersGetDefeseRecord} message CoffersGetDefeseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersGetDefeseRecord message, length delimited. Does not implicitly {@link msgProto.CoffersGetDefeseRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {msgProto.ICoffersGetDefeseRecord} message CoffersGetDefeseRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetDefeseRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetDefeseRecord} CoffersGetDefeseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetDefeseRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetDefeseRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetDefeseRecord} CoffersGetDefeseRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetDefeseRecord message.
         * @function verify
         * @memberof msgProto.CoffersGetDefeseRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetDefeseRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersGetDefeseRecord;
    })();

    msgProto.CoffersGetDefeseData = (function() {

        /**
         * Properties of a CoffersGetDefeseData.
         * @memberof msgProto
         * @interface ICoffersGetDefeseData
         */

        /**
         * Constructs a new CoffersGetDefeseData.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetDefeseData.
         * @implements ICoffersGetDefeseData
         * @constructor
         * @param {msgProto.ICoffersGetDefeseData=} [properties] Properties to set
         */
        function CoffersGetDefeseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersGetDefeseData instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {msgProto.ICoffersGetDefeseData=} [properties] Properties to set
         * @returns {msgProto.CoffersGetDefeseData} CoffersGetDefeseData instance
         */
        CoffersGetDefeseData.create = function create(properties) {
            return new CoffersGetDefeseData(properties);
        };

        /**
         * Encodes the specified CoffersGetDefeseData message. Does not implicitly {@link msgProto.CoffersGetDefeseData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {msgProto.ICoffersGetDefeseData} message CoffersGetDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersGetDefeseData message, length delimited. Does not implicitly {@link msgProto.CoffersGetDefeseData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {msgProto.ICoffersGetDefeseData} message CoffersGetDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetDefeseData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetDefeseData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetDefeseData} CoffersGetDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetDefeseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetDefeseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetDefeseData} CoffersGetDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetDefeseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetDefeseData message.
         * @function verify
         * @memberof msgProto.CoffersGetDefeseData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetDefeseData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersGetDefeseData;
    })();

    msgProto.CoffersGetEnemyDefeseData = (function() {

        /**
         * Properties of a CoffersGetEnemyDefeseData.
         * @memberof msgProto
         * @interface ICoffersGetEnemyDefeseData
         * @property {number|null} [serverId] CoffersGetEnemyDefeseData serverId
         */

        /**
         * Constructs a new CoffersGetEnemyDefeseData.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetEnemyDefeseData.
         * @implements ICoffersGetEnemyDefeseData
         * @constructor
         * @param {msgProto.ICoffersGetEnemyDefeseData=} [properties] Properties to set
         */
        function CoffersGetEnemyDefeseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersGetEnemyDefeseData serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @instance
         */
        CoffersGetEnemyDefeseData.prototype.serverId = 0;

        /**
         * Creates a new CoffersGetEnemyDefeseData instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {msgProto.ICoffersGetEnemyDefeseData=} [properties] Properties to set
         * @returns {msgProto.CoffersGetEnemyDefeseData} CoffersGetEnemyDefeseData instance
         */
        CoffersGetEnemyDefeseData.create = function create(properties) {
            return new CoffersGetEnemyDefeseData(properties);
        };

        /**
         * Encodes the specified CoffersGetEnemyDefeseData message. Does not implicitly {@link msgProto.CoffersGetEnemyDefeseData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {msgProto.ICoffersGetEnemyDefeseData} message CoffersGetEnemyDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetEnemyDefeseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            return writer;
        };

        /**
         * Encodes the specified CoffersGetEnemyDefeseData message, length delimited. Does not implicitly {@link msgProto.CoffersGetEnemyDefeseData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {msgProto.ICoffersGetEnemyDefeseData} message CoffersGetEnemyDefeseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetEnemyDefeseData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetEnemyDefeseData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetEnemyDefeseData} CoffersGetEnemyDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetEnemyDefeseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetEnemyDefeseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetEnemyDefeseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetEnemyDefeseData} CoffersGetEnemyDefeseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetEnemyDefeseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetEnemyDefeseData message.
         * @function verify
         * @memberof msgProto.CoffersGetEnemyDefeseData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetEnemyDefeseData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            return null;
        };

        return CoffersGetEnemyDefeseData;
    })();

    msgProto.CoffersGetServerArr = (function() {

        /**
         * Properties of a CoffersGetServerArr.
         * @memberof msgProto
         * @interface ICoffersGetServerArr
         */

        /**
         * Constructs a new CoffersGetServerArr.
         * @memberof msgProto
         * @classdesc Represents a CoffersGetServerArr.
         * @implements ICoffersGetServerArr
         * @constructor
         * @param {msgProto.ICoffersGetServerArr=} [properties] Properties to set
         */
        function CoffersGetServerArr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CoffersGetServerArr instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {msgProto.ICoffersGetServerArr=} [properties] Properties to set
         * @returns {msgProto.CoffersGetServerArr} CoffersGetServerArr instance
         */
        CoffersGetServerArr.create = function create(properties) {
            return new CoffersGetServerArr(properties);
        };

        /**
         * Encodes the specified CoffersGetServerArr message. Does not implicitly {@link msgProto.CoffersGetServerArr.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {msgProto.ICoffersGetServerArr} message CoffersGetServerArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetServerArr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CoffersGetServerArr message, length delimited. Does not implicitly {@link msgProto.CoffersGetServerArr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {msgProto.ICoffersGetServerArr} message CoffersGetServerArr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersGetServerArr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersGetServerArr message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersGetServerArr} CoffersGetServerArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetServerArr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersGetServerArr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersGetServerArr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersGetServerArr} CoffersGetServerArr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersGetServerArr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersGetServerArr message.
         * @function verify
         * @memberof msgProto.CoffersGetServerArr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersGetServerArr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CoffersGetServerArr;
    })();

    msgProto.CoffersFightStart = (function() {

        /**
         * Properties of a CoffersFightStart.
         * @memberof msgProto
         * @interface ICoffersFightStart
         * @property {number|null} [serverId] CoffersFightStart serverId
         * @property {number|null} [door] CoffersFightStart door
         */

        /**
         * Constructs a new CoffersFightStart.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightStart.
         * @implements ICoffersFightStart
         * @constructor
         * @param {msgProto.ICoffersFightStart=} [properties] Properties to set
         */
        function CoffersFightStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightStart serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightStart
         * @instance
         */
        CoffersFightStart.prototype.serverId = 0;

        /**
         * CoffersFightStart door.
         * @member {number} door
         * @memberof msgProto.CoffersFightStart
         * @instance
         */
        CoffersFightStart.prototype.door = 0;

        /**
         * Creates a new CoffersFightStart instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {msgProto.ICoffersFightStart=} [properties] Properties to set
         * @returns {msgProto.CoffersFightStart} CoffersFightStart instance
         */
        CoffersFightStart.create = function create(properties) {
            return new CoffersFightStart(properties);
        };

        /**
         * Encodes the specified CoffersFightStart message. Does not implicitly {@link msgProto.CoffersFightStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {msgProto.ICoffersFightStart} message CoffersFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            return writer;
        };

        /**
         * Encodes the specified CoffersFightStart message, length delimited. Does not implicitly {@link msgProto.CoffersFightStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {msgProto.ICoffersFightStart} message CoffersFightStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersFightStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightStart} CoffersFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersFightStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersFightStart} CoffersFightStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersFightStart message.
         * @function verify
         * @memberof msgProto.CoffersFightStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersFightStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            return null;
        };

        return CoffersFightStart;
    })();

    msgProto.CoffersFightEnd = (function() {

        /**
         * Properties of a CoffersFightEnd.
         * @memberof msgProto
         * @interface ICoffersFightEnd
         * @property {number|null} [serverId] CoffersFightEnd serverId
         * @property {number|null} [door] CoffersFightEnd door
         * @property {boolean|null} [isWin] CoffersFightEnd isWin
         * @property {string|null} [fightData] CoffersFightEnd fightData
         */

        /**
         * Constructs a new CoffersFightEnd.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightEnd.
         * @implements ICoffersFightEnd
         * @constructor
         * @param {msgProto.ICoffersFightEnd=} [properties] Properties to set
         */
        function CoffersFightEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightEnd serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.serverId = 0;

        /**
         * CoffersFightEnd door.
         * @member {number} door
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.door = 0;

        /**
         * CoffersFightEnd isWin.
         * @member {boolean} isWin
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.isWin = false;

        /**
         * CoffersFightEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CoffersFightEnd
         * @instance
         */
        CoffersFightEnd.prototype.fightData = "";

        /**
         * Creates a new CoffersFightEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {msgProto.ICoffersFightEnd=} [properties] Properties to set
         * @returns {msgProto.CoffersFightEnd} CoffersFightEnd instance
         */
        CoffersFightEnd.create = function create(properties) {
            return new CoffersFightEnd(properties);
        };

        /**
         * Encodes the specified CoffersFightEnd message. Does not implicitly {@link msgProto.CoffersFightEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {msgProto.ICoffersFightEnd} message CoffersFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fightData);
            return writer;
        };

        /**
         * Encodes the specified CoffersFightEnd message, length delimited. Does not implicitly {@link msgProto.CoffersFightEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {msgProto.ICoffersFightEnd} message CoffersFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersFightEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightEnd} CoffersFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                case 4:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersFightEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersFightEnd} CoffersFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersFightEnd message.
         * @function verify
         * @memberof msgProto.CoffersFightEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersFightEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            return null;
        };

        return CoffersFightEnd;
    })();

    msgProto.CoffersFightCoffersStart = (function() {

        /**
         * Properties of a CoffersFightCoffersStart.
         * @memberof msgProto
         * @interface ICoffersFightCoffersStart
         * @property {number|null} [serverId] CoffersFightCoffersStart serverId
         */

        /**
         * Constructs a new CoffersFightCoffersStart.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightCoffersStart.
         * @implements ICoffersFightCoffersStart
         * @constructor
         * @param {msgProto.ICoffersFightCoffersStart=} [properties] Properties to set
         */
        function CoffersFightCoffersStart(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightCoffersStart serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightCoffersStart
         * @instance
         */
        CoffersFightCoffersStart.prototype.serverId = 0;

        /**
         * Creates a new CoffersFightCoffersStart instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {msgProto.ICoffersFightCoffersStart=} [properties] Properties to set
         * @returns {msgProto.CoffersFightCoffersStart} CoffersFightCoffersStart instance
         */
        CoffersFightCoffersStart.create = function create(properties) {
            return new CoffersFightCoffersStart(properties);
        };

        /**
         * Encodes the specified CoffersFightCoffersStart message. Does not implicitly {@link msgProto.CoffersFightCoffersStart.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {msgProto.ICoffersFightCoffersStart} message CoffersFightCoffersStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverId);
            return writer;
        };

        /**
         * Encodes the specified CoffersFightCoffersStart message, length delimited. Does not implicitly {@link msgProto.CoffersFightCoffersStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {msgProto.ICoffersFightCoffersStart} message CoffersFightCoffersStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersFightCoffersStart message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightCoffersStart} CoffersFightCoffersStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightCoffersStart();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersFightCoffersStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersFightCoffersStart} CoffersFightCoffersStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersFightCoffersStart message.
         * @function verify
         * @memberof msgProto.CoffersFightCoffersStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersFightCoffersStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            return null;
        };

        return CoffersFightCoffersStart;
    })();

    msgProto.CoffersFightCoffersEnd = (function() {

        /**
         * Properties of a CoffersFightCoffersEnd.
         * @memberof msgProto
         * @interface ICoffersFightCoffersEnd
         * @property {number|null} [hurt] CoffersFightCoffersEnd hurt
         * @property {number|null} [serverId] CoffersFightCoffersEnd serverId
         * @property {string|null} [fightData] CoffersFightCoffersEnd fightData
         */

        /**
         * Constructs a new CoffersFightCoffersEnd.
         * @memberof msgProto
         * @classdesc Represents a CoffersFightCoffersEnd.
         * @implements ICoffersFightCoffersEnd
         * @constructor
         * @param {msgProto.ICoffersFightCoffersEnd=} [properties] Properties to set
         */
        function CoffersFightCoffersEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoffersFightCoffersEnd hurt.
         * @member {number} hurt
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.hurt = 0;

        /**
         * CoffersFightCoffersEnd serverId.
         * @member {number} serverId
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.serverId = 0;

        /**
         * CoffersFightCoffersEnd fightData.
         * @member {string} fightData
         * @memberof msgProto.CoffersFightCoffersEnd
         * @instance
         */
        CoffersFightCoffersEnd.prototype.fightData = "";

        /**
         * Creates a new CoffersFightCoffersEnd instance using the specified properties.
         * @function create
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {msgProto.ICoffersFightCoffersEnd=} [properties] Properties to set
         * @returns {msgProto.CoffersFightCoffersEnd} CoffersFightCoffersEnd instance
         */
        CoffersFightCoffersEnd.create = function create(properties) {
            return new CoffersFightCoffersEnd(properties);
        };

        /**
         * Encodes the specified CoffersFightCoffersEnd message. Does not implicitly {@link msgProto.CoffersFightCoffersEnd.verify|verify} messages.
         * @function encode
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {msgProto.ICoffersFightCoffersEnd} message CoffersFightCoffersEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hurt);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serverId);
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fightData);
            return writer;
        };

        /**
         * Encodes the specified CoffersFightCoffersEnd message, length delimited. Does not implicitly {@link msgProto.CoffersFightCoffersEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {msgProto.ICoffersFightCoffersEnd} message CoffersFightCoffersEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoffersFightCoffersEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoffersFightCoffersEnd message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.CoffersFightCoffersEnd} CoffersFightCoffersEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.CoffersFightCoffersEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hurt = reader.int32();
                    break;
                case 2:
                    message.serverId = reader.int32();
                    break;
                case 3:
                    message.fightData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoffersFightCoffersEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.CoffersFightCoffersEnd} CoffersFightCoffersEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoffersFightCoffersEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoffersFightCoffersEnd message.
         * @function verify
         * @memberof msgProto.CoffersFightCoffersEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoffersFightCoffersEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                if (!$util.isInteger(message.hurt))
                    return "hurt: integer expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.fightData != null && message.hasOwnProperty("fightData"))
                if (!$util.isString(message.fightData))
                    return "fightData: string expected";
            return null;
        };

        return CoffersFightCoffersEnd;
    })();

    msgProto.SdkGetVip = (function() {

        /**
         * Properties of a SdkGetVip.
         * @memberof msgProto
         * @interface ISdkGetVip
         */

        /**
         * Constructs a new SdkGetVip.
         * @memberof msgProto
         * @classdesc Represents a SdkGetVip.
         * @implements ISdkGetVip
         * @constructor
         * @param {msgProto.ISdkGetVip=} [properties] Properties to set
         */
        function SdkGetVip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SdkGetVip instance using the specified properties.
         * @function create
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {msgProto.ISdkGetVip=} [properties] Properties to set
         * @returns {msgProto.SdkGetVip} SdkGetVip instance
         */
        SdkGetVip.create = function create(properties) {
            return new SdkGetVip(properties);
        };

        /**
         * Encodes the specified SdkGetVip message. Does not implicitly {@link msgProto.SdkGetVip.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {msgProto.ISdkGetVip} message SdkGetVip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkGetVip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SdkGetVip message, length delimited. Does not implicitly {@link msgProto.SdkGetVip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {msgProto.ISdkGetVip} message SdkGetVip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkGetVip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkGetVip message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SdkGetVip} SdkGetVip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkGetVip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SdkGetVip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkGetVip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SdkGetVip} SdkGetVip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkGetVip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkGetVip message.
         * @function verify
         * @memberof msgProto.SdkGetVip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkGetVip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return SdkGetVip;
    })();

    msgProto.SmeltSmelt = (function() {

        /**
         * Properties of a SmeltSmelt.
         * @memberof msgProto
         * @interface ISmeltSmelt
         * @property {string|null} [equipArr] SmeltSmelt equipArr
         * @property {number|null} [choColor] SmeltSmelt choColor
         */

        /**
         * Constructs a new SmeltSmelt.
         * @memberof msgProto
         * @classdesc Represents a SmeltSmelt.
         * @implements ISmeltSmelt
         * @constructor
         * @param {msgProto.ISmeltSmelt=} [properties] Properties to set
         */
        function SmeltSmelt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltSmelt equipArr.
         * @member {string} equipArr
         * @memberof msgProto.SmeltSmelt
         * @instance
         */
        SmeltSmelt.prototype.equipArr = "";

        /**
         * SmeltSmelt choColor.
         * @member {number} choColor
         * @memberof msgProto.SmeltSmelt
         * @instance
         */
        SmeltSmelt.prototype.choColor = 0;

        /**
         * Creates a new SmeltSmelt instance using the specified properties.
         * @function create
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {msgProto.ISmeltSmelt=} [properties] Properties to set
         * @returns {msgProto.SmeltSmelt} SmeltSmelt instance
         */
        SmeltSmelt.create = function create(properties) {
            return new SmeltSmelt(properties);
        };

        /**
         * Encodes the specified SmeltSmelt message. Does not implicitly {@link msgProto.SmeltSmelt.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {msgProto.ISmeltSmelt} message SmeltSmelt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltSmelt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.equipArr != null && message.hasOwnProperty("equipArr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.equipArr);
            if (message.choColor != null && message.hasOwnProperty("choColor"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.choColor);
            return writer;
        };

        /**
         * Encodes the specified SmeltSmelt message, length delimited. Does not implicitly {@link msgProto.SmeltSmelt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {msgProto.ISmeltSmelt} message SmeltSmelt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltSmelt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmeltSmelt message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltSmelt} SmeltSmelt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltSmelt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltSmelt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.equipArr = reader.string();
                    break;
                case 2:
                    message.choColor = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmeltSmelt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SmeltSmelt} SmeltSmelt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltSmelt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmeltSmelt message.
         * @function verify
         * @memberof msgProto.SmeltSmelt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmeltSmelt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.equipArr != null && message.hasOwnProperty("equipArr"))
                if (!$util.isString(message.equipArr))
                    return "equipArr: string expected";
            if (message.choColor != null && message.hasOwnProperty("choColor"))
                if (!$util.isInteger(message.choColor))
                    return "choColor: integer expected";
            return null;
        };

        return SmeltSmelt;
    })();

    msgProto.SmeltCompound = (function() {

        /**
         * Properties of a SmeltCompound.
         * @memberof msgProto
         * @interface ISmeltCompound
         * @property {number|null} [compoundId] SmeltCompound compoundId
         */

        /**
         * Constructs a new SmeltCompound.
         * @memberof msgProto
         * @classdesc Represents a SmeltCompound.
         * @implements ISmeltCompound
         * @constructor
         * @param {msgProto.ISmeltCompound=} [properties] Properties to set
         */
        function SmeltCompound(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltCompound compoundId.
         * @member {number} compoundId
         * @memberof msgProto.SmeltCompound
         * @instance
         */
        SmeltCompound.prototype.compoundId = 0;

        /**
         * Creates a new SmeltCompound instance using the specified properties.
         * @function create
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {msgProto.ISmeltCompound=} [properties] Properties to set
         * @returns {msgProto.SmeltCompound} SmeltCompound instance
         */
        SmeltCompound.create = function create(properties) {
            return new SmeltCompound(properties);
        };

        /**
         * Encodes the specified SmeltCompound message. Does not implicitly {@link msgProto.SmeltCompound.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {msgProto.ISmeltCompound} message SmeltCompound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltCompound.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compoundId != null && message.hasOwnProperty("compoundId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.compoundId);
            return writer;
        };

        /**
         * Encodes the specified SmeltCompound message, length delimited. Does not implicitly {@link msgProto.SmeltCompound.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {msgProto.ISmeltCompound} message SmeltCompound message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltCompound.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmeltCompound message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltCompound} SmeltCompound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltCompound.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltCompound();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.compoundId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmeltCompound message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SmeltCompound} SmeltCompound
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltCompound.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmeltCompound message.
         * @function verify
         * @memberof msgProto.SmeltCompound
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmeltCompound.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compoundId != null && message.hasOwnProperty("compoundId"))
                if (!$util.isInteger(message.compoundId))
                    return "compoundId: integer expected";
            return null;
        };

        return SmeltCompound;
    })();

    msgProto.SmeltWearParRing = (function() {

        /**
         * Properties of a SmeltWearParRing.
         * @memberof msgProto
         * @interface ISmeltWearParRing
         * @property {number|null} [tempId] SmeltWearParRing tempId
         * @property {number|null} [breakId] SmeltWearParRing breakId
         */

        /**
         * Constructs a new SmeltWearParRing.
         * @memberof msgProto
         * @classdesc Represents a SmeltWearParRing.
         * @implements ISmeltWearParRing
         * @constructor
         * @param {msgProto.ISmeltWearParRing=} [properties] Properties to set
         */
        function SmeltWearParRing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltWearParRing tempId.
         * @member {number} tempId
         * @memberof msgProto.SmeltWearParRing
         * @instance
         */
        SmeltWearParRing.prototype.tempId = 0;

        /**
         * SmeltWearParRing breakId.
         * @member {number} breakId
         * @memberof msgProto.SmeltWearParRing
         * @instance
         */
        SmeltWearParRing.prototype.breakId = 0;

        /**
         * Creates a new SmeltWearParRing instance using the specified properties.
         * @function create
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {msgProto.ISmeltWearParRing=} [properties] Properties to set
         * @returns {msgProto.SmeltWearParRing} SmeltWearParRing instance
         */
        SmeltWearParRing.create = function create(properties) {
            return new SmeltWearParRing(properties);
        };

        /**
         * Encodes the specified SmeltWearParRing message. Does not implicitly {@link msgProto.SmeltWearParRing.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {msgProto.ISmeltWearParRing} message SmeltWearParRing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltWearParRing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakId);
            return writer;
        };

        /**
         * Encodes the specified SmeltWearParRing message, length delimited. Does not implicitly {@link msgProto.SmeltWearParRing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {msgProto.ISmeltWearParRing} message SmeltWearParRing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltWearParRing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmeltWearParRing message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltWearParRing} SmeltWearParRing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltWearParRing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltWearParRing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.breakId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmeltWearParRing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SmeltWearParRing} SmeltWearParRing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltWearParRing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmeltWearParRing message.
         * @function verify
         * @memberof msgProto.SmeltWearParRing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmeltWearParRing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                if (!$util.isInteger(message.breakId))
                    return "breakId: integer expected";
            return null;
        };

        return SmeltWearParRing;
    })();

    msgProto.SmeltRingBreak = (function() {

        /**
         * Properties of a SmeltRingBreak.
         * @memberof msgProto
         * @interface ISmeltRingBreak
         * @property {number|null} [tempId] SmeltRingBreak tempId
         * @property {number|null} [breakId] SmeltRingBreak breakId
         */

        /**
         * Constructs a new SmeltRingBreak.
         * @memberof msgProto
         * @classdesc Represents a SmeltRingBreak.
         * @implements ISmeltRingBreak
         * @constructor
         * @param {msgProto.ISmeltRingBreak=} [properties] Properties to set
         */
        function SmeltRingBreak(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmeltRingBreak tempId.
         * @member {number} tempId
         * @memberof msgProto.SmeltRingBreak
         * @instance
         */
        SmeltRingBreak.prototype.tempId = 0;

        /**
         * SmeltRingBreak breakId.
         * @member {number} breakId
         * @memberof msgProto.SmeltRingBreak
         * @instance
         */
        SmeltRingBreak.prototype.breakId = 0;

        /**
         * Creates a new SmeltRingBreak instance using the specified properties.
         * @function create
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {msgProto.ISmeltRingBreak=} [properties] Properties to set
         * @returns {msgProto.SmeltRingBreak} SmeltRingBreak instance
         */
        SmeltRingBreak.create = function create(properties) {
            return new SmeltRingBreak(properties);
        };

        /**
         * Encodes the specified SmeltRingBreak message. Does not implicitly {@link msgProto.SmeltRingBreak.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {msgProto.ISmeltRingBreak} message SmeltRingBreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltRingBreak.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakId);
            return writer;
        };

        /**
         * Encodes the specified SmeltRingBreak message, length delimited. Does not implicitly {@link msgProto.SmeltRingBreak.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {msgProto.ISmeltRingBreak} message SmeltRingBreak message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmeltRingBreak.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmeltRingBreak message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SmeltRingBreak} SmeltRingBreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltRingBreak.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SmeltRingBreak();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.breakId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmeltRingBreak message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SmeltRingBreak} SmeltRingBreak
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmeltRingBreak.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmeltRingBreak message.
         * @function verify
         * @memberof msgProto.SmeltRingBreak
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmeltRingBreak.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.breakId != null && message.hasOwnProperty("breakId"))
                if (!$util.isInteger(message.breakId))
                    return "breakId: integer expected";
            return null;
        };

        return SmeltRingBreak;
    })();

    msgProto.KingGetInfo = (function() {

        /**
         * Properties of a KingGetInfo.
         * @memberof msgProto
         * @interface IKingGetInfo
         */

        /**
         * Constructs a new KingGetInfo.
         * @memberof msgProto
         * @classdesc Represents a KingGetInfo.
         * @implements IKingGetInfo
         * @constructor
         * @param {msgProto.IKingGetInfo=} [properties] Properties to set
         */
        function KingGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new KingGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {msgProto.IKingGetInfo=} [properties] Properties to set
         * @returns {msgProto.KingGetInfo} KingGetInfo instance
         */
        KingGetInfo.create = function create(properties) {
            return new KingGetInfo(properties);
        };

        /**
         * Encodes the specified KingGetInfo message. Does not implicitly {@link msgProto.KingGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {msgProto.IKingGetInfo} message KingGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified KingGetInfo message, length delimited. Does not implicitly {@link msgProto.KingGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {msgProto.IKingGetInfo} message KingGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KingGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingGetInfo} KingGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KingGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KingGetInfo} KingGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KingGetInfo message.
         * @function verify
         * @memberof msgProto.KingGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KingGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return KingGetInfo;
    })();

    msgProto.KingWorship = (function() {

        /**
         * Properties of a KingWorship.
         * @memberof msgProto
         * @interface IKingWorship
         */

        /**
         * Constructs a new KingWorship.
         * @memberof msgProto
         * @classdesc Represents a KingWorship.
         * @implements IKingWorship
         * @constructor
         * @param {msgProto.IKingWorship=} [properties] Properties to set
         */
        function KingWorship(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new KingWorship instance using the specified properties.
         * @function create
         * @memberof msgProto.KingWorship
         * @static
         * @param {msgProto.IKingWorship=} [properties] Properties to set
         * @returns {msgProto.KingWorship} KingWorship instance
         */
        KingWorship.create = function create(properties) {
            return new KingWorship(properties);
        };

        /**
         * Encodes the specified KingWorship message. Does not implicitly {@link msgProto.KingWorship.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingWorship
         * @static
         * @param {msgProto.IKingWorship} message KingWorship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingWorship.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified KingWorship message, length delimited. Does not implicitly {@link msgProto.KingWorship.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KingWorship
         * @static
         * @param {msgProto.IKingWorship} message KingWorship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingWorship.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KingWorship message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingWorship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingWorship} KingWorship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingWorship.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingWorship();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KingWorship message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KingWorship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KingWorship} KingWorship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingWorship.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KingWorship message.
         * @function verify
         * @memberof msgProto.KingWorship
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KingWorship.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return KingWorship;
    })();

    msgProto.KingReceiveWelfare = (function() {

        /**
         * Properties of a KingReceiveWelfare.
         * @memberof msgProto
         * @interface IKingReceiveWelfare
         */

        /**
         * Constructs a new KingReceiveWelfare.
         * @memberof msgProto
         * @classdesc Represents a KingReceiveWelfare.
         * @implements IKingReceiveWelfare
         * @constructor
         * @param {msgProto.IKingReceiveWelfare=} [properties] Properties to set
         */
        function KingReceiveWelfare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new KingReceiveWelfare instance using the specified properties.
         * @function create
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {msgProto.IKingReceiveWelfare=} [properties] Properties to set
         * @returns {msgProto.KingReceiveWelfare} KingReceiveWelfare instance
         */
        KingReceiveWelfare.create = function create(properties) {
            return new KingReceiveWelfare(properties);
        };

        /**
         * Encodes the specified KingReceiveWelfare message. Does not implicitly {@link msgProto.KingReceiveWelfare.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {msgProto.IKingReceiveWelfare} message KingReceiveWelfare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingReceiveWelfare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified KingReceiveWelfare message, length delimited. Does not implicitly {@link msgProto.KingReceiveWelfare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {msgProto.IKingReceiveWelfare} message KingReceiveWelfare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingReceiveWelfare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KingReceiveWelfare message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingReceiveWelfare} KingReceiveWelfare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingReceiveWelfare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingReceiveWelfare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KingReceiveWelfare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KingReceiveWelfare} KingReceiveWelfare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingReceiveWelfare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KingReceiveWelfare message.
         * @function verify
         * @memberof msgProto.KingReceiveWelfare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KingReceiveWelfare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return KingReceiveWelfare;
    })();

    msgProto.KingOpenBuff = (function() {

        /**
         * Properties of a KingOpenBuff.
         * @memberof msgProto
         * @interface IKingOpenBuff
         */

        /**
         * Constructs a new KingOpenBuff.
         * @memberof msgProto
         * @classdesc Represents a KingOpenBuff.
         * @implements IKingOpenBuff
         * @constructor
         * @param {msgProto.IKingOpenBuff=} [properties] Properties to set
         */
        function KingOpenBuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new KingOpenBuff instance using the specified properties.
         * @function create
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {msgProto.IKingOpenBuff=} [properties] Properties to set
         * @returns {msgProto.KingOpenBuff} KingOpenBuff instance
         */
        KingOpenBuff.create = function create(properties) {
            return new KingOpenBuff(properties);
        };

        /**
         * Encodes the specified KingOpenBuff message. Does not implicitly {@link msgProto.KingOpenBuff.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {msgProto.IKingOpenBuff} message KingOpenBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingOpenBuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified KingOpenBuff message, length delimited. Does not implicitly {@link msgProto.KingOpenBuff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {msgProto.IKingOpenBuff} message KingOpenBuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KingOpenBuff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KingOpenBuff message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KingOpenBuff} KingOpenBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingOpenBuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KingOpenBuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KingOpenBuff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KingOpenBuff} KingOpenBuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KingOpenBuff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KingOpenBuff message.
         * @function verify
         * @memberof msgProto.KingOpenBuff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KingOpenBuff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return KingOpenBuff;
    })();

    msgProto.ItemSellItems = (function() {

        /**
         * Properties of an ItemSellItems.
         * @memberof msgProto
         * @interface IItemSellItems
         * @property {number|null} [itemId] ItemSellItems itemId
         * @property {number|null} [itemNum] ItemSellItems itemNum
         */

        /**
         * Constructs a new ItemSellItems.
         * @memberof msgProto
         * @classdesc Represents an ItemSellItems.
         * @implements IItemSellItems
         * @constructor
         * @param {msgProto.IItemSellItems=} [properties] Properties to set
         */
        function ItemSellItems(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemSellItems itemId.
         * @member {number} itemId
         * @memberof msgProto.ItemSellItems
         * @instance
         */
        ItemSellItems.prototype.itemId = 0;

        /**
         * ItemSellItems itemNum.
         * @member {number} itemNum
         * @memberof msgProto.ItemSellItems
         * @instance
         */
        ItemSellItems.prototype.itemNum = 0;

        /**
         * Creates a new ItemSellItems instance using the specified properties.
         * @function create
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {msgProto.IItemSellItems=} [properties] Properties to set
         * @returns {msgProto.ItemSellItems} ItemSellItems instance
         */
        ItemSellItems.create = function create(properties) {
            return new ItemSellItems(properties);
        };

        /**
         * Encodes the specified ItemSellItems message. Does not implicitly {@link msgProto.ItemSellItems.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {msgProto.IItemSellItems} message ItemSellItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemSellItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum);
            return writer;
        };

        /**
         * Encodes the specified ItemSellItems message, length delimited. Does not implicitly {@link msgProto.ItemSellItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {msgProto.IItemSellItems} message ItemSellItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemSellItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemSellItems message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ItemSellItems} ItemSellItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemSellItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ItemSellItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.itemNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemSellItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ItemSellItems} ItemSellItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemSellItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemSellItems message.
         * @function verify
         * @memberof msgProto.ItemSellItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemSellItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                if (!$util.isInteger(message.itemNum))
                    return "itemNum: integer expected";
            return null;
        };

        return ItemSellItems;
    })();

    msgProto.TreasureSpies = (function() {

        /**
         * Properties of a TreasureSpies.
         * @memberof msgProto
         * @interface ITreasureSpies
         */

        /**
         * Constructs a new TreasureSpies.
         * @memberof msgProto
         * @classdesc Represents a TreasureSpies.
         * @implements ITreasureSpies
         * @constructor
         * @param {msgProto.ITreasureSpies=} [properties] Properties to set
         */
        function TreasureSpies(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TreasureSpies instance using the specified properties.
         * @function create
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {msgProto.ITreasureSpies=} [properties] Properties to set
         * @returns {msgProto.TreasureSpies} TreasureSpies instance
         */
        TreasureSpies.create = function create(properties) {
            return new TreasureSpies(properties);
        };

        /**
         * Encodes the specified TreasureSpies message. Does not implicitly {@link msgProto.TreasureSpies.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {msgProto.ITreasureSpies} message TreasureSpies message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureSpies.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TreasureSpies message, length delimited. Does not implicitly {@link msgProto.TreasureSpies.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {msgProto.ITreasureSpies} message TreasureSpies message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureSpies.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureSpies message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureSpies} TreasureSpies
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureSpies.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureSpies();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureSpies message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TreasureSpies} TreasureSpies
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureSpies.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureSpies message.
         * @function verify
         * @memberof msgProto.TreasureSpies
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureSpies.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TreasureSpies;
    })();

    msgProto.TreasureGetExPkOutInfo = (function() {

        /**
         * Properties of a TreasureGetExPkOutInfo.
         * @memberof msgProto
         * @interface ITreasureGetExPkOutInfo
         */

        /**
         * Constructs a new TreasureGetExPkOutInfo.
         * @memberof msgProto
         * @classdesc Represents a TreasureGetExPkOutInfo.
         * @implements ITreasureGetExPkOutInfo
         * @constructor
         * @param {msgProto.ITreasureGetExPkOutInfo=} [properties] Properties to set
         */
        function TreasureGetExPkOutInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TreasureGetExPkOutInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {msgProto.ITreasureGetExPkOutInfo=} [properties] Properties to set
         * @returns {msgProto.TreasureGetExPkOutInfo} TreasureGetExPkOutInfo instance
         */
        TreasureGetExPkOutInfo.create = function create(properties) {
            return new TreasureGetExPkOutInfo(properties);
        };

        /**
         * Encodes the specified TreasureGetExPkOutInfo message. Does not implicitly {@link msgProto.TreasureGetExPkOutInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {msgProto.ITreasureGetExPkOutInfo} message TreasureGetExPkOutInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureGetExPkOutInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TreasureGetExPkOutInfo message, length delimited. Does not implicitly {@link msgProto.TreasureGetExPkOutInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {msgProto.ITreasureGetExPkOutInfo} message TreasureGetExPkOutInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureGetExPkOutInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureGetExPkOutInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureGetExPkOutInfo} TreasureGetExPkOutInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureGetExPkOutInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureGetExPkOutInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureGetExPkOutInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TreasureGetExPkOutInfo} TreasureGetExPkOutInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureGetExPkOutInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureGetExPkOutInfo message.
         * @function verify
         * @memberof msgProto.TreasureGetExPkOutInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureGetExPkOutInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TreasureGetExPkOutInfo;
    })();

    msgProto.TreasureOpen = (function() {

        /**
         * Properties of a TreasureOpen.
         * @memberof msgProto
         * @interface ITreasureOpen
         * @property {number|null} [id] TreasureOpen id
         */

        /**
         * Constructs a new TreasureOpen.
         * @memberof msgProto
         * @classdesc Represents a TreasureOpen.
         * @implements ITreasureOpen
         * @constructor
         * @param {msgProto.ITreasureOpen=} [properties] Properties to set
         */
        function TreasureOpen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureOpen id.
         * @member {number} id
         * @memberof msgProto.TreasureOpen
         * @instance
         */
        TreasureOpen.prototype.id = 0;

        /**
         * Creates a new TreasureOpen instance using the specified properties.
         * @function create
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {msgProto.ITreasureOpen=} [properties] Properties to set
         * @returns {msgProto.TreasureOpen} TreasureOpen instance
         */
        TreasureOpen.create = function create(properties) {
            return new TreasureOpen(properties);
        };

        /**
         * Encodes the specified TreasureOpen message. Does not implicitly {@link msgProto.TreasureOpen.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {msgProto.ITreasureOpen} message TreasureOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureOpen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified TreasureOpen message, length delimited. Does not implicitly {@link msgProto.TreasureOpen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {msgProto.ITreasureOpen} message TreasureOpen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureOpen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureOpen message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureOpen} TreasureOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureOpen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureOpen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureOpen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TreasureOpen} TreasureOpen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureOpen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureOpen message.
         * @function verify
         * @memberof msgProto.TreasureOpen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureOpen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        return TreasureOpen;
    })();

    msgProto.TreasureCompose = (function() {

        /**
         * Properties of a TreasureCompose.
         * @memberof msgProto
         * @interface ITreasureCompose
         * @property {number|null} [itemId] TreasureCompose itemId
         */

        /**
         * Constructs a new TreasureCompose.
         * @memberof msgProto
         * @classdesc Represents a TreasureCompose.
         * @implements ITreasureCompose
         * @constructor
         * @param {msgProto.ITreasureCompose=} [properties] Properties to set
         */
        function TreasureCompose(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureCompose itemId.
         * @member {number} itemId
         * @memberof msgProto.TreasureCompose
         * @instance
         */
        TreasureCompose.prototype.itemId = 0;

        /**
         * Creates a new TreasureCompose instance using the specified properties.
         * @function create
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {msgProto.ITreasureCompose=} [properties] Properties to set
         * @returns {msgProto.TreasureCompose} TreasureCompose instance
         */
        TreasureCompose.create = function create(properties) {
            return new TreasureCompose(properties);
        };

        /**
         * Encodes the specified TreasureCompose message. Does not implicitly {@link msgProto.TreasureCompose.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {msgProto.ITreasureCompose} message TreasureCompose message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureCompose.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Encodes the specified TreasureCompose message, length delimited. Does not implicitly {@link msgProto.TreasureCompose.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {msgProto.ITreasureCompose} message TreasureCompose message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureCompose.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureCompose message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TreasureCompose} TreasureCompose
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureCompose.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TreasureCompose();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureCompose message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TreasureCompose} TreasureCompose
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureCompose.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureCompose message.
         * @function verify
         * @memberof msgProto.TreasureCompose
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureCompose.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            return null;
        };

        return TreasureCompose;
    })();

    msgProto.TalismanUseTrumpItem = (function() {

        /**
         * Properties of a TalismanUseTrumpItem.
         * @memberof msgProto
         * @interface ITalismanUseTrumpItem
         * @property {number|null} [itemId] TalismanUseTrumpItem itemId
         */

        /**
         * Constructs a new TalismanUseTrumpItem.
         * @memberof msgProto
         * @classdesc Represents a TalismanUseTrumpItem.
         * @implements ITalismanUseTrumpItem
         * @constructor
         * @param {msgProto.ITalismanUseTrumpItem=} [properties] Properties to set
         */
        function TalismanUseTrumpItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUseTrumpItem itemId.
         * @member {number} itemId
         * @memberof msgProto.TalismanUseTrumpItem
         * @instance
         */
        TalismanUseTrumpItem.prototype.itemId = 0;

        /**
         * Creates a new TalismanUseTrumpItem instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {msgProto.ITalismanUseTrumpItem=} [properties] Properties to set
         * @returns {msgProto.TalismanUseTrumpItem} TalismanUseTrumpItem instance
         */
        TalismanUseTrumpItem.create = function create(properties) {
            return new TalismanUseTrumpItem(properties);
        };

        /**
         * Encodes the specified TalismanUseTrumpItem message. Does not implicitly {@link msgProto.TalismanUseTrumpItem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {msgProto.ITalismanUseTrumpItem} message TalismanUseTrumpItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUseTrumpItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Encodes the specified TalismanUseTrumpItem message, length delimited. Does not implicitly {@link msgProto.TalismanUseTrumpItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {msgProto.ITalismanUseTrumpItem} message TalismanUseTrumpItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUseTrumpItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanUseTrumpItem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUseTrumpItem} TalismanUseTrumpItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUseTrumpItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUseTrumpItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanUseTrumpItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanUseTrumpItem} TalismanUseTrumpItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUseTrumpItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanUseTrumpItem message.
         * @function verify
         * @memberof msgProto.TalismanUseTrumpItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanUseTrumpItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            return null;
        };

        return TalismanUseTrumpItem;
    })();

    msgProto.TalismanWearTrump = (function() {

        /**
         * Properties of a TalismanWearTrump.
         * @memberof msgProto
         * @interface ITalismanWearTrump
         * @property {number|null} [tempId] TalismanWearTrump tempId
         * @property {number|null} [trumpId] TalismanWearTrump trumpId
         */

        /**
         * Constructs a new TalismanWearTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanWearTrump.
         * @implements ITalismanWearTrump
         * @constructor
         * @param {msgProto.ITalismanWearTrump=} [properties] Properties to set
         */
        function TalismanWearTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanWearTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanWearTrump
         * @instance
         */
        TalismanWearTrump.prototype.tempId = 0;

        /**
         * TalismanWearTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanWearTrump
         * @instance
         */
        TalismanWearTrump.prototype.trumpId = 0;

        /**
         * Creates a new TalismanWearTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {msgProto.ITalismanWearTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanWearTrump} TalismanWearTrump instance
         */
        TalismanWearTrump.create = function create(properties) {
            return new TalismanWearTrump(properties);
        };

        /**
         * Encodes the specified TalismanWearTrump message. Does not implicitly {@link msgProto.TalismanWearTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {msgProto.ITalismanWearTrump} message TalismanWearTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanWearTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanWearTrump message, length delimited. Does not implicitly {@link msgProto.TalismanWearTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {msgProto.ITalismanWearTrump} message TalismanWearTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanWearTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanWearTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanWearTrump} TalismanWearTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanWearTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanWearTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanWearTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanWearTrump} TalismanWearTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanWearTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanWearTrump message.
         * @function verify
         * @memberof msgProto.TalismanWearTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanWearTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanWearTrump;
    })();

    msgProto.TalismanUpTrumpLvl = (function() {

        /**
         * Properties of a TalismanUpTrumpLvl.
         * @memberof msgProto
         * @interface ITalismanUpTrumpLvl
         * @property {number|null} [tempId] TalismanUpTrumpLvl tempId
         * @property {number|null} [trumpId] TalismanUpTrumpLvl trumpId
         */

        /**
         * Constructs a new TalismanUpTrumpLvl.
         * @memberof msgProto
         * @classdesc Represents a TalismanUpTrumpLvl.
         * @implements ITalismanUpTrumpLvl
         * @constructor
         * @param {msgProto.ITalismanUpTrumpLvl=} [properties] Properties to set
         */
        function TalismanUpTrumpLvl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUpTrumpLvl tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanUpTrumpLvl
         * @instance
         */
        TalismanUpTrumpLvl.prototype.tempId = 0;

        /**
         * TalismanUpTrumpLvl trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanUpTrumpLvl
         * @instance
         */
        TalismanUpTrumpLvl.prototype.trumpId = 0;

        /**
         * Creates a new TalismanUpTrumpLvl instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {msgProto.ITalismanUpTrumpLvl=} [properties] Properties to set
         * @returns {msgProto.TalismanUpTrumpLvl} TalismanUpTrumpLvl instance
         */
        TalismanUpTrumpLvl.create = function create(properties) {
            return new TalismanUpTrumpLvl(properties);
        };

        /**
         * Encodes the specified TalismanUpTrumpLvl message. Does not implicitly {@link msgProto.TalismanUpTrumpLvl.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {msgProto.ITalismanUpTrumpLvl} message TalismanUpTrumpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpLvl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanUpTrumpLvl message, length delimited. Does not implicitly {@link msgProto.TalismanUpTrumpLvl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {msgProto.ITalismanUpTrumpLvl} message TalismanUpTrumpLvl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpLvl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanUpTrumpLvl message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUpTrumpLvl} TalismanUpTrumpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpLvl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUpTrumpLvl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanUpTrumpLvl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanUpTrumpLvl} TalismanUpTrumpLvl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpLvl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanUpTrumpLvl message.
         * @function verify
         * @memberof msgProto.TalismanUpTrumpLvl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanUpTrumpLvl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanUpTrumpLvl;
    })();

    msgProto.TalismanUpTrumpStar = (function() {

        /**
         * Properties of a TalismanUpTrumpStar.
         * @memberof msgProto
         * @interface ITalismanUpTrumpStar
         * @property {number|null} [tempId] TalismanUpTrumpStar tempId
         * @property {number|null} [trumpId] TalismanUpTrumpStar trumpId
         */

        /**
         * Constructs a new TalismanUpTrumpStar.
         * @memberof msgProto
         * @classdesc Represents a TalismanUpTrumpStar.
         * @implements ITalismanUpTrumpStar
         * @constructor
         * @param {msgProto.ITalismanUpTrumpStar=} [properties] Properties to set
         */
        function TalismanUpTrumpStar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanUpTrumpStar tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanUpTrumpStar
         * @instance
         */
        TalismanUpTrumpStar.prototype.tempId = 0;

        /**
         * TalismanUpTrumpStar trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanUpTrumpStar
         * @instance
         */
        TalismanUpTrumpStar.prototype.trumpId = 0;

        /**
         * Creates a new TalismanUpTrumpStar instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {msgProto.ITalismanUpTrumpStar=} [properties] Properties to set
         * @returns {msgProto.TalismanUpTrumpStar} TalismanUpTrumpStar instance
         */
        TalismanUpTrumpStar.create = function create(properties) {
            return new TalismanUpTrumpStar(properties);
        };

        /**
         * Encodes the specified TalismanUpTrumpStar message. Does not implicitly {@link msgProto.TalismanUpTrumpStar.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {msgProto.ITalismanUpTrumpStar} message TalismanUpTrumpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpStar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanUpTrumpStar message, length delimited. Does not implicitly {@link msgProto.TalismanUpTrumpStar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {msgProto.ITalismanUpTrumpStar} message TalismanUpTrumpStar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanUpTrumpStar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanUpTrumpStar message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanUpTrumpStar} TalismanUpTrumpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpStar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanUpTrumpStar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanUpTrumpStar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanUpTrumpStar} TalismanUpTrumpStar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanUpTrumpStar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanUpTrumpStar message.
         * @function verify
         * @memberof msgProto.TalismanUpTrumpStar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanUpTrumpStar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanUpTrumpStar;
    })();

    msgProto.TalismanRecastTrump = (function() {

        /**
         * Properties of a TalismanRecastTrump.
         * @memberof msgProto
         * @interface ITalismanRecastTrump
         * @property {number|null} [tempId] TalismanRecastTrump tempId
         * @property {number|null} [trumpId] TalismanRecastTrump trumpId
         */

        /**
         * Constructs a new TalismanRecastTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanRecastTrump.
         * @implements ITalismanRecastTrump
         * @constructor
         * @param {msgProto.ITalismanRecastTrump=} [properties] Properties to set
         */
        function TalismanRecastTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanRecastTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanRecastTrump
         * @instance
         */
        TalismanRecastTrump.prototype.tempId = 0;

        /**
         * TalismanRecastTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanRecastTrump
         * @instance
         */
        TalismanRecastTrump.prototype.trumpId = 0;

        /**
         * Creates a new TalismanRecastTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {msgProto.ITalismanRecastTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanRecastTrump} TalismanRecastTrump instance
         */
        TalismanRecastTrump.create = function create(properties) {
            return new TalismanRecastTrump(properties);
        };

        /**
         * Encodes the specified TalismanRecastTrump message. Does not implicitly {@link msgProto.TalismanRecastTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {msgProto.ITalismanRecastTrump} message TalismanRecastTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanRecastTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanRecastTrump message, length delimited. Does not implicitly {@link msgProto.TalismanRecastTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {msgProto.ITalismanRecastTrump} message TalismanRecastTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanRecastTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanRecastTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanRecastTrump} TalismanRecastTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanRecastTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanRecastTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanRecastTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanRecastTrump} TalismanRecastTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanRecastTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanRecastTrump message.
         * @function verify
         * @memberof msgProto.TalismanRecastTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanRecastTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanRecastTrump;
    })();

    msgProto.TalismanCompoundTrump = (function() {

        /**
         * Properties of a TalismanCompoundTrump.
         * @memberof msgProto
         * @interface ITalismanCompoundTrump
         * @property {number|null} [tempId] TalismanCompoundTrump tempId
         * @property {number|null} [trumpId] TalismanCompoundTrump trumpId
         */

        /**
         * Constructs a new TalismanCompoundTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanCompoundTrump.
         * @implements ITalismanCompoundTrump
         * @constructor
         * @param {msgProto.ITalismanCompoundTrump=} [properties] Properties to set
         */
        function TalismanCompoundTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanCompoundTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanCompoundTrump
         * @instance
         */
        TalismanCompoundTrump.prototype.tempId = 0;

        /**
         * TalismanCompoundTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanCompoundTrump
         * @instance
         */
        TalismanCompoundTrump.prototype.trumpId = 0;

        /**
         * Creates a new TalismanCompoundTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {msgProto.ITalismanCompoundTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanCompoundTrump} TalismanCompoundTrump instance
         */
        TalismanCompoundTrump.create = function create(properties) {
            return new TalismanCompoundTrump(properties);
        };

        /**
         * Encodes the specified TalismanCompoundTrump message. Does not implicitly {@link msgProto.TalismanCompoundTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {msgProto.ITalismanCompoundTrump} message TalismanCompoundTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCompoundTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanCompoundTrump message, length delimited. Does not implicitly {@link msgProto.TalismanCompoundTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {msgProto.ITalismanCompoundTrump} message TalismanCompoundTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCompoundTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanCompoundTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanCompoundTrump} TalismanCompoundTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCompoundTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanCompoundTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanCompoundTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanCompoundTrump} TalismanCompoundTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCompoundTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanCompoundTrump message.
         * @function verify
         * @memberof msgProto.TalismanCompoundTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanCompoundTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanCompoundTrump;
    })();

    msgProto.TalismanBaptizeTrump = (function() {

        /**
         * Properties of a TalismanBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanBaptizeTrump
         * @property {number|null} [tempId] TalismanBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanBaptizeTrump trumpId
         * @property {boolean|null} [isCheck] TalismanBaptizeTrump isCheck
         */

        /**
         * Constructs a new TalismanBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanBaptizeTrump.
         * @implements ITalismanBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanBaptizeTrump=} [properties] Properties to set
         */
        function TalismanBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.trumpId = 0;

        /**
         * TalismanBaptizeTrump isCheck.
         * @member {boolean} isCheck
         * @memberof msgProto.TalismanBaptizeTrump
         * @instance
         */
        TalismanBaptizeTrump.prototype.isCheck = false;

        /**
         * Creates a new TalismanBaptizeTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {msgProto.ITalismanBaptizeTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanBaptizeTrump} TalismanBaptizeTrump instance
         */
        TalismanBaptizeTrump.create = function create(properties) {
            return new TalismanBaptizeTrump(properties);
        };

        /**
         * Encodes the specified TalismanBaptizeTrump message. Does not implicitly {@link msgProto.TalismanBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {msgProto.ITalismanBaptizeTrump} message TalismanBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            if (message.isCheck != null && message.hasOwnProperty("isCheck"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isCheck);
            return writer;
        };

        /**
         * Encodes the specified TalismanBaptizeTrump message, length delimited. Does not implicitly {@link msgProto.TalismanBaptizeTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {msgProto.ITalismanBaptizeTrump} message TalismanBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanBaptizeTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanBaptizeTrump} TalismanBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                case 3:
                    message.isCheck = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanBaptizeTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanBaptizeTrump} TalismanBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanBaptizeTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanBaptizeTrump message.
         * @function verify
         * @memberof msgProto.TalismanBaptizeTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanBaptizeTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            if (message.isCheck != null && message.hasOwnProperty("isCheck"))
                if (typeof message.isCheck !== "boolean")
                    return "isCheck: boolean expected";
            return null;
        };

        return TalismanBaptizeTrump;
    })();

    msgProto.TalismanConfirmBaptizeTrump = (function() {

        /**
         * Properties of a TalismanConfirmBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanConfirmBaptizeTrump
         * @property {number|null} [tempId] TalismanConfirmBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanConfirmBaptizeTrump trumpId
         */

        /**
         * Constructs a new TalismanConfirmBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanConfirmBaptizeTrump.
         * @implements ITalismanConfirmBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanConfirmBaptizeTrump=} [properties] Properties to set
         */
        function TalismanConfirmBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanConfirmBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @instance
         */
        TalismanConfirmBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanConfirmBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @instance
         */
        TalismanConfirmBaptizeTrump.prototype.trumpId = 0;

        /**
         * Creates a new TalismanConfirmBaptizeTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {msgProto.ITalismanConfirmBaptizeTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanConfirmBaptizeTrump} TalismanConfirmBaptizeTrump instance
         */
        TalismanConfirmBaptizeTrump.create = function create(properties) {
            return new TalismanConfirmBaptizeTrump(properties);
        };

        /**
         * Encodes the specified TalismanConfirmBaptizeTrump message. Does not implicitly {@link msgProto.TalismanConfirmBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {msgProto.ITalismanConfirmBaptizeTrump} message TalismanConfirmBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanConfirmBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanConfirmBaptizeTrump message, length delimited. Does not implicitly {@link msgProto.TalismanConfirmBaptizeTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {msgProto.ITalismanConfirmBaptizeTrump} message TalismanConfirmBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanConfirmBaptizeTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanConfirmBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanConfirmBaptizeTrump} TalismanConfirmBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanConfirmBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanConfirmBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanConfirmBaptizeTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanConfirmBaptizeTrump} TalismanConfirmBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanConfirmBaptizeTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanConfirmBaptizeTrump message.
         * @function verify
         * @memberof msgProto.TalismanConfirmBaptizeTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanConfirmBaptizeTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanConfirmBaptizeTrump;
    })();

    msgProto.TalismanCancelBaptizeTrump = (function() {

        /**
         * Properties of a TalismanCancelBaptizeTrump.
         * @memberof msgProto
         * @interface ITalismanCancelBaptizeTrump
         * @property {number|null} [tempId] TalismanCancelBaptizeTrump tempId
         * @property {number|null} [trumpId] TalismanCancelBaptizeTrump trumpId
         */

        /**
         * Constructs a new TalismanCancelBaptizeTrump.
         * @memberof msgProto
         * @classdesc Represents a TalismanCancelBaptizeTrump.
         * @implements ITalismanCancelBaptizeTrump
         * @constructor
         * @param {msgProto.ITalismanCancelBaptizeTrump=} [properties] Properties to set
         */
        function TalismanCancelBaptizeTrump(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TalismanCancelBaptizeTrump tempId.
         * @member {number} tempId
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @instance
         */
        TalismanCancelBaptizeTrump.prototype.tempId = 0;

        /**
         * TalismanCancelBaptizeTrump trumpId.
         * @member {number} trumpId
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @instance
         */
        TalismanCancelBaptizeTrump.prototype.trumpId = 0;

        /**
         * Creates a new TalismanCancelBaptizeTrump instance using the specified properties.
         * @function create
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {msgProto.ITalismanCancelBaptizeTrump=} [properties] Properties to set
         * @returns {msgProto.TalismanCancelBaptizeTrump} TalismanCancelBaptizeTrump instance
         */
        TalismanCancelBaptizeTrump.create = function create(properties) {
            return new TalismanCancelBaptizeTrump(properties);
        };

        /**
         * Encodes the specified TalismanCancelBaptizeTrump message. Does not implicitly {@link msgProto.TalismanCancelBaptizeTrump.verify|verify} messages.
         * @function encode
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {msgProto.ITalismanCancelBaptizeTrump} message TalismanCancelBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCancelBaptizeTrump.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trumpId);
            return writer;
        };

        /**
         * Encodes the specified TalismanCancelBaptizeTrump message, length delimited. Does not implicitly {@link msgProto.TalismanCancelBaptizeTrump.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {msgProto.ITalismanCancelBaptizeTrump} message TalismanCancelBaptizeTrump message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TalismanCancelBaptizeTrump.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TalismanCancelBaptizeTrump message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.TalismanCancelBaptizeTrump} TalismanCancelBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCancelBaptizeTrump.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.TalismanCancelBaptizeTrump();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.trumpId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TalismanCancelBaptizeTrump message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.TalismanCancelBaptizeTrump} TalismanCancelBaptizeTrump
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TalismanCancelBaptizeTrump.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TalismanCancelBaptizeTrump message.
         * @function verify
         * @memberof msgProto.TalismanCancelBaptizeTrump
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TalismanCancelBaptizeTrump.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.trumpId != null && message.hasOwnProperty("trumpId"))
                if (!$util.isInteger(message.trumpId))
                    return "trumpId: integer expected";
            return null;
        };

        return TalismanCancelBaptizeTrump;
    })();

    msgProto.ExpeditionGetInfo = (function() {

        /**
         * Properties of an ExpeditionGetInfo.
         * @memberof msgProto
         * @interface IExpeditionGetInfo
         */

        /**
         * Constructs a new ExpeditionGetInfo.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionGetInfo.
         * @implements IExpeditionGetInfo
         * @constructor
         * @param {msgProto.IExpeditionGetInfo=} [properties] Properties to set
         */
        function ExpeditionGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ExpeditionGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {msgProto.IExpeditionGetInfo=} [properties] Properties to set
         * @returns {msgProto.ExpeditionGetInfo} ExpeditionGetInfo instance
         */
        ExpeditionGetInfo.create = function create(properties) {
            return new ExpeditionGetInfo(properties);
        };

        /**
         * Encodes the specified ExpeditionGetInfo message. Does not implicitly {@link msgProto.ExpeditionGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {msgProto.IExpeditionGetInfo} message ExpeditionGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ExpeditionGetInfo message, length delimited. Does not implicitly {@link msgProto.ExpeditionGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {msgProto.IExpeditionGetInfo} message ExpeditionGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpeditionGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionGetInfo} ExpeditionGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpeditionGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ExpeditionGetInfo} ExpeditionGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpeditionGetInfo message.
         * @function verify
         * @memberof msgProto.ExpeditionGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpeditionGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ExpeditionGetInfo;
    })();

    msgProto.ExpeditionWearSoul = (function() {

        /**
         * Properties of an ExpeditionWearSoul.
         * @memberof msgProto
         * @interface IExpeditionWearSoul
         * @property {number|null} [tempId] ExpeditionWearSoul tempId
         * @property {number|null} [soulId] ExpeditionWearSoul soulId
         */

        /**
         * Constructs a new ExpeditionWearSoul.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionWearSoul.
         * @implements IExpeditionWearSoul
         * @constructor
         * @param {msgProto.IExpeditionWearSoul=} [properties] Properties to set
         */
        function ExpeditionWearSoul(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionWearSoul tempId.
         * @member {number} tempId
         * @memberof msgProto.ExpeditionWearSoul
         * @instance
         */
        ExpeditionWearSoul.prototype.tempId = 0;

        /**
         * ExpeditionWearSoul soulId.
         * @member {number} soulId
         * @memberof msgProto.ExpeditionWearSoul
         * @instance
         */
        ExpeditionWearSoul.prototype.soulId = 0;

        /**
         * Creates a new ExpeditionWearSoul instance using the specified properties.
         * @function create
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {msgProto.IExpeditionWearSoul=} [properties] Properties to set
         * @returns {msgProto.ExpeditionWearSoul} ExpeditionWearSoul instance
         */
        ExpeditionWearSoul.create = function create(properties) {
            return new ExpeditionWearSoul(properties);
        };

        /**
         * Encodes the specified ExpeditionWearSoul message. Does not implicitly {@link msgProto.ExpeditionWearSoul.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {msgProto.IExpeditionWearSoul} message ExpeditionWearSoul message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionWearSoul.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tempId);
            if (message.soulId != null && message.hasOwnProperty("soulId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.soulId);
            return writer;
        };

        /**
         * Encodes the specified ExpeditionWearSoul message, length delimited. Does not implicitly {@link msgProto.ExpeditionWearSoul.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {msgProto.IExpeditionWearSoul} message ExpeditionWearSoul message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionWearSoul.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpeditionWearSoul message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionWearSoul} ExpeditionWearSoul
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionWearSoul.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionWearSoul();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempId = reader.int32();
                    break;
                case 2:
                    message.soulId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpeditionWearSoul message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ExpeditionWearSoul} ExpeditionWearSoul
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionWearSoul.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpeditionWearSoul message.
         * @function verify
         * @memberof msgProto.ExpeditionWearSoul
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpeditionWearSoul.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tempId != null && message.hasOwnProperty("tempId"))
                if (!$util.isInteger(message.tempId))
                    return "tempId: integer expected";
            if (message.soulId != null && message.hasOwnProperty("soulId"))
                if (!$util.isInteger(message.soulId))
                    return "soulId: integer expected";
            return null;
        };

        return ExpeditionWearSoul;
    })();

    msgProto.ExpeditionStartBattle = (function() {

        /**
         * Properties of an ExpeditionStartBattle.
         * @memberof msgProto
         * @interface IExpeditionStartBattle
         * @property {number|null} [stageId] ExpeditionStartBattle stageId
         */

        /**
         * Constructs a new ExpeditionStartBattle.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionStartBattle.
         * @implements IExpeditionStartBattle
         * @constructor
         * @param {msgProto.IExpeditionStartBattle=} [properties] Properties to set
         */
        function ExpeditionStartBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionStartBattle stageId.
         * @member {number} stageId
         * @memberof msgProto.ExpeditionStartBattle
         * @instance
         */
        ExpeditionStartBattle.prototype.stageId = 0;

        /**
         * Creates a new ExpeditionStartBattle instance using the specified properties.
         * @function create
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {msgProto.IExpeditionStartBattle=} [properties] Properties to set
         * @returns {msgProto.ExpeditionStartBattle} ExpeditionStartBattle instance
         */
        ExpeditionStartBattle.create = function create(properties) {
            return new ExpeditionStartBattle(properties);
        };

        /**
         * Encodes the specified ExpeditionStartBattle message. Does not implicitly {@link msgProto.ExpeditionStartBattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {msgProto.IExpeditionStartBattle} message ExpeditionStartBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionStartBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stageId != null && message.hasOwnProperty("stageId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stageId);
            return writer;
        };

        /**
         * Encodes the specified ExpeditionStartBattle message, length delimited. Does not implicitly {@link msgProto.ExpeditionStartBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {msgProto.IExpeditionStartBattle} message ExpeditionStartBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionStartBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpeditionStartBattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionStartBattle} ExpeditionStartBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionStartBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionStartBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stageId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpeditionStartBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ExpeditionStartBattle} ExpeditionStartBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionStartBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpeditionStartBattle message.
         * @function verify
         * @memberof msgProto.ExpeditionStartBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpeditionStartBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stageId != null && message.hasOwnProperty("stageId"))
                if (!$util.isInteger(message.stageId))
                    return "stageId: integer expected";
            return null;
        };

        return ExpeditionStartBattle;
    })();

    msgProto.ExpeditionEndBattle = (function() {

        /**
         * Properties of an ExpeditionEndBattle.
         * @memberof msgProto
         * @interface IExpeditionEndBattle
         * @property {boolean|null} [isWin] ExpeditionEndBattle isWin
         * @property {number|null} [herosHp] ExpeditionEndBattle herosHp
         */

        /**
         * Constructs a new ExpeditionEndBattle.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionEndBattle.
         * @implements IExpeditionEndBattle
         * @constructor
         * @param {msgProto.IExpeditionEndBattle=} [properties] Properties to set
         */
        function ExpeditionEndBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionEndBattle isWin.
         * @member {boolean} isWin
         * @memberof msgProto.ExpeditionEndBattle
         * @instance
         */
        ExpeditionEndBattle.prototype.isWin = false;

        /**
         * ExpeditionEndBattle herosHp.
         * @member {number} herosHp
         * @memberof msgProto.ExpeditionEndBattle
         * @instance
         */
        ExpeditionEndBattle.prototype.herosHp = 0;

        /**
         * Creates a new ExpeditionEndBattle instance using the specified properties.
         * @function create
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {msgProto.IExpeditionEndBattle=} [properties] Properties to set
         * @returns {msgProto.ExpeditionEndBattle} ExpeditionEndBattle instance
         */
        ExpeditionEndBattle.create = function create(properties) {
            return new ExpeditionEndBattle(properties);
        };

        /**
         * Encodes the specified ExpeditionEndBattle message. Does not implicitly {@link msgProto.ExpeditionEndBattle.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {msgProto.IExpeditionEndBattle} message ExpeditionEndBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionEndBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            if (message.herosHp != null && message.hasOwnProperty("herosHp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.herosHp);
            return writer;
        };

        /**
         * Encodes the specified ExpeditionEndBattle message, length delimited. Does not implicitly {@link msgProto.ExpeditionEndBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {msgProto.IExpeditionEndBattle} message ExpeditionEndBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionEndBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpeditionEndBattle message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionEndBattle} ExpeditionEndBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionEndBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionEndBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isWin = reader.bool();
                    break;
                case 2:
                    message.herosHp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpeditionEndBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ExpeditionEndBattle} ExpeditionEndBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionEndBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpeditionEndBattle message.
         * @function verify
         * @memberof msgProto.ExpeditionEndBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpeditionEndBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.herosHp != null && message.hasOwnProperty("herosHp"))
                if (!$util.isInteger(message.herosHp))
                    return "herosHp: integer expected";
            return null;
        };

        return ExpeditionEndBattle;
    })();

    msgProto.ExpeditionBuyBlackItem = (function() {

        /**
         * Properties of an ExpeditionBuyBlackItem.
         * @memberof msgProto
         * @interface IExpeditionBuyBlackItem
         * @property {number|null} [itemId] ExpeditionBuyBlackItem itemId
         */

        /**
         * Constructs a new ExpeditionBuyBlackItem.
         * @memberof msgProto
         * @classdesc Represents an ExpeditionBuyBlackItem.
         * @implements IExpeditionBuyBlackItem
         * @constructor
         * @param {msgProto.IExpeditionBuyBlackItem=} [properties] Properties to set
         */
        function ExpeditionBuyBlackItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpeditionBuyBlackItem itemId.
         * @member {number} itemId
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @instance
         */
        ExpeditionBuyBlackItem.prototype.itemId = 0;

        /**
         * Creates a new ExpeditionBuyBlackItem instance using the specified properties.
         * @function create
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {msgProto.IExpeditionBuyBlackItem=} [properties] Properties to set
         * @returns {msgProto.ExpeditionBuyBlackItem} ExpeditionBuyBlackItem instance
         */
        ExpeditionBuyBlackItem.create = function create(properties) {
            return new ExpeditionBuyBlackItem(properties);
        };

        /**
         * Encodes the specified ExpeditionBuyBlackItem message. Does not implicitly {@link msgProto.ExpeditionBuyBlackItem.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {msgProto.IExpeditionBuyBlackItem} message ExpeditionBuyBlackItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionBuyBlackItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };

        /**
         * Encodes the specified ExpeditionBuyBlackItem message, length delimited. Does not implicitly {@link msgProto.ExpeditionBuyBlackItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {msgProto.IExpeditionBuyBlackItem} message ExpeditionBuyBlackItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpeditionBuyBlackItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpeditionBuyBlackItem message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ExpeditionBuyBlackItem} ExpeditionBuyBlackItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionBuyBlackItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ExpeditionBuyBlackItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpeditionBuyBlackItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ExpeditionBuyBlackItem} ExpeditionBuyBlackItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpeditionBuyBlackItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpeditionBuyBlackItem message.
         * @function verify
         * @memberof msgProto.ExpeditionBuyBlackItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpeditionBuyBlackItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            return null;
        };

        return ExpeditionBuyBlackItem;
    })();

    msgProto.UserCreate = (function() {

        /**
         * Properties of a UserCreate.
         * @memberof msgProto
         * @interface IUserCreate
         * @property {string|null} [name] UserCreate name
         * @property {number|null} [heroTempId] UserCreate heroTempId
         * @property {number|null} [sex] UserCreate sex
         * @property {number|null} [serverIndexId] UserCreate serverIndexId
         * @property {string|null} [shareKey] UserCreate shareKey
         */

        /**
         * Constructs a new UserCreate.
         * @memberof msgProto
         * @classdesc Represents a UserCreate.
         * @implements IUserCreate
         * @constructor
         * @param {msgProto.IUserCreate=} [properties] Properties to set
         */
        function UserCreate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCreate name.
         * @member {string} name
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.name = "";

        /**
         * UserCreate heroTempId.
         * @member {number} heroTempId
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.heroTempId = 0;

        /**
         * UserCreate sex.
         * @member {number} sex
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.sex = 0;

        /**
         * UserCreate serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.serverIndexId = 0;

        /**
         * UserCreate shareKey.
         * @member {string} shareKey
         * @memberof msgProto.UserCreate
         * @instance
         */
        UserCreate.prototype.shareKey = "";

        /**
         * Creates a new UserCreate instance using the specified properties.
         * @function create
         * @memberof msgProto.UserCreate
         * @static
         * @param {msgProto.IUserCreate=} [properties] Properties to set
         * @returns {msgProto.UserCreate} UserCreate instance
         */
        UserCreate.create = function create(properties) {
            return new UserCreate(properties);
        };

        /**
         * Encodes the specified UserCreate message. Does not implicitly {@link msgProto.UserCreate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserCreate
         * @static
         * @param {msgProto.IUserCreate} message UserCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroTempId);
            if (message.sex != null && message.hasOwnProperty("sex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sex);
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.serverIndexId);
            if (message.shareKey != null && message.hasOwnProperty("shareKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.shareKey);
            return writer;
        };

        /**
         * Encodes the specified UserCreate message, length delimited. Does not implicitly {@link msgProto.UserCreate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserCreate
         * @static
         * @param {msgProto.IUserCreate} message UserCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserCreate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserCreate} UserCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserCreate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.heroTempId = reader.int32();
                    break;
                case 3:
                    message.sex = reader.int32();
                    break;
                case 4:
                    message.serverIndexId = reader.int32();
                    break;
                case 5:
                    message.shareKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserCreate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserCreate} UserCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserCreate message.
         * @function verify
         * @memberof msgProto.UserCreate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserCreate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.heroTempId != null && message.hasOwnProperty("heroTempId"))
                if (!$util.isInteger(message.heroTempId))
                    return "heroTempId: integer expected";
            if (message.sex != null && message.hasOwnProperty("sex"))
                if (!$util.isInteger(message.sex))
                    return "sex: integer expected";
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                if (!$util.isInteger(message.serverIndexId))
                    return "serverIndexId: integer expected";
            if (message.shareKey != null && message.hasOwnProperty("shareKey"))
                if (!$util.isString(message.shareKey))
                    return "shareKey: string expected";
            return null;
        };

        return UserCreate;
    })();

    msgProto.UserCreateResponse = (function() {

        /**
         * Properties of a UserCreateResponse.
         * @memberof msgProto
         * @interface IUserCreateResponse
         * @property {number|null} [retCode] UserCreateResponse retCode
         */

        /**
         * Constructs a new UserCreateResponse.
         * @memberof msgProto
         * @classdesc Represents a UserCreateResponse.
         * @implements IUserCreateResponse
         * @constructor
         * @param {msgProto.IUserCreateResponse=} [properties] Properties to set
         */
        function UserCreateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserCreateResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.UserCreateResponse
         * @instance
         */
        UserCreateResponse.prototype.retCode = 0;

        /**
         * Creates a new UserCreateResponse instance using the specified properties.
         * @function create
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {msgProto.IUserCreateResponse=} [properties] Properties to set
         * @returns {msgProto.UserCreateResponse} UserCreateResponse instance
         */
        UserCreateResponse.create = function create(properties) {
            return new UserCreateResponse(properties);
        };

        /**
         * Encodes the specified UserCreateResponse message. Does not implicitly {@link msgProto.UserCreateResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {msgProto.IUserCreateResponse} message UserCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            return writer;
        };

        /**
         * Encodes the specified UserCreateResponse message, length delimited. Does not implicitly {@link msgProto.UserCreateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {msgProto.IUserCreateResponse} message UserCreateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserCreateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserCreateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserCreateResponse} UserCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserCreateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserCreateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserCreateResponse} UserCreateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserCreateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserCreateResponse message.
         * @function verify
         * @memberof msgProto.UserCreateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserCreateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                if (!$util.isInteger(message.retCode))
                    return "retCode: integer expected";
            return null;
        };

        return UserCreateResponse;
    })();

    msgProto.GameEnter = (function() {

        /**
         * Properties of a GameEnter.
         * @memberof msgProto
         * @interface IGameEnter
         * @property {number|Long|null} [accId] GameEnter accId
         * @property {string|null} [loginKey] GameEnter loginKey
         * @property {number|null} [serverIndexId] GameEnter serverIndexId
         */

        /**
         * Constructs a new GameEnter.
         * @memberof msgProto
         * @classdesc Represents a GameEnter.
         * @implements IGameEnter
         * @constructor
         * @param {msgProto.IGameEnter=} [properties] Properties to set
         */
        function GameEnter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEnter accId.
         * @member {number|Long} accId
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GameEnter loginKey.
         * @member {string} loginKey
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.loginKey = "";

        /**
         * GameEnter serverIndexId.
         * @member {number} serverIndexId
         * @memberof msgProto.GameEnter
         * @instance
         */
        GameEnter.prototype.serverIndexId = 0;

        /**
         * Creates a new GameEnter instance using the specified properties.
         * @function create
         * @memberof msgProto.GameEnter
         * @static
         * @param {msgProto.IGameEnter=} [properties] Properties to set
         * @returns {msgProto.GameEnter} GameEnter instance
         */
        GameEnter.create = function create(properties) {
            return new GameEnter(properties);
        };

        /**
         * Encodes the specified GameEnter message. Does not implicitly {@link msgProto.GameEnter.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GameEnter
         * @static
         * @param {msgProto.IGameEnter} message GameEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.accId);
            if (message.loginKey != null && message.hasOwnProperty("loginKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.loginKey);
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.serverIndexId);
            return writer;
        };

        /**
         * Encodes the specified GameEnter message, length delimited. Does not implicitly {@link msgProto.GameEnter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GameEnter
         * @static
         * @param {msgProto.IGameEnter} message GameEnter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameEnter message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GameEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GameEnter} GameEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GameEnter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accId = reader.int64();
                    break;
                case 2:
                    message.loginKey = reader.string();
                    break;
                case 3:
                    message.serverIndexId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameEnter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GameEnter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GameEnter} GameEnter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameEnter message.
         * @function verify
         * @memberof msgProto.GameEnter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameEnter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (!$util.isInteger(message.accId) && !(message.accId && $util.isInteger(message.accId.low) && $util.isInteger(message.accId.high)))
                    return "accId: integer|Long expected";
            if (message.loginKey != null && message.hasOwnProperty("loginKey"))
                if (!$util.isString(message.loginKey))
                    return "loginKey: string expected";
            if (message.serverIndexId != null && message.hasOwnProperty("serverIndexId"))
                if (!$util.isInteger(message.serverIndexId))
                    return "serverIndexId: integer expected";
            return null;
        };

        return GameEnter;
    })();

    msgProto.GameEnterResponse = (function() {

        /**
         * Properties of a GameEnterResponse.
         * @memberof msgProto
         * @interface IGameEnterResponse
         * @property {number|null} [retCode] GameEnterResponse retCode
         * @property {string|null} [nickName] GameEnterResponse nickName
         * @property {number|Long|null} [userId] GameEnterResponse userId
         */

        /**
         * Constructs a new GameEnterResponse.
         * @memberof msgProto
         * @classdesc Represents a GameEnterResponse.
         * @implements IGameEnterResponse
         * @constructor
         * @param {msgProto.IGameEnterResponse=} [properties] Properties to set
         */
        function GameEnterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEnterResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.retCode = 0;

        /**
         * GameEnterResponse nickName.
         * @member {string} nickName
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.nickName = "";

        /**
         * GameEnterResponse userId.
         * @member {number|Long} userId
         * @memberof msgProto.GameEnterResponse
         * @instance
         */
        GameEnterResponse.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GameEnterResponse instance using the specified properties.
         * @function create
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {msgProto.IGameEnterResponse=} [properties] Properties to set
         * @returns {msgProto.GameEnterResponse} GameEnterResponse instance
         */
        GameEnterResponse.create = function create(properties) {
            return new GameEnterResponse(properties);
        };

        /**
         * Encodes the specified GameEnterResponse message. Does not implicitly {@link msgProto.GameEnterResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {msgProto.IGameEnterResponse} message GameEnterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickName);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.userId);
            return writer;
        };

        /**
         * Encodes the specified GameEnterResponse message, length delimited. Does not implicitly {@link msgProto.GameEnterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {msgProto.IGameEnterResponse} message GameEnterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEnterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameEnterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.GameEnterResponse} GameEnterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.GameEnterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.nickName = reader.string();
                    break;
                case 3:
                    message.userId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameEnterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.GameEnterResponse} GameEnterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEnterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameEnterResponse message.
         * @function verify
         * @memberof msgProto.GameEnterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameEnterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                if (!$util.isInteger(message.retCode))
                    return "retCode: integer expected";
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                if (!$util.isString(message.nickName))
                    return "nickName: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            return null;
        };

        return GameEnterResponse;
    })();

    msgProto.AccountGetThirdUserInfo = (function() {

        /**
         * Properties of an AccountGetThirdUserInfo.
         * @memberof msgProto
         * @interface IAccountGetThirdUserInfo
         */

        /**
         * Constructs a new AccountGetThirdUserInfo.
         * @memberof msgProto
         * @classdesc Represents an AccountGetThirdUserInfo.
         * @implements IAccountGetThirdUserInfo
         * @constructor
         * @param {msgProto.IAccountGetThirdUserInfo=} [properties] Properties to set
         */
        function AccountGetThirdUserInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AccountGetThirdUserInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {msgProto.IAccountGetThirdUserInfo=} [properties] Properties to set
         * @returns {msgProto.AccountGetThirdUserInfo} AccountGetThirdUserInfo instance
         */
        AccountGetThirdUserInfo.create = function create(properties) {
            return new AccountGetThirdUserInfo(properties);
        };

        /**
         * Encodes the specified AccountGetThirdUserInfo message. Does not implicitly {@link msgProto.AccountGetThirdUserInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {msgProto.IAccountGetThirdUserInfo} message AccountGetThirdUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountGetThirdUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AccountGetThirdUserInfo message, length delimited. Does not implicitly {@link msgProto.AccountGetThirdUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {msgProto.IAccountGetThirdUserInfo} message AccountGetThirdUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountGetThirdUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountGetThirdUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountGetThirdUserInfo} AccountGetThirdUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountGetThirdUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountGetThirdUserInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountGetThirdUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AccountGetThirdUserInfo} AccountGetThirdUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountGetThirdUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountGetThirdUserInfo message.
         * @function verify
         * @memberof msgProto.AccountGetThirdUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountGetThirdUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AccountGetThirdUserInfo;
    })();

    msgProto.NetConnect = (function() {

        /**
         * Properties of a NetConnect.
         * @memberof msgProto
         * @interface INetConnect
         */

        /**
         * Constructs a new NetConnect.
         * @memberof msgProto
         * @classdesc Represents a NetConnect.
         * @implements INetConnect
         * @constructor
         * @param {msgProto.INetConnect=} [properties] Properties to set
         */
        function NetConnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NetConnect instance using the specified properties.
         * @function create
         * @memberof msgProto.NetConnect
         * @static
         * @param {msgProto.INetConnect=} [properties] Properties to set
         * @returns {msgProto.NetConnect} NetConnect instance
         */
        NetConnect.create = function create(properties) {
            return new NetConnect(properties);
        };

        /**
         * Encodes the specified NetConnect message. Does not implicitly {@link msgProto.NetConnect.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetConnect
         * @static
         * @param {msgProto.INetConnect} message NetConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NetConnect message, length delimited. Does not implicitly {@link msgProto.NetConnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.NetConnect
         * @static
         * @param {msgProto.INetConnect} message NetConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetConnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetConnect message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetConnect} NetConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetConnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetConnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.NetConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.NetConnect} NetConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetConnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetConnect message.
         * @function verify
         * @memberof msgProto.NetConnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetConnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return NetConnect;
    })();

    msgProto.NetDisconnect = (function() {

        /**
         * Properties of a NetDisconnect.
         * @memberof msgProto
         * @interface INetDisconnect
         * @property {string|null} [sessionId] NetDisconnect sessionId
         */

        /**
         * Constructs a new NetDisconnect.
         * @memberof msgProto
         * @classdesc Represents a NetDisconnect.
         * @implements INetDisconnect
         * @constructor
         * @param {msgProto.INetDisconnect=} [properties] Properties to set
         */
        function NetDisconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetDisconnect sessionId.
         * @member {string} sessionId
         * @memberof msgProto.NetDisconnect
         * @instance
         */
        NetDisconnect.prototype.sessionId = "";

        /**
         * Creates a new NetDisconnect instance using the specified properties.
         * @function create
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {msgProto.INetDisconnect=} [properties] Properties to set
         * @returns {msgProto.NetDisconnect} NetDisconnect instance
         */
        NetDisconnect.create = function create(properties) {
            return new NetDisconnect(properties);
        };

        /**
         * Encodes the specified NetDisconnect message. Does not implicitly {@link msgProto.NetDisconnect.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {msgProto.INetDisconnect} message NetDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetDisconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
            return writer;
        };

        /**
         * Encodes the specified NetDisconnect message, length delimited. Does not implicitly {@link msgProto.NetDisconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {msgProto.INetDisconnect} message NetDisconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetDisconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetDisconnect message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetDisconnect} NetDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetDisconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetDisconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetDisconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.NetDisconnect} NetDisconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetDisconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetDisconnect message.
         * @function verify
         * @memberof msgProto.NetDisconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetDisconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isString(message.sessionId))
                    return "sessionId: string expected";
            return null;
        };

        return NetDisconnect;
    })();

    msgProto.NetGetServerDate = (function() {

        /**
         * Properties of a NetGetServerDate.
         * @memberof msgProto
         * @interface INetGetServerDate
         */

        /**
         * Constructs a new NetGetServerDate.
         * @memberof msgProto
         * @classdesc Represents a NetGetServerDate.
         * @implements INetGetServerDate
         * @constructor
         * @param {msgProto.INetGetServerDate=} [properties] Properties to set
         */
        function NetGetServerDate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NetGetServerDate instance using the specified properties.
         * @function create
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {msgProto.INetGetServerDate=} [properties] Properties to set
         * @returns {msgProto.NetGetServerDate} NetGetServerDate instance
         */
        NetGetServerDate.create = function create(properties) {
            return new NetGetServerDate(properties);
        };

        /**
         * Encodes the specified NetGetServerDate message. Does not implicitly {@link msgProto.NetGetServerDate.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {msgProto.INetGetServerDate} message NetGetServerDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetGetServerDate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NetGetServerDate message, length delimited. Does not implicitly {@link msgProto.NetGetServerDate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {msgProto.INetGetServerDate} message NetGetServerDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetGetServerDate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetGetServerDate message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NetGetServerDate} NetGetServerDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetGetServerDate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NetGetServerDate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetGetServerDate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.NetGetServerDate} NetGetServerDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetGetServerDate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetGetServerDate message.
         * @function verify
         * @memberof msgProto.NetGetServerDate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetGetServerDate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return NetGetServerDate;
    })();

    msgProto.AccountLogin = (function() {

        /**
         * Properties of an AccountLogin.
         * @memberof msgProto
         * @interface IAccountLogin
         * @property {string|null} [account] AccountLogin account
         * @property {string|null} [pwd] AccountLogin pwd
         * @property {number|null} [channelId] AccountLogin channelId
         */

        /**
         * Constructs a new AccountLogin.
         * @memberof msgProto
         * @classdesc Represents an AccountLogin.
         * @implements IAccountLogin
         * @constructor
         * @param {msgProto.IAccountLogin=} [properties] Properties to set
         */
        function AccountLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountLogin account.
         * @member {string} account
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.account = "";

        /**
         * AccountLogin pwd.
         * @member {string} pwd
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.pwd = "";

        /**
         * AccountLogin channelId.
         * @member {number} channelId
         * @memberof msgProto.AccountLogin
         * @instance
         */
        AccountLogin.prototype.channelId = 0;

        /**
         * Creates a new AccountLogin instance using the specified properties.
         * @function create
         * @memberof msgProto.AccountLogin
         * @static
         * @param {msgProto.IAccountLogin=} [properties] Properties to set
         * @returns {msgProto.AccountLogin} AccountLogin instance
         */
        AccountLogin.create = function create(properties) {
            return new AccountLogin(properties);
        };

        /**
         * Encodes the specified AccountLogin message. Does not implicitly {@link msgProto.AccountLogin.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountLogin
         * @static
         * @param {msgProto.IAccountLogin} message AccountLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelId);
            return writer;
        };

        /**
         * Encodes the specified AccountLogin message, length delimited. Does not implicitly {@link msgProto.AccountLogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AccountLogin
         * @static
         * @param {msgProto.IAccountLogin} message AccountLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountLogin message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountLogin} AccountLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.channelId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountLogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AccountLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AccountLogin} AccountLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountLogin message.
         * @function verify
         * @memberof msgProto.AccountLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountLogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                if (!$util.isString(message.pwd))
                    return "pwd: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId))
                    return "channelId: integer expected";
            return null;
        };

        return AccountLogin;
    })();

    msgProto.LoginResponse = (function() {

        /**
         * Properties of a LoginResponse.
         * @memberof msgProto
         * @interface ILoginResponse
         * @property {number|null} [retCode] LoginResponse retCode
         * @property {number|Long|null} [accId] LoginResponse accId
         * @property {string|null} [account] LoginResponse account
         * @property {string|null} [Email] LoginResponse Email
         * @property {string|null} [DeviceId] LoginResponse DeviceId
         * @property {number|null} [Status] LoginResponse Status
         * @property {string|null} [SdkData] LoginResponse SdkData
         * @property {string|null} [ExData] LoginResponse ExData
         * @property {number|null} [LoginCount] LoginResponse LoginCount
         * @property {string|null} [LoginKey] LoginResponse LoginKey
         * @property {string|null} [UserServers] LoginResponse UserServers
         * @property {string|null} [RechargeCom] LoginResponse RechargeCom
         * @property {string|null} [SdkChannelId] LoginResponse SdkChannelId
         * @property {number|Long|null} [BendExpireAt] LoginResponse BendExpireAt
         * @property {number|null} [BendType] LoginResponse BendType
         */

        /**
         * Constructs a new LoginResponse.
         * @memberof msgProto
         * @classdesc Represents a LoginResponse.
         * @implements ILoginResponse
         * @constructor
         * @param {msgProto.ILoginResponse=} [properties] Properties to set
         */
        function LoginResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.retCode = 0;

        /**
         * LoginResponse accId.
         * @member {number|Long} accId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginResponse account.
         * @member {string} account
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.account = "";

        /**
         * LoginResponse Email.
         * @member {string} Email
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.Email = "";

        /**
         * LoginResponse DeviceId.
         * @member {string} DeviceId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.DeviceId = "";

        /**
         * LoginResponse Status.
         * @member {number} Status
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.Status = 0;

        /**
         * LoginResponse SdkData.
         * @member {string} SdkData
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.SdkData = "";

        /**
         * LoginResponse ExData.
         * @member {string} ExData
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.ExData = "";

        /**
         * LoginResponse LoginCount.
         * @member {number} LoginCount
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.LoginCount = 0;

        /**
         * LoginResponse LoginKey.
         * @member {string} LoginKey
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.LoginKey = "";

        /**
         * LoginResponse UserServers.
         * @member {string} UserServers
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.UserServers = "";

        /**
         * LoginResponse RechargeCom.
         * @member {string} RechargeCom
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.RechargeCom = "";

        /**
         * LoginResponse SdkChannelId.
         * @member {string} SdkChannelId
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.SdkChannelId = "";

        /**
         * LoginResponse BendExpireAt.
         * @member {number|Long} BendExpireAt
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.BendExpireAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginResponse BendType.
         * @member {number} BendType
         * @memberof msgProto.LoginResponse
         * @instance
         */
        LoginResponse.prototype.BendType = 0;

        /**
         * Creates a new LoginResponse instance using the specified properties.
         * @function create
         * @memberof msgProto.LoginResponse
         * @static
         * @param {msgProto.ILoginResponse=} [properties] Properties to set
         * @returns {msgProto.LoginResponse} LoginResponse instance
         */
        LoginResponse.create = function create(properties) {
            return new LoginResponse(properties);
        };

        /**
         * Encodes the specified LoginResponse message. Does not implicitly {@link msgProto.LoginResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginResponse
         * @static
         * @param {msgProto.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accId);
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.account);
            if (message.Email != null && message.hasOwnProperty("Email"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Email);
            if (message.DeviceId != null && message.hasOwnProperty("DeviceId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.DeviceId);
            if (message.Status != null && message.hasOwnProperty("Status"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Status);
            if (message.SdkData != null && message.hasOwnProperty("SdkData"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.SdkData);
            if (message.ExData != null && message.hasOwnProperty("ExData"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.ExData);
            if (message.LoginCount != null && message.hasOwnProperty("LoginCount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.LoginCount);
            if (message.LoginKey != null && message.hasOwnProperty("LoginKey"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.LoginKey);
            if (message.UserServers != null && message.hasOwnProperty("UserServers"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.UserServers);
            if (message.RechargeCom != null && message.hasOwnProperty("RechargeCom"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.RechargeCom);
            if (message.SdkChannelId != null && message.hasOwnProperty("SdkChannelId"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.SdkChannelId);
            if (message.BendExpireAt != null && message.hasOwnProperty("BendExpireAt"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.BendExpireAt);
            if (message.BendType != null && message.hasOwnProperty("BendType"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.BendType);
            return writer;
        };

        /**
         * Encodes the specified LoginResponse message, length delimited. Does not implicitly {@link msgProto.LoginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LoginResponse
         * @static
         * @param {msgProto.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.accId = reader.int64();
                    break;
                case 3:
                    message.account = reader.string();
                    break;
                case 4:
                    message.Email = reader.string();
                    break;
                case 5:
                    message.DeviceId = reader.string();
                    break;
                case 6:
                    message.Status = reader.int32();
                    break;
                case 8:
                    message.SdkData = reader.string();
                    break;
                case 9:
                    message.ExData = reader.string();
                    break;
                case 10:
                    message.LoginCount = reader.int32();
                    break;
                case 11:
                    message.LoginKey = reader.string();
                    break;
                case 12:
                    message.UserServers = reader.string();
                    break;
                case 13:
                    message.RechargeCom = reader.string();
                    break;
                case 14:
                    message.SdkChannelId = reader.string();
                    break;
                case 15:
                    message.BendExpireAt = reader.int64();
                    break;
                case 16:
                    message.BendType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginResponse message.
         * @function verify
         * @memberof msgProto.LoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                if (!$util.isInteger(message.retCode))
                    return "retCode: integer expected";
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (!$util.isInteger(message.accId) && !(message.accId && $util.isInteger(message.accId.low) && $util.isInteger(message.accId.high)))
                    return "accId: integer|Long expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.Email != null && message.hasOwnProperty("Email"))
                if (!$util.isString(message.Email))
                    return "Email: string expected";
            if (message.DeviceId != null && message.hasOwnProperty("DeviceId"))
                if (!$util.isString(message.DeviceId))
                    return "DeviceId: string expected";
            if (message.Status != null && message.hasOwnProperty("Status"))
                if (!$util.isInteger(message.Status))
                    return "Status: integer expected";
            if (message.SdkData != null && message.hasOwnProperty("SdkData"))
                if (!$util.isString(message.SdkData))
                    return "SdkData: string expected";
            if (message.ExData != null && message.hasOwnProperty("ExData"))
                if (!$util.isString(message.ExData))
                    return "ExData: string expected";
            if (message.LoginCount != null && message.hasOwnProperty("LoginCount"))
                if (!$util.isInteger(message.LoginCount))
                    return "LoginCount: integer expected";
            if (message.LoginKey != null && message.hasOwnProperty("LoginKey"))
                if (!$util.isString(message.LoginKey))
                    return "LoginKey: string expected";
            if (message.UserServers != null && message.hasOwnProperty("UserServers"))
                if (!$util.isString(message.UserServers))
                    return "UserServers: string expected";
            if (message.RechargeCom != null && message.hasOwnProperty("RechargeCom"))
                if (!$util.isString(message.RechargeCom))
                    return "RechargeCom: string expected";
            if (message.SdkChannelId != null && message.hasOwnProperty("SdkChannelId"))
                if (!$util.isString(message.SdkChannelId))
                    return "SdkChannelId: string expected";
            if (message.BendExpireAt != null && message.hasOwnProperty("BendExpireAt"))
                if (!$util.isInteger(message.BendExpireAt) && !(message.BendExpireAt && $util.isInteger(message.BendExpireAt.low) && $util.isInteger(message.BendExpireAt.high)))
                    return "BendExpireAt: integer|Long expected";
            if (message.BendType != null && message.hasOwnProperty("BendType"))
                if (!$util.isInteger(message.BendType))
                    return "BendType: integer expected";
            return null;
        };

        return LoginResponse;
    })();

    msgProto.AccountLoginBySdk = (function() {

        /**
         * Properties of an AccountLoginBySdk.
         * @memberof msgProto
         * @interface IAccountLoginBySdk
         * @property {string|null} [channelId] AccountLoginBySdk channelId
         * @property {string|null} [sdkData] AccountLoginBySdk sdkData
         * @property {string|null} [deviceId] AccountLoginBySdk deviceId
         */

        /**
         * Constructs a new AccountLoginBySdk.
         * @memberof msgProto
         * @classdesc Represents an AccountLoginBySdk.
         * @implements IAccountLoginBySdk
         * @constructor
         * @param {msgProto.IAccountLoginBySdk=} [properties] Properties to set
         */
        function AccountLoginBySdk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountLoginBySdk channelId.
         * @member {string} channelId
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.channelId = "";

        /**
         * AccountLoginBySdk sdkData.
         * @member {string} sdkData
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.sdkData = "";

        /**
         * AccountLoginBySdk deviceId.
         * @member {string} deviceId
         * @memberof msgProto.AccountLoginBySdk
         * @instance
         */
        AccountLoginBySdk.prototype.deviceId = "";

        /**
         * Creates a new AccountLoginBySdk instance using the specified properties.
         * @function create
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {msgProto.IAccountLoginBySdk=} [properties] Properties to set
         * @returns {msgProto.AccountLoginBySdk} AccountLoginBySdk instance
         */
        AccountLoginBySdk.create = function create(properties) {
            return new AccountLoginBySdk(properties);
        };

        /**
         * Encodes the specified AccountLoginBySdk message. Does not implicitly {@link msgProto.AccountLoginBySdk.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {msgProto.IAccountLoginBySdk} message AccountLoginBySdk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginBySdk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
            if (message.sdkData != null && message.hasOwnProperty("sdkData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdkData);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceId);
            return writer;
        };

        /**
         * Encodes the specified AccountLoginBySdk message, length delimited. Does not implicitly {@link msgProto.AccountLoginBySdk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {msgProto.IAccountLoginBySdk} message AccountLoginBySdk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginBySdk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountLoginBySdk message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountLoginBySdk} AccountLoginBySdk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginBySdk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountLoginBySdk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.string();
                    break;
                case 2:
                    message.sdkData = reader.string();
                    break;
                case 3:
                    message.deviceId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountLoginBySdk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AccountLoginBySdk} AccountLoginBySdk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginBySdk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountLoginBySdk message.
         * @function verify
         * @memberof msgProto.AccountLoginBySdk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountLoginBySdk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            if (message.sdkData != null && message.hasOwnProperty("sdkData"))
                if (!$util.isString(message.sdkData))
                    return "sdkData: string expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            return null;
        };

        return AccountLoginBySdk;
    })();

    msgProto.AccountRegister = (function() {

        /**
         * Properties of an AccountRegister.
         * @memberof msgProto
         * @interface IAccountRegister
         * @property {string|null} [account] AccountRegister account
         * @property {string|null} [pwd] AccountRegister pwd
         * @property {number|null} [channelId] AccountRegister channelId
         * @property {string|null} [deviceId] AccountRegister deviceId
         */

        /**
         * Constructs a new AccountRegister.
         * @memberof msgProto
         * @classdesc Represents an AccountRegister.
         * @implements IAccountRegister
         * @constructor
         * @param {msgProto.IAccountRegister=} [properties] Properties to set
         */
        function AccountRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountRegister account.
         * @member {string} account
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.account = "";

        /**
         * AccountRegister pwd.
         * @member {string} pwd
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.pwd = "";

        /**
         * AccountRegister channelId.
         * @member {number} channelId
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.channelId = 0;

        /**
         * AccountRegister deviceId.
         * @member {string} deviceId
         * @memberof msgProto.AccountRegister
         * @instance
         */
        AccountRegister.prototype.deviceId = "";

        /**
         * Creates a new AccountRegister instance using the specified properties.
         * @function create
         * @memberof msgProto.AccountRegister
         * @static
         * @param {msgProto.IAccountRegister=} [properties] Properties to set
         * @returns {msgProto.AccountRegister} AccountRegister instance
         */
        AccountRegister.create = function create(properties) {
            return new AccountRegister(properties);
        };

        /**
         * Encodes the specified AccountRegister message. Does not implicitly {@link msgProto.AccountRegister.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountRegister
         * @static
         * @param {msgProto.IAccountRegister} message AccountRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channelId);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceId);
            return writer;
        };

        /**
         * Encodes the specified AccountRegister message, length delimited. Does not implicitly {@link msgProto.AccountRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AccountRegister
         * @static
         * @param {msgProto.IAccountRegister} message AccountRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountRegister.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountRegister message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountRegister} AccountRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.channelId = reader.int32();
                    break;
                case 4:
                    message.deviceId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AccountRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AccountRegister} AccountRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountRegister.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountRegister message.
         * @function verify
         * @memberof msgProto.AccountRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountRegister.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                if (!$util.isString(message.pwd))
                    return "pwd: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId))
                    return "channelId: integer expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            return null;
        };

        return AccountRegister;
    })();

    msgProto.NoticeGetNewOne = (function() {

        /**
         * Properties of a NoticeGetNewOne.
         * @memberof msgProto
         * @interface INoticeGetNewOne
         */

        /**
         * Constructs a new NoticeGetNewOne.
         * @memberof msgProto
         * @classdesc Represents a NoticeGetNewOne.
         * @implements INoticeGetNewOne
         * @constructor
         * @param {msgProto.INoticeGetNewOne=} [properties] Properties to set
         */
        function NoticeGetNewOne(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NoticeGetNewOne instance using the specified properties.
         * @function create
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {msgProto.INoticeGetNewOne=} [properties] Properties to set
         * @returns {msgProto.NoticeGetNewOne} NoticeGetNewOne instance
         */
        NoticeGetNewOne.create = function create(properties) {
            return new NoticeGetNewOne(properties);
        };

        /**
         * Encodes the specified NoticeGetNewOne message. Does not implicitly {@link msgProto.NoticeGetNewOne.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {msgProto.INoticeGetNewOne} message NoticeGetNewOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetNewOne.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NoticeGetNewOne message, length delimited. Does not implicitly {@link msgProto.NoticeGetNewOne.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {msgProto.INoticeGetNewOne} message NoticeGetNewOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetNewOne.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeGetNewOne message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NoticeGetNewOne} NoticeGetNewOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetNewOne.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NoticeGetNewOne();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeGetNewOne message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.NoticeGetNewOne} NoticeGetNewOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetNewOne.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeGetNewOne message.
         * @function verify
         * @memberof msgProto.NoticeGetNewOne
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeGetNewOne.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return NoticeGetNewOne;
    })();

    msgProto.NoticeGetList = (function() {

        /**
         * Properties of a NoticeGetList.
         * @memberof msgProto
         * @interface INoticeGetList
         */

        /**
         * Constructs a new NoticeGetList.
         * @memberof msgProto
         * @classdesc Represents a NoticeGetList.
         * @implements INoticeGetList
         * @constructor
         * @param {msgProto.INoticeGetList=} [properties] Properties to set
         */
        function NoticeGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NoticeGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {msgProto.INoticeGetList=} [properties] Properties to set
         * @returns {msgProto.NoticeGetList} NoticeGetList instance
         */
        NoticeGetList.create = function create(properties) {
            return new NoticeGetList(properties);
        };

        /**
         * Encodes the specified NoticeGetList message. Does not implicitly {@link msgProto.NoticeGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {msgProto.INoticeGetList} message NoticeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NoticeGetList message, length delimited. Does not implicitly {@link msgProto.NoticeGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {msgProto.INoticeGetList} message NoticeGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.NoticeGetList} NoticeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.NoticeGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.NoticeGetList} NoticeGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeGetList message.
         * @function verify
         * @memberof msgProto.NoticeGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return NoticeGetList;
    })();

    msgProto.ProtocolContentGetInfo = (function() {

        /**
         * Properties of a ProtocolContentGetInfo.
         * @memberof msgProto
         * @interface IProtocolContentGetInfo
         */

        /**
         * Constructs a new ProtocolContentGetInfo.
         * @memberof msgProto
         * @classdesc Represents a ProtocolContentGetInfo.
         * @implements IProtocolContentGetInfo
         * @constructor
         * @param {msgProto.IProtocolContentGetInfo=} [properties] Properties to set
         */
        function ProtocolContentGetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ProtocolContentGetInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {msgProto.IProtocolContentGetInfo=} [properties] Properties to set
         * @returns {msgProto.ProtocolContentGetInfo} ProtocolContentGetInfo instance
         */
        ProtocolContentGetInfo.create = function create(properties) {
            return new ProtocolContentGetInfo(properties);
        };

        /**
         * Encodes the specified ProtocolContentGetInfo message. Does not implicitly {@link msgProto.ProtocolContentGetInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {msgProto.IProtocolContentGetInfo} message ProtocolContentGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolContentGetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ProtocolContentGetInfo message, length delimited. Does not implicitly {@link msgProto.ProtocolContentGetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {msgProto.IProtocolContentGetInfo} message ProtocolContentGetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolContentGetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtocolContentGetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ProtocolContentGetInfo} ProtocolContentGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolContentGetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ProtocolContentGetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtocolContentGetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ProtocolContentGetInfo} ProtocolContentGetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolContentGetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtocolContentGetInfo message.
         * @function verify
         * @memberof msgProto.ProtocolContentGetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtocolContentGetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return ProtocolContentGetInfo;
    })();

    msgProto.SvrListGet = (function() {

        /**
         * Properties of a SvrListGet.
         * @memberof msgProto
         * @interface ISvrListGet
         * @property {boolean|null} [isTest] SvrListGet isTest
         */

        /**
         * Constructs a new SvrListGet.
         * @memberof msgProto
         * @classdesc Represents a SvrListGet.
         * @implements ISvrListGet
         * @constructor
         * @param {msgProto.ISvrListGet=} [properties] Properties to set
         */
        function SvrListGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrListGet isTest.
         * @member {boolean} isTest
         * @memberof msgProto.SvrListGet
         * @instance
         */
        SvrListGet.prototype.isTest = false;

        /**
         * Creates a new SvrListGet instance using the specified properties.
         * @function create
         * @memberof msgProto.SvrListGet
         * @static
         * @param {msgProto.ISvrListGet=} [properties] Properties to set
         * @returns {msgProto.SvrListGet} SvrListGet instance
         */
        SvrListGet.create = function create(properties) {
            return new SvrListGet(properties);
        };

        /**
         * Encodes the specified SvrListGet message. Does not implicitly {@link msgProto.SvrListGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrListGet
         * @static
         * @param {msgProto.ISvrListGet} message SvrListGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isTest);
            return writer;
        };

        /**
         * Encodes the specified SvrListGet message, length delimited. Does not implicitly {@link msgProto.SvrListGet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SvrListGet
         * @static
         * @param {msgProto.ISvrListGet} message SvrListGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListGet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SvrListGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrListGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrListGet} SvrListGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrListGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isTest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SvrListGet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SvrListGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SvrListGet} SvrListGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListGet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SvrListGet message.
         * @function verify
         * @memberof msgProto.SvrListGet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SvrListGet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                if (typeof message.isTest !== "boolean")
                    return "isTest: boolean expected";
            return null;
        };

        return SvrListGet;
    })();

    msgProto.SvrInfoGet = (function() {

        /**
         * Properties of a SvrInfoGet.
         * @memberof msgProto
         * @interface ISvrInfoGet
         * @property {number|null} [svrId] SvrInfoGet svrId
         */

        /**
         * Constructs a new SvrInfoGet.
         * @memberof msgProto
         * @classdesc Represents a SvrInfoGet.
         * @implements ISvrInfoGet
         * @constructor
         * @param {msgProto.ISvrInfoGet=} [properties] Properties to set
         */
        function SvrInfoGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrInfoGet svrId.
         * @member {number} svrId
         * @memberof msgProto.SvrInfoGet
         * @instance
         */
        SvrInfoGet.prototype.svrId = 0;

        /**
         * Creates a new SvrInfoGet instance using the specified properties.
         * @function create
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {msgProto.ISvrInfoGet=} [properties] Properties to set
         * @returns {msgProto.SvrInfoGet} SvrInfoGet instance
         */
        SvrInfoGet.create = function create(properties) {
            return new SvrInfoGet(properties);
        };

        /**
         * Encodes the specified SvrInfoGet message. Does not implicitly {@link msgProto.SvrInfoGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {msgProto.ISvrInfoGet} message SvrInfoGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrInfoGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.svrId != null && message.hasOwnProperty("svrId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.svrId);
            return writer;
        };

        /**
         * Encodes the specified SvrInfoGet message, length delimited. Does not implicitly {@link msgProto.SvrInfoGet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {msgProto.ISvrInfoGet} message SvrInfoGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrInfoGet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SvrInfoGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrInfoGet} SvrInfoGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrInfoGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrInfoGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.svrId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SvrInfoGet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SvrInfoGet} SvrInfoGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrInfoGet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SvrInfoGet message.
         * @function verify
         * @memberof msgProto.SvrInfoGet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SvrInfoGet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.svrId != null && message.hasOwnProperty("svrId"))
                if (!$util.isInteger(message.svrId))
                    return "svrId: integer expected";
            return null;
        };

        return SvrInfoGet;
    })();

    msgProto.PbSvrInfo = (function() {

        /**
         * Properties of a PbSvrInfo.
         * @memberof msgProto
         * @interface IPbSvrInfo
         * @property {number|null} [Id] PbSvrInfo Id
         * @property {string|null} [Name] PbSvrInfo Name
         * @property {string|null} [MergerName] 服务器名称 *
         * @property {string|null} [Area] PbSvrInfo Area
         * @property {string|null} [Host] PbSvrInfo Host
         * @property {string|null} [Port] PbSvrInfo Port
         * @property {number|null} [IsNew] PbSvrInfo IsNew
         * @property {number|null} [Status] PbSvrInfo Status
         * @property {number|null} [Sort] PbSvrInfo Sort
         * @property {string|null} [AppId] PbSvrInfo AppId
         * @property {number|null} [ServerId] PbSvrInfo ServerId
         * @property {number|null} [IndexId] PbSvrInfo IndexId
         * @property {number|null} [IsClose] PbSvrInfo IsClose
         * @property {string|null} [CloseExplain] 是否维护 *
         * @property {number|Long|null} [ServerDate] 维护说明 *
         */

        /**
         * Constructs a new PbSvrInfo.
         * @memberof msgProto
         * @classdesc Represents a PbSvrInfo.
         * @implements IPbSvrInfo
         * @constructor
         * @param {msgProto.IPbSvrInfo=} [properties] Properties to set
         */
        function PbSvrInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PbSvrInfo Id.
         * @member {number} Id
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Id = 0;

        /**
         * PbSvrInfo Name.
         * @member {string} Name
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Name = "";

        /**
         * 服务器名称 *
         * @member {string} MergerName
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.MergerName = "";

        /**
         * PbSvrInfo Area.
         * @member {string} Area
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Area = "";

        /**
         * PbSvrInfo Host.
         * @member {string} Host
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Host = "";

        /**
         * PbSvrInfo Port.
         * @member {string} Port
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Port = "";

        /**
         * PbSvrInfo IsNew.
         * @member {number} IsNew
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IsNew = 0;

        /**
         * PbSvrInfo Status.
         * @member {number} Status
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Status = 0;

        /**
         * PbSvrInfo Sort.
         * @member {number} Sort
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.Sort = 0;

        /**
         * PbSvrInfo AppId.
         * @member {string} AppId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.AppId = "";

        /**
         * PbSvrInfo ServerId.
         * @member {number} ServerId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.ServerId = 0;

        /**
         * PbSvrInfo IndexId.
         * @member {number} IndexId
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IndexId = 0;

        /**
         * PbSvrInfo IsClose.
         * @member {number} IsClose
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.IsClose = 0;

        /**
         * 是否维护 *
         * @member {string} CloseExplain
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.CloseExplain = "";

        /**
         * 维护说明 *
         * @member {number|Long} ServerDate
         * @memberof msgProto.PbSvrInfo
         * @instance
         */
        PbSvrInfo.prototype.ServerDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PbSvrInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {msgProto.IPbSvrInfo=} [properties] Properties to set
         * @returns {msgProto.PbSvrInfo} PbSvrInfo instance
         */
        PbSvrInfo.create = function create(properties) {
            return new PbSvrInfo(properties);
        };

        /**
         * Encodes the specified PbSvrInfo message. Does not implicitly {@link msgProto.PbSvrInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {msgProto.IPbSvrInfo} message PbSvrInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSvrInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Id != null && message.hasOwnProperty("Id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Id);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
            if (message.MergerName != null && message.hasOwnProperty("MergerName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.MergerName);
            if (message.Area != null && message.hasOwnProperty("Area"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Area);
            if (message.Host != null && message.hasOwnProperty("Host"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Host);
            if (message.Port != null && message.hasOwnProperty("Port"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Port);
            if (message.IsNew != null && message.hasOwnProperty("IsNew"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.IsNew);
            if (message.Status != null && message.hasOwnProperty("Status"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Status);
            if (message.Sort != null && message.hasOwnProperty("Sort"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Sort);
            if (message.AppId != null && message.hasOwnProperty("AppId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.AppId);
            if (message.ServerId != null && message.hasOwnProperty("ServerId"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.ServerId);
            if (message.IndexId != null && message.hasOwnProperty("IndexId"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.IndexId);
            if (message.IsClose != null && message.hasOwnProperty("IsClose"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.IsClose);
            if (message.CloseExplain != null && message.hasOwnProperty("CloseExplain"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.CloseExplain);
            if (message.ServerDate != null && message.hasOwnProperty("ServerDate"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.ServerDate);
            return writer;
        };

        /**
         * Encodes the specified PbSvrInfo message, length delimited. Does not implicitly {@link msgProto.PbSvrInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {msgProto.IPbSvrInfo} message PbSvrInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PbSvrInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PbSvrInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PbSvrInfo} PbSvrInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSvrInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PbSvrInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.Id = reader.int32();
                    break;
                case 3:
                    message.Name = reader.string();
                    break;
                case 4:
                    message.MergerName = reader.string();
                    break;
                case 5:
                    message.Area = reader.string();
                    break;
                case 6:
                    message.Host = reader.string();
                    break;
                case 7:
                    message.Port = reader.string();
                    break;
                case 8:
                    message.IsNew = reader.int32();
                    break;
                case 9:
                    message.Status = reader.int32();
                    break;
                case 10:
                    message.Sort = reader.int32();
                    break;
                case 11:
                    message.AppId = reader.string();
                    break;
                case 12:
                    message.ServerId = reader.int32();
                    break;
                case 13:
                    message.IndexId = reader.int32();
                    break;
                case 14:
                    message.IsClose = reader.int32();
                    break;
                case 15:
                    message.CloseExplain = reader.string();
                    break;
                case 16:
                    message.ServerDate = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PbSvrInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PbSvrInfo} PbSvrInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PbSvrInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PbSvrInfo message.
         * @function verify
         * @memberof msgProto.PbSvrInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PbSvrInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Id != null && message.hasOwnProperty("Id"))
                if (!$util.isInteger(message.Id))
                    return "Id: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.MergerName != null && message.hasOwnProperty("MergerName"))
                if (!$util.isString(message.MergerName))
                    return "MergerName: string expected";
            if (message.Area != null && message.hasOwnProperty("Area"))
                if (!$util.isString(message.Area))
                    return "Area: string expected";
            if (message.Host != null && message.hasOwnProperty("Host"))
                if (!$util.isString(message.Host))
                    return "Host: string expected";
            if (message.Port != null && message.hasOwnProperty("Port"))
                if (!$util.isString(message.Port))
                    return "Port: string expected";
            if (message.IsNew != null && message.hasOwnProperty("IsNew"))
                if (!$util.isInteger(message.IsNew))
                    return "IsNew: integer expected";
            if (message.Status != null && message.hasOwnProperty("Status"))
                if (!$util.isInteger(message.Status))
                    return "Status: integer expected";
            if (message.Sort != null && message.hasOwnProperty("Sort"))
                if (!$util.isInteger(message.Sort))
                    return "Sort: integer expected";
            if (message.AppId != null && message.hasOwnProperty("AppId"))
                if (!$util.isString(message.AppId))
                    return "AppId: string expected";
            if (message.ServerId != null && message.hasOwnProperty("ServerId"))
                if (!$util.isInteger(message.ServerId))
                    return "ServerId: integer expected";
            if (message.IndexId != null && message.hasOwnProperty("IndexId"))
                if (!$util.isInteger(message.IndexId))
                    return "IndexId: integer expected";
            if (message.IsClose != null && message.hasOwnProperty("IsClose"))
                if (!$util.isInteger(message.IsClose))
                    return "IsClose: integer expected";
            if (message.CloseExplain != null && message.hasOwnProperty("CloseExplain"))
                if (!$util.isString(message.CloseExplain))
                    return "CloseExplain: string expected";
            if (message.ServerDate != null && message.hasOwnProperty("ServerDate"))
                if (!$util.isInteger(message.ServerDate) && !(message.ServerDate && $util.isInteger(message.ServerDate.low) && $util.isInteger(message.ServerDate.high)))
                    return "ServerDate: integer|Long expected";
            return null;
        };

        return PbSvrInfo;
    })();

    msgProto.SvrListResponse = (function() {

        /**
         * Properties of a SvrListResponse.
         * @memberof msgProto
         * @interface ISvrListResponse
         * @property {number|null} [retCode] SvrListResponse retCode
         * @property {number|null} [retType] SvrListResponse retType
         * @property {Array.<msgProto.IPbSvrInfo>|null} [infos] SvrListResponse infos
         */

        /**
         * Constructs a new SvrListResponse.
         * @memberof msgProto
         * @classdesc Represents a SvrListResponse.
         * @implements ISvrListResponse
         * @constructor
         * @param {msgProto.ISvrListResponse=} [properties] Properties to set
         */
        function SvrListResponse(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SvrListResponse retCode.
         * @member {number} retCode
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.retCode = 0;

        /**
         * SvrListResponse retType.
         * @member {number} retType
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.retType = 0;

        /**
         * SvrListResponse infos.
         * @member {Array.<msgProto.IPbSvrInfo>} infos
         * @memberof msgProto.SvrListResponse
         * @instance
         */
        SvrListResponse.prototype.infos = $util.emptyArray;

        /**
         * Creates a new SvrListResponse instance using the specified properties.
         * @function create
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {msgProto.ISvrListResponse=} [properties] Properties to set
         * @returns {msgProto.SvrListResponse} SvrListResponse instance
         */
        SvrListResponse.create = function create(properties) {
            return new SvrListResponse(properties);
        };

        /**
         * Encodes the specified SvrListResponse message. Does not implicitly {@link msgProto.SvrListResponse.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {msgProto.ISvrListResponse} message SvrListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retCode);
            if (message.retType != null && message.hasOwnProperty("retType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.retType);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.msgProto.PbSvrInfo.encode(message.infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SvrListResponse message, length delimited. Does not implicitly {@link msgProto.SvrListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {msgProto.ISvrListResponse} message SvrListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SvrListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrListResponse} SvrListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrListResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retCode = reader.int32();
                    break;
                case 2:
                    message.retType = reader.int32();
                    break;
                case 3:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.msgProto.PbSvrInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SvrListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SvrListResponse} SvrListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SvrListResponse message.
         * @function verify
         * @memberof msgProto.SvrListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SvrListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retCode != null && message.hasOwnProperty("retCode"))
                if (!$util.isInteger(message.retCode))
                    return "retCode: integer expected";
            if (message.retType != null && message.hasOwnProperty("retType"))
                if (!$util.isInteger(message.retType))
                    return "retType: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.msgProto.PbSvrInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return SvrListResponse;
    })();

    msgProto.SvrDateGet = (function() {

        /**
         * Properties of a SvrDateGet.
         * @memberof msgProto
         * @interface ISvrDateGet
         */

        /**
         * Constructs a new SvrDateGet.
         * @memberof msgProto
         * @classdesc Represents a SvrDateGet.
         * @implements ISvrDateGet
         * @constructor
         * @param {msgProto.ISvrDateGet=} [properties] Properties to set
         */
        function SvrDateGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SvrDateGet instance using the specified properties.
         * @function create
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {msgProto.ISvrDateGet=} [properties] Properties to set
         * @returns {msgProto.SvrDateGet} SvrDateGet instance
         */
        SvrDateGet.create = function create(properties) {
            return new SvrDateGet(properties);
        };

        /**
         * Encodes the specified SvrDateGet message. Does not implicitly {@link msgProto.SvrDateGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {msgProto.ISvrDateGet} message SvrDateGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrDateGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SvrDateGet message, length delimited. Does not implicitly {@link msgProto.SvrDateGet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {msgProto.ISvrDateGet} message SvrDateGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SvrDateGet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SvrDateGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.SvrDateGet} SvrDateGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrDateGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.SvrDateGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SvrDateGet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.SvrDateGet} SvrDateGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SvrDateGet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SvrDateGet message.
         * @function verify
         * @memberof msgProto.SvrDateGet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SvrDateGet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return SvrDateGet;
    })();

    msgProto.UserSvrsGet = (function() {

        /**
         * Properties of a UserSvrsGet.
         * @memberof msgProto
         * @interface IUserSvrsGet
         * @property {number|Long|null} [accId] UserSvrsGet accId
         */

        /**
         * Constructs a new UserSvrsGet.
         * @memberof msgProto
         * @classdesc Represents a UserSvrsGet.
         * @implements IUserSvrsGet
         * @constructor
         * @param {msgProto.IUserSvrsGet=} [properties] Properties to set
         */
        function UserSvrsGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSvrsGet accId.
         * @member {number|Long} accId
         * @memberof msgProto.UserSvrsGet
         * @instance
         */
        UserSvrsGet.prototype.accId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserSvrsGet instance using the specified properties.
         * @function create
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {msgProto.IUserSvrsGet=} [properties] Properties to set
         * @returns {msgProto.UserSvrsGet} UserSvrsGet instance
         */
        UserSvrsGet.create = function create(properties) {
            return new UserSvrsGet(properties);
        };

        /**
         * Encodes the specified UserSvrsGet message. Does not implicitly {@link msgProto.UserSvrsGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {msgProto.IUserSvrsGet} message UserSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSvrsGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accId != null && message.hasOwnProperty("accId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.accId);
            return writer;
        };

        /**
         * Encodes the specified UserSvrsGet message, length delimited. Does not implicitly {@link msgProto.UserSvrsGet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {msgProto.IUserSvrsGet} message UserSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSvrsGet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSvrsGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.UserSvrsGet} UserSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSvrsGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.UserSvrsGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSvrsGet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.UserSvrsGet} UserSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSvrsGet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSvrsGet message.
         * @function verify
         * @memberof msgProto.UserSvrsGet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSvrsGet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accId != null && message.hasOwnProperty("accId"))
                if (!$util.isInteger(message.accId) && !(message.accId && $util.isInteger(message.accId.low) && $util.isInteger(message.accId.high)))
                    return "accId: integer|Long expected";
            return null;
        };

        return UserSvrsGet;
    })();

    msgProto.AccountSvrsGet = (function() {

        /**
         * Properties of an AccountSvrsGet.
         * @memberof msgProto
         * @interface IAccountSvrsGet
         * @property {string|null} [openId] AccountSvrsGet openId
         * @property {string|null} [appId] AccountSvrsGet appId
         * @property {boolean|null} [isTest] AccountSvrsGet isTest
         */

        /**
         * Constructs a new AccountSvrsGet.
         * @memberof msgProto
         * @classdesc Represents an AccountSvrsGet.
         * @implements IAccountSvrsGet
         * @constructor
         * @param {msgProto.IAccountSvrsGet=} [properties] Properties to set
         */
        function AccountSvrsGet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSvrsGet openId.
         * @member {string} openId
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.openId = "";

        /**
         * AccountSvrsGet appId.
         * @member {string} appId
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.appId = "";

        /**
         * AccountSvrsGet isTest.
         * @member {boolean} isTest
         * @memberof msgProto.AccountSvrsGet
         * @instance
         */
        AccountSvrsGet.prototype.isTest = false;

        /**
         * Creates a new AccountSvrsGet instance using the specified properties.
         * @function create
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {msgProto.IAccountSvrsGet=} [properties] Properties to set
         * @returns {msgProto.AccountSvrsGet} AccountSvrsGet instance
         */
        AccountSvrsGet.create = function create(properties) {
            return new AccountSvrsGet(properties);
        };

        /**
         * Encodes the specified AccountSvrsGet message. Does not implicitly {@link msgProto.AccountSvrsGet.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {msgProto.IAccountSvrsGet} message AccountSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSvrsGet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.openId);
            if (message.appId != null && message.hasOwnProperty("appId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.appId);
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isTest);
            return writer;
        };

        /**
         * Encodes the specified AccountSvrsGet message, length delimited. Does not implicitly {@link msgProto.AccountSvrsGet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {msgProto.IAccountSvrsGet} message AccountSvrsGet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSvrsGet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSvrsGet message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AccountSvrsGet} AccountSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSvrsGet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AccountSvrsGet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.openId = reader.string();
                    break;
                case 2:
                    message.appId = reader.string();
                    break;
                case 3:
                    message.isTest = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSvrsGet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AccountSvrsGet} AccountSvrsGet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSvrsGet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSvrsGet message.
         * @function verify
         * @memberof msgProto.AccountSvrsGet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSvrsGet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.openId != null && message.hasOwnProperty("openId"))
                if (!$util.isString(message.openId))
                    return "openId: string expected";
            if (message.appId != null && message.hasOwnProperty("appId"))
                if (!$util.isString(message.appId))
                    return "appId: string expected";
            if (message.isTest != null && message.hasOwnProperty("isTest"))
                if (typeof message.isTest !== "boolean")
                    return "isTest: boolean expected";
            return null;
        };

        return AccountSvrsGet;
    })();

    msgProto.KefuGetList = (function() {

        /**
         * Properties of a KefuGetList.
         * @memberof msgProto
         * @interface IKefuGetList
         * @property {number|null} [lastId] KefuGetList lastId
         * @property {string|null} [openId] KefuGetList openId
         */

        /**
         * Constructs a new KefuGetList.
         * @memberof msgProto
         * @classdesc Represents a KefuGetList.
         * @implements IKefuGetList
         * @constructor
         * @param {msgProto.IKefuGetList=} [properties] Properties to set
         */
        function KefuGetList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KefuGetList lastId.
         * @member {number} lastId
         * @memberof msgProto.KefuGetList
         * @instance
         */
        KefuGetList.prototype.lastId = 0;

        /**
         * KefuGetList openId.
         * @member {string} openId
         * @memberof msgProto.KefuGetList
         * @instance
         */
        KefuGetList.prototype.openId = "";

        /**
         * Creates a new KefuGetList instance using the specified properties.
         * @function create
         * @memberof msgProto.KefuGetList
         * @static
         * @param {msgProto.IKefuGetList=} [properties] Properties to set
         * @returns {msgProto.KefuGetList} KefuGetList instance
         */
        KefuGetList.create = function create(properties) {
            return new KefuGetList(properties);
        };

        /**
         * Encodes the specified KefuGetList message. Does not implicitly {@link msgProto.KefuGetList.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KefuGetList
         * @static
         * @param {msgProto.IKefuGetList} message KefuGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuGetList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.openId);
            return writer;
        };

        /**
         * Encodes the specified KefuGetList message, length delimited. Does not implicitly {@link msgProto.KefuGetList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KefuGetList
         * @static
         * @param {msgProto.IKefuGetList} message KefuGetList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuGetList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KefuGetList message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KefuGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KefuGetList} KefuGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuGetList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KefuGetList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.openId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KefuGetList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KefuGetList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KefuGetList} KefuGetList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuGetList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KefuGetList message.
         * @function verify
         * @memberof msgProto.KefuGetList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KefuGetList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            if (message.openId != null && message.hasOwnProperty("openId"))
                if (!$util.isString(message.openId))
                    return "openId: string expected";
            return null;
        };

        return KefuGetList;
    })();

    msgProto.KefuSendData = (function() {

        /**
         * Properties of a KefuSendData.
         * @memberof msgProto
         * @interface IKefuSendData
         * @property {number|null} [lastId] KefuSendData lastId
         * @property {string|null} [content] KefuSendData content
         * @property {string|null} [openId] KefuSendData openId
         * @property {string|null} [nickname] KefuSendData nickname
         * @property {number|null} [vipLevel] KefuSendData vipLevel
         */

        /**
         * Constructs a new KefuSendData.
         * @memberof msgProto
         * @classdesc Represents a KefuSendData.
         * @implements IKefuSendData
         * @constructor
         * @param {msgProto.IKefuSendData=} [properties] Properties to set
         */
        function KefuSendData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KefuSendData lastId.
         * @member {number} lastId
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.lastId = 0;

        /**
         * KefuSendData content.
         * @member {string} content
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.content = "";

        /**
         * KefuSendData openId.
         * @member {string} openId
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.openId = "";

        /**
         * KefuSendData nickname.
         * @member {string} nickname
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.nickname = "";

        /**
         * KefuSendData vipLevel.
         * @member {number} vipLevel
         * @memberof msgProto.KefuSendData
         * @instance
         */
        KefuSendData.prototype.vipLevel = 0;

        /**
         * Creates a new KefuSendData instance using the specified properties.
         * @function create
         * @memberof msgProto.KefuSendData
         * @static
         * @param {msgProto.IKefuSendData=} [properties] Properties to set
         * @returns {msgProto.KefuSendData} KefuSendData instance
         */
        KefuSendData.create = function create(properties) {
            return new KefuSendData(properties);
        };

        /**
         * Encodes the specified KefuSendData message. Does not implicitly {@link msgProto.KefuSendData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.KefuSendData
         * @static
         * @param {msgProto.IKefuSendData} message KefuSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuSendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lastId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            if (message.openId != null && message.hasOwnProperty("openId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.openId);
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nickname);
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.vipLevel);
            return writer;
        };

        /**
         * Encodes the specified KefuSendData message, length delimited. Does not implicitly {@link msgProto.KefuSendData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.KefuSendData
         * @static
         * @param {msgProto.IKefuSendData} message KefuSendData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KefuSendData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KefuSendData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.KefuSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.KefuSendData} KefuSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuSendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.KefuSendData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastId = reader.int32();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                case 3:
                    message.openId = reader.string();
                    break;
                case 4:
                    message.nickname = reader.string();
                    break;
                case 5:
                    message.vipLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KefuSendData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.KefuSendData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.KefuSendData} KefuSendData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KefuSendData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KefuSendData message.
         * @function verify
         * @memberof msgProto.KefuSendData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KefuSendData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.openId != null && message.hasOwnProperty("openId"))
                if (!$util.isString(message.openId))
                    return "openId: string expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.vipLevel != null && message.hasOwnProperty("vipLevel"))
                if (!$util.isInteger(message.vipLevel))
                    return "vipLevel: integer expected";
            return null;
        };

        return KefuSendData;
    })();

    msgProto.AdminCoffersLootDefense = (function() {

        /**
         * Properties of an AdminCoffersLootDefense.
         * @memberof msgProto
         * @interface IAdminCoffersLootDefense
         * @property {string|null} [attackData] AdminCoffersLootDefense attackData
         * @property {number|null} [door] AdminCoffersLootDefense door
         */

        /**
         * Constructs a new AdminCoffersLootDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersLootDefense.
         * @implements IAdminCoffersLootDefense
         * @constructor
         * @param {msgProto.IAdminCoffersLootDefense=} [properties] Properties to set
         */
        function AdminCoffersLootDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersLootDefense attackData.
         * @member {string} attackData
         * @memberof msgProto.AdminCoffersLootDefense
         * @instance
         */
        AdminCoffersLootDefense.prototype.attackData = "";

        /**
         * AdminCoffersLootDefense door.
         * @member {number} door
         * @memberof msgProto.AdminCoffersLootDefense
         * @instance
         */
        AdminCoffersLootDefense.prototype.door = 0;

        /**
         * Creates a new AdminCoffersLootDefense instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {msgProto.IAdminCoffersLootDefense=} [properties] Properties to set
         * @returns {msgProto.AdminCoffersLootDefense} AdminCoffersLootDefense instance
         */
        AdminCoffersLootDefense.create = function create(properties) {
            return new AdminCoffersLootDefense(properties);
        };

        /**
         * Encodes the specified AdminCoffersLootDefense message. Does not implicitly {@link msgProto.AdminCoffersLootDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {msgProto.IAdminCoffersLootDefense} message AdminCoffersLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.attackData);
            if (message.door != null && message.hasOwnProperty("door"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.door);
            return writer;
        };

        /**
         * Encodes the specified AdminCoffersLootDefense message, length delimited. Does not implicitly {@link msgProto.AdminCoffersLootDefense.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {msgProto.IAdminCoffersLootDefense} message AdminCoffersLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootDefense.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminCoffersLootDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersLootDefense} AdminCoffersLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersLootDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attackData = reader.string();
                    break;
                case 2:
                    message.door = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminCoffersLootDefense message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminCoffersLootDefense} AdminCoffersLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootDefense.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminCoffersLootDefense message.
         * @function verify
         * @memberof msgProto.AdminCoffersLootDefense
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminCoffersLootDefense.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                if (!$util.isString(message.attackData))
                    return "attackData: string expected";
            if (message.door != null && message.hasOwnProperty("door"))
                if (!$util.isInteger(message.door))
                    return "door: integer expected";
            return null;
        };

        return AdminCoffersLootDefense;
    })();

    msgProto.AdminCoffersLootCoffersDefense = (function() {

        /**
         * Properties of an AdminCoffersLootCoffersDefense.
         * @memberof msgProto
         * @interface IAdminCoffersLootCoffersDefense
         * @property {number|null} [hurt] AdminCoffersLootCoffersDefense hurt
         * @property {number|null} [breakNum] AdminCoffersLootCoffersDefense breakNum
         */

        /**
         * Constructs a new AdminCoffersLootCoffersDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersLootCoffersDefense.
         * @implements IAdminCoffersLootCoffersDefense
         * @constructor
         * @param {msgProto.IAdminCoffersLootCoffersDefense=} [properties] Properties to set
         */
        function AdminCoffersLootCoffersDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersLootCoffersDefense hurt.
         * @member {number} hurt
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @instance
         */
        AdminCoffersLootCoffersDefense.prototype.hurt = 0;

        /**
         * AdminCoffersLootCoffersDefense breakNum.
         * @member {number} breakNum
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @instance
         */
        AdminCoffersLootCoffersDefense.prototype.breakNum = 0;

        /**
         * Creates a new AdminCoffersLootCoffersDefense instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {msgProto.IAdminCoffersLootCoffersDefense=} [properties] Properties to set
         * @returns {msgProto.AdminCoffersLootCoffersDefense} AdminCoffersLootCoffersDefense instance
         */
        AdminCoffersLootCoffersDefense.create = function create(properties) {
            return new AdminCoffersLootCoffersDefense(properties);
        };

        /**
         * Encodes the specified AdminCoffersLootCoffersDefense message. Does not implicitly {@link msgProto.AdminCoffersLootCoffersDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {msgProto.IAdminCoffersLootCoffersDefense} message AdminCoffersLootCoffersDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootCoffersDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hurt);
            if (message.breakNum != null && message.hasOwnProperty("breakNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.breakNum);
            return writer;
        };

        /**
         * Encodes the specified AdminCoffersLootCoffersDefense message, length delimited. Does not implicitly {@link msgProto.AdminCoffersLootCoffersDefense.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {msgProto.IAdminCoffersLootCoffersDefense} message AdminCoffersLootCoffersDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersLootCoffersDefense.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminCoffersLootCoffersDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersLootCoffersDefense} AdminCoffersLootCoffersDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootCoffersDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersLootCoffersDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hurt = reader.int32();
                    break;
                case 2:
                    message.breakNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminCoffersLootCoffersDefense message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminCoffersLootCoffersDefense} AdminCoffersLootCoffersDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersLootCoffersDefense.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminCoffersLootCoffersDefense message.
         * @function verify
         * @memberof msgProto.AdminCoffersLootCoffersDefense
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminCoffersLootCoffersDefense.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                if (!$util.isInteger(message.hurt))
                    return "hurt: integer expected";
            if (message.breakNum != null && message.hasOwnProperty("breakNum"))
                if (!$util.isInteger(message.breakNum))
                    return "breakNum: integer expected";
            return null;
        };

        return AdminCoffersLootCoffersDefense;
    })();

    msgProto.AdminCoffersGetCache = (function() {

        /**
         * Properties of an AdminCoffersGetCache.
         * @memberof msgProto
         * @interface IAdminCoffersGetCache
         */

        /**
         * Constructs a new AdminCoffersGetCache.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersGetCache.
         * @implements IAdminCoffersGetCache
         * @constructor
         * @param {msgProto.IAdminCoffersGetCache=} [properties] Properties to set
         */
        function AdminCoffersGetCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminCoffersGetCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {msgProto.IAdminCoffersGetCache=} [properties] Properties to set
         * @returns {msgProto.AdminCoffersGetCache} AdminCoffersGetCache instance
         */
        AdminCoffersGetCache.create = function create(properties) {
            return new AdminCoffersGetCache(properties);
        };

        /**
         * Encodes the specified AdminCoffersGetCache message. Does not implicitly {@link msgProto.AdminCoffersGetCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {msgProto.IAdminCoffersGetCache} message AdminCoffersGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersGetCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminCoffersGetCache message, length delimited. Does not implicitly {@link msgProto.AdminCoffersGetCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {msgProto.IAdminCoffersGetCache} message AdminCoffersGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersGetCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminCoffersGetCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersGetCache} AdminCoffersGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersGetCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersGetCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminCoffersGetCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminCoffersGetCache} AdminCoffersGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersGetCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminCoffersGetCache message.
         * @function verify
         * @memberof msgProto.AdminCoffersGetCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminCoffersGetCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminCoffersGetCache;
    })();

    msgProto.AdminCoffersResetPoints = (function() {

        /**
         * Properties of an AdminCoffersResetPoints.
         * @memberof msgProto
         * @interface IAdminCoffersResetPoints
         */

        /**
         * Constructs a new AdminCoffersResetPoints.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersResetPoints.
         * @implements IAdminCoffersResetPoints
         * @constructor
         * @param {msgProto.IAdminCoffersResetPoints=} [properties] Properties to set
         */
        function AdminCoffersResetPoints(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminCoffersResetPoints instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {msgProto.IAdminCoffersResetPoints=} [properties] Properties to set
         * @returns {msgProto.AdminCoffersResetPoints} AdminCoffersResetPoints instance
         */
        AdminCoffersResetPoints.create = function create(properties) {
            return new AdminCoffersResetPoints(properties);
        };

        /**
         * Encodes the specified AdminCoffersResetPoints message. Does not implicitly {@link msgProto.AdminCoffersResetPoints.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {msgProto.IAdminCoffersResetPoints} message AdminCoffersResetPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersResetPoints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminCoffersResetPoints message, length delimited. Does not implicitly {@link msgProto.AdminCoffersResetPoints.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {msgProto.IAdminCoffersResetPoints} message AdminCoffersResetPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersResetPoints.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminCoffersResetPoints message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersResetPoints} AdminCoffersResetPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersResetPoints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersResetPoints();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminCoffersResetPoints message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminCoffersResetPoints} AdminCoffersResetPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersResetPoints.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminCoffersResetPoints message.
         * @function verify
         * @memberof msgProto.AdminCoffersResetPoints
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminCoffersResetPoints.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminCoffersResetPoints;
    })();

    msgProto.AdminCoffersUpdateCache = (function() {

        /**
         * Properties of an AdminCoffersUpdateCache.
         * @memberof msgProto
         * @interface IAdminCoffersUpdateCache
         * @property {string|null} [data] AdminCoffersUpdateCache data
         */

        /**
         * Constructs a new AdminCoffersUpdateCache.
         * @memberof msgProto
         * @classdesc Represents an AdminCoffersUpdateCache.
         * @implements IAdminCoffersUpdateCache
         * @constructor
         * @param {msgProto.IAdminCoffersUpdateCache=} [properties] Properties to set
         */
        function AdminCoffersUpdateCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminCoffersUpdateCache data.
         * @member {string} data
         * @memberof msgProto.AdminCoffersUpdateCache
         * @instance
         */
        AdminCoffersUpdateCache.prototype.data = "";

        /**
         * Creates a new AdminCoffersUpdateCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {msgProto.IAdminCoffersUpdateCache=} [properties] Properties to set
         * @returns {msgProto.AdminCoffersUpdateCache} AdminCoffersUpdateCache instance
         */
        AdminCoffersUpdateCache.create = function create(properties) {
            return new AdminCoffersUpdateCache(properties);
        };

        /**
         * Encodes the specified AdminCoffersUpdateCache message. Does not implicitly {@link msgProto.AdminCoffersUpdateCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {msgProto.IAdminCoffersUpdateCache} message AdminCoffersUpdateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersUpdateCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified AdminCoffersUpdateCache message, length delimited. Does not implicitly {@link msgProto.AdminCoffersUpdateCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {msgProto.IAdminCoffersUpdateCache} message AdminCoffersUpdateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminCoffersUpdateCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminCoffersUpdateCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminCoffersUpdateCache} AdminCoffersUpdateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersUpdateCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminCoffersUpdateCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminCoffersUpdateCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminCoffersUpdateCache} AdminCoffersUpdateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminCoffersUpdateCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminCoffersUpdateCache message.
         * @function verify
         * @memberof msgProto.AdminCoffersUpdateCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminCoffersUpdateCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return AdminCoffersUpdateCache;
    })();

    msgProto.AdminGuildGetCache = (function() {

        /**
         * Properties of an AdminGuildGetCache.
         * @memberof msgProto
         * @interface IAdminGuildGetCache
         */

        /**
         * Constructs a new AdminGuildGetCache.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetCache.
         * @implements IAdminGuildGetCache
         * @constructor
         * @param {msgProto.IAdminGuildGetCache=} [properties] Properties to set
         */
        function AdminGuildGetCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminGuildGetCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {msgProto.IAdminGuildGetCache=} [properties] Properties to set
         * @returns {msgProto.AdminGuildGetCache} AdminGuildGetCache instance
         */
        AdminGuildGetCache.create = function create(properties) {
            return new AdminGuildGetCache(properties);
        };

        /**
         * Encodes the specified AdminGuildGetCache message. Does not implicitly {@link msgProto.AdminGuildGetCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {msgProto.IAdminGuildGetCache} message AdminGuildGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminGuildGetCache message, length delimited. Does not implicitly {@link msgProto.AdminGuildGetCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {msgProto.IAdminGuildGetCache} message AdminGuildGetCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildGetCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetCache} AdminGuildGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildGetCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildGetCache} AdminGuildGetCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildGetCache message.
         * @function verify
         * @memberof msgProto.AdminGuildGetCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildGetCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminGuildGetCache;
    })();

    msgProto.AdminGuildGetGuildById = (function() {

        /**
         * Properties of an AdminGuildGetGuildById.
         * @memberof msgProto
         * @interface IAdminGuildGetGuildById
         * @property {number|null} [id] AdminGuildGetGuildById id
         */

        /**
         * Constructs a new AdminGuildGetGuildById.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetGuildById.
         * @implements IAdminGuildGetGuildById
         * @constructor
         * @param {msgProto.IAdminGuildGetGuildById=} [properties] Properties to set
         */
        function AdminGuildGetGuildById(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildGetGuildById id.
         * @member {number} id
         * @memberof msgProto.AdminGuildGetGuildById
         * @instance
         */
        AdminGuildGetGuildById.prototype.id = 0;

        /**
         * Creates a new AdminGuildGetGuildById instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {msgProto.IAdminGuildGetGuildById=} [properties] Properties to set
         * @returns {msgProto.AdminGuildGetGuildById} AdminGuildGetGuildById instance
         */
        AdminGuildGetGuildById.create = function create(properties) {
            return new AdminGuildGetGuildById(properties);
        };

        /**
         * Encodes the specified AdminGuildGetGuildById message. Does not implicitly {@link msgProto.AdminGuildGetGuildById.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {msgProto.IAdminGuildGetGuildById} message AdminGuildGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetGuildById.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified AdminGuildGetGuildById message, length delimited. Does not implicitly {@link msgProto.AdminGuildGetGuildById.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {msgProto.IAdminGuildGetGuildById} message AdminGuildGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetGuildById.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildGetGuildById message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetGuildById} AdminGuildGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetGuildById.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetGuildById();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildGetGuildById message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildGetGuildById} AdminGuildGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetGuildById.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildGetGuildById message.
         * @function verify
         * @memberof msgProto.AdminGuildGetGuildById
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildGetGuildById.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        return AdminGuildGetGuildById;
    })();

    msgProto.Admin_guild_updateCache = (function() {

        /**
         * Properties of an Admin_guild_updateCache.
         * @memberof msgProto
         * @interface IAdmin_guild_updateCache
         * @property {number|null} [id] Admin_guild_updateCache id
         * @property {string|null} [data] Admin_guild_updateCache data
         */

        /**
         * Constructs a new Admin_guild_updateCache.
         * @memberof msgProto
         * @classdesc Represents an Admin_guild_updateCache.
         * @implements IAdmin_guild_updateCache
         * @constructor
         * @param {msgProto.IAdmin_guild_updateCache=} [properties] Properties to set
         */
        function Admin_guild_updateCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Admin_guild_updateCache id.
         * @member {number} id
         * @memberof msgProto.Admin_guild_updateCache
         * @instance
         */
        Admin_guild_updateCache.prototype.id = 0;

        /**
         * Admin_guild_updateCache data.
         * @member {string} data
         * @memberof msgProto.Admin_guild_updateCache
         * @instance
         */
        Admin_guild_updateCache.prototype.data = "";

        /**
         * Creates a new Admin_guild_updateCache instance using the specified properties.
         * @function create
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {msgProto.IAdmin_guild_updateCache=} [properties] Properties to set
         * @returns {msgProto.Admin_guild_updateCache} Admin_guild_updateCache instance
         */
        Admin_guild_updateCache.create = function create(properties) {
            return new Admin_guild_updateCache(properties);
        };

        /**
         * Encodes the specified Admin_guild_updateCache message. Does not implicitly {@link msgProto.Admin_guild_updateCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {msgProto.IAdmin_guild_updateCache} message Admin_guild_updateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Admin_guild_updateCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified Admin_guild_updateCache message, length delimited. Does not implicitly {@link msgProto.Admin_guild_updateCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {msgProto.IAdmin_guild_updateCache} message Admin_guild_updateCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Admin_guild_updateCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Admin_guild_updateCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.Admin_guild_updateCache} Admin_guild_updateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Admin_guild_updateCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.Admin_guild_updateCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Admin_guild_updateCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.Admin_guild_updateCache} Admin_guild_updateCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Admin_guild_updateCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Admin_guild_updateCache message.
         * @function verify
         * @memberof msgProto.Admin_guild_updateCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Admin_guild_updateCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return Admin_guild_updateCache;
    })();

    msgProto.AdminGuildGetZombieGuild = (function() {

        /**
         * Properties of an AdminGuildGetZombieGuild.
         * @memberof msgProto
         * @interface IAdminGuildGetZombieGuild
         */

        /**
         * Constructs a new AdminGuildGetZombieGuild.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildGetZombieGuild.
         * @implements IAdminGuildGetZombieGuild
         * @constructor
         * @param {msgProto.IAdminGuildGetZombieGuild=} [properties] Properties to set
         */
        function AdminGuildGetZombieGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminGuildGetZombieGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {msgProto.IAdminGuildGetZombieGuild=} [properties] Properties to set
         * @returns {msgProto.AdminGuildGetZombieGuild} AdminGuildGetZombieGuild instance
         */
        AdminGuildGetZombieGuild.create = function create(properties) {
            return new AdminGuildGetZombieGuild(properties);
        };

        /**
         * Encodes the specified AdminGuildGetZombieGuild message. Does not implicitly {@link msgProto.AdminGuildGetZombieGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {msgProto.IAdminGuildGetZombieGuild} message AdminGuildGetZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetZombieGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminGuildGetZombieGuild message, length delimited. Does not implicitly {@link msgProto.AdminGuildGetZombieGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {msgProto.IAdminGuildGetZombieGuild} message AdminGuildGetZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildGetZombieGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildGetZombieGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildGetZombieGuild} AdminGuildGetZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetZombieGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildGetZombieGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildGetZombieGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildGetZombieGuild} AdminGuildGetZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildGetZombieGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildGetZombieGuild message.
         * @function verify
         * @memberof msgProto.AdminGuildGetZombieGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildGetZombieGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminGuildGetZombieGuild;
    })();

    msgProto.AdminGuildClearZombieGuild = (function() {

        /**
         * Properties of an AdminGuildClearZombieGuild.
         * @memberof msgProto
         * @interface IAdminGuildClearZombieGuild
         * @property {number|null} [id] AdminGuildClearZombieGuild id
         * @property {string|null} [data] AdminGuildClearZombieGuild data
         */

        /**
         * Constructs a new AdminGuildClearZombieGuild.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildClearZombieGuild.
         * @implements IAdminGuildClearZombieGuild
         * @constructor
         * @param {msgProto.IAdminGuildClearZombieGuild=} [properties] Properties to set
         */
        function AdminGuildClearZombieGuild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildClearZombieGuild id.
         * @member {number} id
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @instance
         */
        AdminGuildClearZombieGuild.prototype.id = 0;

        /**
         * AdminGuildClearZombieGuild data.
         * @member {string} data
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @instance
         */
        AdminGuildClearZombieGuild.prototype.data = "";

        /**
         * Creates a new AdminGuildClearZombieGuild instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {msgProto.IAdminGuildClearZombieGuild=} [properties] Properties to set
         * @returns {msgProto.AdminGuildClearZombieGuild} AdminGuildClearZombieGuild instance
         */
        AdminGuildClearZombieGuild.create = function create(properties) {
            return new AdminGuildClearZombieGuild(properties);
        };

        /**
         * Encodes the specified AdminGuildClearZombieGuild message. Does not implicitly {@link msgProto.AdminGuildClearZombieGuild.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {msgProto.IAdminGuildClearZombieGuild} message AdminGuildClearZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildClearZombieGuild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified AdminGuildClearZombieGuild message, length delimited. Does not implicitly {@link msgProto.AdminGuildClearZombieGuild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {msgProto.IAdminGuildClearZombieGuild} message AdminGuildClearZombieGuild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildClearZombieGuild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildClearZombieGuild message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildClearZombieGuild} AdminGuildClearZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildClearZombieGuild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildClearZombieGuild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildClearZombieGuild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildClearZombieGuild} AdminGuildClearZombieGuild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildClearZombieGuild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildClearZombieGuild message.
         * @function verify
         * @memberof msgProto.AdminGuildClearZombieGuild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildClearZombieGuild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return AdminGuildClearZombieGuild;
    })();

    msgProto.AdminGuildChairmanImpeach = (function() {

        /**
         * Properties of an AdminGuildChairmanImpeach.
         * @memberof msgProto
         * @interface IAdminGuildChairmanImpeach
         */

        /**
         * Constructs a new AdminGuildChairmanImpeach.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildChairmanImpeach.
         * @implements IAdminGuildChairmanImpeach
         * @constructor
         * @param {msgProto.IAdminGuildChairmanImpeach=} [properties] Properties to set
         */
        function AdminGuildChairmanImpeach(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminGuildChairmanImpeach instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {msgProto.IAdminGuildChairmanImpeach=} [properties] Properties to set
         * @returns {msgProto.AdminGuildChairmanImpeach} AdminGuildChairmanImpeach instance
         */
        AdminGuildChairmanImpeach.create = function create(properties) {
            return new AdminGuildChairmanImpeach(properties);
        };

        /**
         * Encodes the specified AdminGuildChairmanImpeach message. Does not implicitly {@link msgProto.AdminGuildChairmanImpeach.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {msgProto.IAdminGuildChairmanImpeach} message AdminGuildChairmanImpeach message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildChairmanImpeach.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminGuildChairmanImpeach message, length delimited. Does not implicitly {@link msgProto.AdminGuildChairmanImpeach.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {msgProto.IAdminGuildChairmanImpeach} message AdminGuildChairmanImpeach message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildChairmanImpeach.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildChairmanImpeach message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildChairmanImpeach} AdminGuildChairmanImpeach
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildChairmanImpeach.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildChairmanImpeach();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildChairmanImpeach message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildChairmanImpeach} AdminGuildChairmanImpeach
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildChairmanImpeach.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildChairmanImpeach message.
         * @function verify
         * @memberof msgProto.AdminGuildChairmanImpeach
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildChairmanImpeach.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminGuildChairmanImpeach;
    })();

    msgProto.AdminBossGetBossData = (function() {

        /**
         * Properties of an AdminBossGetBossData.
         * @memberof msgProto
         * @interface IAdminBossGetBossData
         * @property {number|null} [bossId] AdminBossGetBossData bossId
         */

        /**
         * Constructs a new AdminBossGetBossData.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetBossData.
         * @implements IAdminBossGetBossData
         * @constructor
         * @param {msgProto.IAdminBossGetBossData=} [properties] Properties to set
         */
        function AdminBossGetBossData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetBossData bossId.
         * @member {number} bossId
         * @memberof msgProto.AdminBossGetBossData
         * @instance
         */
        AdminBossGetBossData.prototype.bossId = 0;

        /**
         * Creates a new AdminBossGetBossData instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {msgProto.IAdminBossGetBossData=} [properties] Properties to set
         * @returns {msgProto.AdminBossGetBossData} AdminBossGetBossData instance
         */
        AdminBossGetBossData.create = function create(properties) {
            return new AdminBossGetBossData(properties);
        };

        /**
         * Encodes the specified AdminBossGetBossData message. Does not implicitly {@link msgProto.AdminBossGetBossData.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {msgProto.IAdminBossGetBossData} message AdminBossGetBossData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetBossData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified AdminBossGetBossData message, length delimited. Does not implicitly {@link msgProto.AdminBossGetBossData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {msgProto.IAdminBossGetBossData} message AdminBossGetBossData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetBossData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminBossGetBossData message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetBossData} AdminBossGetBossData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetBossData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetBossData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminBossGetBossData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminBossGetBossData} AdminBossGetBossData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetBossData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminBossGetBossData message.
         * @function verify
         * @memberof msgProto.AdminBossGetBossData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminBossGetBossData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return AdminBossGetBossData;
    })();

    msgProto.AdminBossGetUserCache = (function() {

        /**
         * Properties of an AdminBossGetUserCache.
         * @memberof msgProto
         * @interface IAdminBossGetUserCache
         * @property {number|null} [bossId] AdminBossGetUserCache bossId
         */

        /**
         * Constructs a new AdminBossGetUserCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetUserCache.
         * @implements IAdminBossGetUserCache
         * @constructor
         * @param {msgProto.IAdminBossGetUserCache=} [properties] Properties to set
         */
        function AdminBossGetUserCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetUserCache bossId.
         * @member {number} bossId
         * @memberof msgProto.AdminBossGetUserCache
         * @instance
         */
        AdminBossGetUserCache.prototype.bossId = 0;

        /**
         * Creates a new AdminBossGetUserCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {msgProto.IAdminBossGetUserCache=} [properties] Properties to set
         * @returns {msgProto.AdminBossGetUserCache} AdminBossGetUserCache instance
         */
        AdminBossGetUserCache.create = function create(properties) {
            return new AdminBossGetUserCache(properties);
        };

        /**
         * Encodes the specified AdminBossGetUserCache message. Does not implicitly {@link msgProto.AdminBossGetUserCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {msgProto.IAdminBossGetUserCache} message AdminBossGetUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetUserCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossId);
            return writer;
        };

        /**
         * Encodes the specified AdminBossGetUserCache message, length delimited. Does not implicitly {@link msgProto.AdminBossGetUserCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {msgProto.IAdminBossGetUserCache} message AdminBossGetUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetUserCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminBossGetUserCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetUserCache} AdminBossGetUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetUserCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetUserCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminBossGetUserCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminBossGetUserCache} AdminBossGetUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetUserCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminBossGetUserCache message.
         * @function verify
         * @memberof msgProto.AdminBossGetUserCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminBossGetUserCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            return null;
        };

        return AdminBossGetUserCache;
    })();

    msgProto.AdminBossGetGuildById = (function() {

        /**
         * Properties of an AdminBossGetGuildById.
         * @memberof msgProto
         * @interface IAdminBossGetGuildById
         * @property {number|null} [id] AdminBossGetGuildById id
         */

        /**
         * Constructs a new AdminBossGetGuildById.
         * @memberof msgProto
         * @classdesc Represents an AdminBossGetGuildById.
         * @implements IAdminBossGetGuildById
         * @constructor
         * @param {msgProto.IAdminBossGetGuildById=} [properties] Properties to set
         */
        function AdminBossGetGuildById(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossGetGuildById id.
         * @member {number} id
         * @memberof msgProto.AdminBossGetGuildById
         * @instance
         */
        AdminBossGetGuildById.prototype.id = 0;

        /**
         * Creates a new AdminBossGetGuildById instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {msgProto.IAdminBossGetGuildById=} [properties] Properties to set
         * @returns {msgProto.AdminBossGetGuildById} AdminBossGetGuildById instance
         */
        AdminBossGetGuildById.create = function create(properties) {
            return new AdminBossGetGuildById(properties);
        };

        /**
         * Encodes the specified AdminBossGetGuildById message. Does not implicitly {@link msgProto.AdminBossGetGuildById.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {msgProto.IAdminBossGetGuildById} message AdminBossGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetGuildById.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified AdminBossGetGuildById message, length delimited. Does not implicitly {@link msgProto.AdminBossGetGuildById.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {msgProto.IAdminBossGetGuildById} message AdminBossGetGuildById message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossGetGuildById.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminBossGetGuildById message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossGetGuildById} AdminBossGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetGuildById.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossGetGuildById();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminBossGetGuildById message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminBossGetGuildById} AdminBossGetGuildById
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossGetGuildById.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminBossGetGuildById message.
         * @function verify
         * @memberof msgProto.AdminBossGetGuildById
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminBossGetGuildById.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        return AdminBossGetGuildById;
    })();

    msgProto.AdminBossUpdateBossCache = (function() {

        /**
         * Properties of an AdminBossUpdateBossCache.
         * @memberof msgProto
         * @interface IAdminBossUpdateBossCache
         * @property {string|null} [data] AdminBossUpdateBossCache data
         */

        /**
         * Constructs a new AdminBossUpdateBossCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossUpdateBossCache.
         * @implements IAdminBossUpdateBossCache
         * @constructor
         * @param {msgProto.IAdminBossUpdateBossCache=} [properties] Properties to set
         */
        function AdminBossUpdateBossCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossUpdateBossCache data.
         * @member {string} data
         * @memberof msgProto.AdminBossUpdateBossCache
         * @instance
         */
        AdminBossUpdateBossCache.prototype.data = "";

        /**
         * Creates a new AdminBossUpdateBossCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {msgProto.IAdminBossUpdateBossCache=} [properties] Properties to set
         * @returns {msgProto.AdminBossUpdateBossCache} AdminBossUpdateBossCache instance
         */
        AdminBossUpdateBossCache.create = function create(properties) {
            return new AdminBossUpdateBossCache(properties);
        };

        /**
         * Encodes the specified AdminBossUpdateBossCache message. Does not implicitly {@link msgProto.AdminBossUpdateBossCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {msgProto.IAdminBossUpdateBossCache} message AdminBossUpdateBossCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateBossCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified AdminBossUpdateBossCache message, length delimited. Does not implicitly {@link msgProto.AdminBossUpdateBossCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {msgProto.IAdminBossUpdateBossCache} message AdminBossUpdateBossCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateBossCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminBossUpdateBossCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossUpdateBossCache} AdminBossUpdateBossCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateBossCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossUpdateBossCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminBossUpdateBossCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminBossUpdateBossCache} AdminBossUpdateBossCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateBossCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminBossUpdateBossCache message.
         * @function verify
         * @memberof msgProto.AdminBossUpdateBossCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminBossUpdateBossCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return AdminBossUpdateBossCache;
    })();

    msgProto.AdminBossUpdateUserCache = (function() {

        /**
         * Properties of an AdminBossUpdateUserCache.
         * @memberof msgProto
         * @interface IAdminBossUpdateUserCache
         * @property {number|null} [id] AdminBossUpdateUserCache id
         * @property {string|null} [data] AdminBossUpdateUserCache data
         */

        /**
         * Constructs a new AdminBossUpdateUserCache.
         * @memberof msgProto
         * @classdesc Represents an AdminBossUpdateUserCache.
         * @implements IAdminBossUpdateUserCache
         * @constructor
         * @param {msgProto.IAdminBossUpdateUserCache=} [properties] Properties to set
         */
        function AdminBossUpdateUserCache(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminBossUpdateUserCache id.
         * @member {number} id
         * @memberof msgProto.AdminBossUpdateUserCache
         * @instance
         */
        AdminBossUpdateUserCache.prototype.id = 0;

        /**
         * AdminBossUpdateUserCache data.
         * @member {string} data
         * @memberof msgProto.AdminBossUpdateUserCache
         * @instance
         */
        AdminBossUpdateUserCache.prototype.data = "";

        /**
         * Creates a new AdminBossUpdateUserCache instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {msgProto.IAdminBossUpdateUserCache=} [properties] Properties to set
         * @returns {msgProto.AdminBossUpdateUserCache} AdminBossUpdateUserCache instance
         */
        AdminBossUpdateUserCache.create = function create(properties) {
            return new AdminBossUpdateUserCache(properties);
        };

        /**
         * Encodes the specified AdminBossUpdateUserCache message. Does not implicitly {@link msgProto.AdminBossUpdateUserCache.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {msgProto.IAdminBossUpdateUserCache} message AdminBossUpdateUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateUserCache.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified AdminBossUpdateUserCache message, length delimited. Does not implicitly {@link msgProto.AdminBossUpdateUserCache.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {msgProto.IAdminBossUpdateUserCache} message AdminBossUpdateUserCache message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminBossUpdateUserCache.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminBossUpdateUserCache message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminBossUpdateUserCache} AdminBossUpdateUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateUserCache.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminBossUpdateUserCache();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminBossUpdateUserCache message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminBossUpdateUserCache} AdminBossUpdateUserCache
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminBossUpdateUserCache.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminBossUpdateUserCache message.
         * @function verify
         * @memberof msgProto.AdminBossUpdateUserCache
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminBossUpdateUserCache.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return AdminBossUpdateUserCache;
    })();

    msgProto.AdminChatServersChat = (function() {

        /**
         * Properties of an AdminChatServersChat.
         * @memberof msgProto
         * @interface IAdminChatServersChat
         * @property {string|null} [nickName] AdminChatServersChat nickName
         * @property {number|null} [vip] AdminChatServersChat vip
         * @property {string|null} [content] AdminChatServersChat content
         * @property {boolean|null} [isGM] AdminChatServersChat isGM
         * @property {string|null} [guildName] AdminChatServersChat guildName
         * @property {string|null} [medalTitle] AdminChatServersChat medalTitle
         * @property {boolean|null} [isLittleHorn] AdminChatServersChat isLittleHorn
         */

        /**
         * Constructs a new AdminChatServersChat.
         * @memberof msgProto
         * @classdesc Represents an AdminChatServersChat.
         * @implements IAdminChatServersChat
         * @constructor
         * @param {msgProto.IAdminChatServersChat=} [properties] Properties to set
         */
        function AdminChatServersChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminChatServersChat nickName.
         * @member {string} nickName
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.nickName = "";

        /**
         * AdminChatServersChat vip.
         * @member {number} vip
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.vip = 0;

        /**
         * AdminChatServersChat content.
         * @member {string} content
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.content = "";

        /**
         * AdminChatServersChat isGM.
         * @member {boolean} isGM
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.isGM = false;

        /**
         * AdminChatServersChat guildName.
         * @member {string} guildName
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.guildName = "";

        /**
         * AdminChatServersChat medalTitle.
         * @member {string} medalTitle
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.medalTitle = "";

        /**
         * AdminChatServersChat isLittleHorn.
         * @member {boolean} isLittleHorn
         * @memberof msgProto.AdminChatServersChat
         * @instance
         */
        AdminChatServersChat.prototype.isLittleHorn = false;

        /**
         * Creates a new AdminChatServersChat instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {msgProto.IAdminChatServersChat=} [properties] Properties to set
         * @returns {msgProto.AdminChatServersChat} AdminChatServersChat instance
         */
        AdminChatServersChat.create = function create(properties) {
            return new AdminChatServersChat(properties);
        };

        /**
         * Encodes the specified AdminChatServersChat message. Does not implicitly {@link msgProto.AdminChatServersChat.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {msgProto.IAdminChatServersChat} message AdminChatServersChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminChatServersChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
            if (message.vip != null && message.hasOwnProperty("vip"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vip);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
            if (message.isGM != null && message.hasOwnProperty("isGM"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isGM);
            if (message.guildName != null && message.hasOwnProperty("guildName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.guildName);
            if (message.medalTitle != null && message.hasOwnProperty("medalTitle"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.medalTitle);
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isLittleHorn);
            return writer;
        };

        /**
         * Encodes the specified AdminChatServersChat message, length delimited. Does not implicitly {@link msgProto.AdminChatServersChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {msgProto.IAdminChatServersChat} message AdminChatServersChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminChatServersChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminChatServersChat message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminChatServersChat} AdminChatServersChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminChatServersChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminChatServersChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nickName = reader.string();
                    break;
                case 2:
                    message.vip = reader.int32();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                case 4:
                    message.isGM = reader.bool();
                    break;
                case 5:
                    message.guildName = reader.string();
                    break;
                case 6:
                    message.medalTitle = reader.string();
                    break;
                case 7:
                    message.isLittleHorn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminChatServersChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminChatServersChat} AdminChatServersChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminChatServersChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminChatServersChat message.
         * @function verify
         * @memberof msgProto.AdminChatServersChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminChatServersChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                if (!$util.isString(message.nickName))
                    return "nickName: string expected";
            if (message.vip != null && message.hasOwnProperty("vip"))
                if (!$util.isInteger(message.vip))
                    return "vip: integer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.isGM != null && message.hasOwnProperty("isGM"))
                if (typeof message.isGM !== "boolean")
                    return "isGM: boolean expected";
            if (message.guildName != null && message.hasOwnProperty("guildName"))
                if (!$util.isString(message.guildName))
                    return "guildName: string expected";
            if (message.medalTitle != null && message.hasOwnProperty("medalTitle"))
                if (!$util.isString(message.medalTitle))
                    return "medalTitle: string expected";
            if (message.isLittleHorn != null && message.hasOwnProperty("isLittleHorn"))
                if (typeof message.isLittleHorn !== "boolean")
                    return "isLittleHorn: boolean expected";
            return null;
        };

        return AdminChatServersChat;
    })();

    msgProto.AdminGuildWarLootDefense = (function() {

        /**
         * Properties of an AdminGuildWarLootDefense.
         * @memberof msgProto
         * @interface IAdminGuildWarLootDefense
         * @property {string|null} [attackData] AdminGuildWarLootDefense attackData
         * @property {boolean|null} [isWin] AdminGuildWarLootDefense isWin
         * @property {string|null} [defenceData] AdminGuildWarLootDefense defenceData
         */

        /**
         * Constructs a new AdminGuildWarLootDefense.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarLootDefense.
         * @implements IAdminGuildWarLootDefense
         * @constructor
         * @param {msgProto.IAdminGuildWarLootDefense=} [properties] Properties to set
         */
        function AdminGuildWarLootDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarLootDefense attackData.
         * @member {string} attackData
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.attackData = "";

        /**
         * AdminGuildWarLootDefense isWin.
         * @member {boolean} isWin
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.isWin = false;

        /**
         * AdminGuildWarLootDefense defenceData.
         * @member {string} defenceData
         * @memberof msgProto.AdminGuildWarLootDefense
         * @instance
         */
        AdminGuildWarLootDefense.prototype.defenceData = "";

        /**
         * Creates a new AdminGuildWarLootDefense instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {msgProto.IAdminGuildWarLootDefense=} [properties] Properties to set
         * @returns {msgProto.AdminGuildWarLootDefense} AdminGuildWarLootDefense instance
         */
        AdminGuildWarLootDefense.create = function create(properties) {
            return new AdminGuildWarLootDefense(properties);
        };

        /**
         * Encodes the specified AdminGuildWarLootDefense message. Does not implicitly {@link msgProto.AdminGuildWarLootDefense.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {msgProto.IAdminGuildWarLootDefense} message AdminGuildWarLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarLootDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.attackData);
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isWin);
            if (message.defenceData != null && message.hasOwnProperty("defenceData"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.defenceData);
            return writer;
        };

        /**
         * Encodes the specified AdminGuildWarLootDefense message, length delimited. Does not implicitly {@link msgProto.AdminGuildWarLootDefense.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {msgProto.IAdminGuildWarLootDefense} message AdminGuildWarLootDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarLootDefense.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildWarLootDefense message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarLootDefense} AdminGuildWarLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarLootDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarLootDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attackData = reader.string();
                    break;
                case 2:
                    message.isWin = reader.bool();
                    break;
                case 3:
                    message.defenceData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildWarLootDefense message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildWarLootDefense} AdminGuildWarLootDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarLootDefense.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildWarLootDefense message.
         * @function verify
         * @memberof msgProto.AdminGuildWarLootDefense
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildWarLootDefense.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attackData != null && message.hasOwnProperty("attackData"))
                if (!$util.isString(message.attackData))
                    return "attackData: string expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.defenceData != null && message.hasOwnProperty("defenceData"))
                if (!$util.isString(message.defenceData))
                    return "defenceData: string expected";
            return null;
        };

        return AdminGuildWarLootDefense;
    })();

    msgProto.AdminGuildWarPushBeFightRecord = (function() {

        /**
         * Properties of an AdminGuildWarPushBeFightRecord.
         * @memberof msgProto
         * @interface IAdminGuildWarPushBeFightRecord
         * @property {number|null} [guildId] AdminGuildWarPushBeFightRecord guildId
         * @property {string|null} [data] AdminGuildWarPushBeFightRecord data
         */

        /**
         * Constructs a new AdminGuildWarPushBeFightRecord.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarPushBeFightRecord.
         * @implements IAdminGuildWarPushBeFightRecord
         * @constructor
         * @param {msgProto.IAdminGuildWarPushBeFightRecord=} [properties] Properties to set
         */
        function AdminGuildWarPushBeFightRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarPushBeFightRecord guildId.
         * @member {number} guildId
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @instance
         */
        AdminGuildWarPushBeFightRecord.prototype.guildId = 0;

        /**
         * AdminGuildWarPushBeFightRecord data.
         * @member {string} data
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @instance
         */
        AdminGuildWarPushBeFightRecord.prototype.data = "";

        /**
         * Creates a new AdminGuildWarPushBeFightRecord instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {msgProto.IAdminGuildWarPushBeFightRecord=} [properties] Properties to set
         * @returns {msgProto.AdminGuildWarPushBeFightRecord} AdminGuildWarPushBeFightRecord instance
         */
        AdminGuildWarPushBeFightRecord.create = function create(properties) {
            return new AdminGuildWarPushBeFightRecord(properties);
        };

        /**
         * Encodes the specified AdminGuildWarPushBeFightRecord message. Does not implicitly {@link msgProto.AdminGuildWarPushBeFightRecord.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {msgProto.IAdminGuildWarPushBeFightRecord} message AdminGuildWarPushBeFightRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarPushBeFightRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.guildId);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified AdminGuildWarPushBeFightRecord message, length delimited. Does not implicitly {@link msgProto.AdminGuildWarPushBeFightRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {msgProto.IAdminGuildWarPushBeFightRecord} message AdminGuildWarPushBeFightRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarPushBeFightRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildWarPushBeFightRecord message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarPushBeFightRecord} AdminGuildWarPushBeFightRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarPushBeFightRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarPushBeFightRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guildId = reader.int32();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildWarPushBeFightRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildWarPushBeFightRecord} AdminGuildWarPushBeFightRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarPushBeFightRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildWarPushBeFightRecord message.
         * @function verify
         * @memberof msgProto.AdminGuildWarPushBeFightRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildWarPushBeFightRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guildId != null && message.hasOwnProperty("guildId"))
                if (!$util.isInteger(message.guildId))
                    return "guildId: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        return AdminGuildWarPushBeFightRecord;
    })();

    msgProto.AdminGuildWarGetCurServerGuildWarObj = (function() {

        /**
         * Properties of an AdminGuildWarGetCurServerGuildWarObj.
         * @memberof msgProto
         * @interface IAdminGuildWarGetCurServerGuildWarObj
         */

        /**
         * Constructs a new AdminGuildWarGetCurServerGuildWarObj.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarGetCurServerGuildWarObj.
         * @implements IAdminGuildWarGetCurServerGuildWarObj
         * @constructor
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj=} [properties] Properties to set
         */
        function AdminGuildWarGetCurServerGuildWarObj(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminGuildWarGetCurServerGuildWarObj instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj=} [properties] Properties to set
         * @returns {msgProto.AdminGuildWarGetCurServerGuildWarObj} AdminGuildWarGetCurServerGuildWarObj instance
         */
        AdminGuildWarGetCurServerGuildWarObj.create = function create(properties) {
            return new AdminGuildWarGetCurServerGuildWarObj(properties);
        };

        /**
         * Encodes the specified AdminGuildWarGetCurServerGuildWarObj message. Does not implicitly {@link msgProto.AdminGuildWarGetCurServerGuildWarObj.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj} message AdminGuildWarGetCurServerGuildWarObj message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarGetCurServerGuildWarObj.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminGuildWarGetCurServerGuildWarObj message, length delimited. Does not implicitly {@link msgProto.AdminGuildWarGetCurServerGuildWarObj.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {msgProto.IAdminGuildWarGetCurServerGuildWarObj} message AdminGuildWarGetCurServerGuildWarObj message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarGetCurServerGuildWarObj.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildWarGetCurServerGuildWarObj message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarGetCurServerGuildWarObj} AdminGuildWarGetCurServerGuildWarObj
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarGetCurServerGuildWarObj.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarGetCurServerGuildWarObj();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildWarGetCurServerGuildWarObj message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildWarGetCurServerGuildWarObj} AdminGuildWarGetCurServerGuildWarObj
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarGetCurServerGuildWarObj.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildWarGetCurServerGuildWarObj message.
         * @function verify
         * @memberof msgProto.AdminGuildWarGetCurServerGuildWarObj
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildWarGetCurServerGuildWarObj.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminGuildWarGetCurServerGuildWarObj;
    })();

    msgProto.AdminGuildWarEnter100User = (function() {

        /**
         * Properties of an AdminGuildWarEnter100User.
         * @memberof msgProto
         * @interface IAdminGuildWarEnter100User
         */

        /**
         * Constructs a new AdminGuildWarEnter100User.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarEnter100User.
         * @implements IAdminGuildWarEnter100User
         * @constructor
         * @param {msgProto.IAdminGuildWarEnter100User=} [properties] Properties to set
         */
        function AdminGuildWarEnter100User(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminGuildWarEnter100User instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {msgProto.IAdminGuildWarEnter100User=} [properties] Properties to set
         * @returns {msgProto.AdminGuildWarEnter100User} AdminGuildWarEnter100User instance
         */
        AdminGuildWarEnter100User.create = function create(properties) {
            return new AdminGuildWarEnter100User(properties);
        };

        /**
         * Encodes the specified AdminGuildWarEnter100User message. Does not implicitly {@link msgProto.AdminGuildWarEnter100User.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {msgProto.IAdminGuildWarEnter100User} message AdminGuildWarEnter100User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarEnter100User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminGuildWarEnter100User message, length delimited. Does not implicitly {@link msgProto.AdminGuildWarEnter100User.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {msgProto.IAdminGuildWarEnter100User} message AdminGuildWarEnter100User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarEnter100User.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildWarEnter100User message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarEnter100User} AdminGuildWarEnter100User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarEnter100User.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarEnter100User();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildWarEnter100User message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildWarEnter100User} AdminGuildWarEnter100User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarEnter100User.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildWarEnter100User message.
         * @function verify
         * @memberof msgProto.AdminGuildWarEnter100User
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildWarEnter100User.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminGuildWarEnter100User;
    })();

    msgProto.AdminGuildWarSyncGetSyncServer = (function() {

        /**
         * Properties of an AdminGuildWarSyncGetSyncServer.
         * @memberof msgProto
         * @interface IAdminGuildWarSyncGetSyncServer
         * @property {string|null} [curServerData] AdminGuildWarSyncGetSyncServer curServerData
         */

        /**
         * Constructs a new AdminGuildWarSyncGetSyncServer.
         * @memberof msgProto
         * @classdesc Represents an AdminGuildWarSyncGetSyncServer.
         * @implements IAdminGuildWarSyncGetSyncServer
         * @constructor
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer=} [properties] Properties to set
         */
        function AdminGuildWarSyncGetSyncServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminGuildWarSyncGetSyncServer curServerData.
         * @member {string} curServerData
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @instance
         */
        AdminGuildWarSyncGetSyncServer.prototype.curServerData = "";

        /**
         * Creates a new AdminGuildWarSyncGetSyncServer instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer=} [properties] Properties to set
         * @returns {msgProto.AdminGuildWarSyncGetSyncServer} AdminGuildWarSyncGetSyncServer instance
         */
        AdminGuildWarSyncGetSyncServer.create = function create(properties) {
            return new AdminGuildWarSyncGetSyncServer(properties);
        };

        /**
         * Encodes the specified AdminGuildWarSyncGetSyncServer message. Does not implicitly {@link msgProto.AdminGuildWarSyncGetSyncServer.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer} message AdminGuildWarSyncGetSyncServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarSyncGetSyncServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.curServerData != null && message.hasOwnProperty("curServerData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.curServerData);
            return writer;
        };

        /**
         * Encodes the specified AdminGuildWarSyncGetSyncServer message, length delimited. Does not implicitly {@link msgProto.AdminGuildWarSyncGetSyncServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {msgProto.IAdminGuildWarSyncGetSyncServer} message AdminGuildWarSyncGetSyncServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminGuildWarSyncGetSyncServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminGuildWarSyncGetSyncServer message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminGuildWarSyncGetSyncServer} AdminGuildWarSyncGetSyncServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarSyncGetSyncServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminGuildWarSyncGetSyncServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.curServerData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminGuildWarSyncGetSyncServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminGuildWarSyncGetSyncServer} AdminGuildWarSyncGetSyncServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminGuildWarSyncGetSyncServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminGuildWarSyncGetSyncServer message.
         * @function verify
         * @memberof msgProto.AdminGuildWarSyncGetSyncServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminGuildWarSyncGetSyncServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.curServerData != null && message.hasOwnProperty("curServerData"))
                if (!$util.isString(message.curServerData))
                    return "curServerData: string expected";
            return null;
        };

        return AdminGuildWarSyncGetSyncServer;
    })();

    msgProto.AdminTreasureGetTreasureCash = (function() {

        /**
         * Properties of an AdminTreasureGetTreasureCash.
         * @memberof msgProto
         * @interface IAdminTreasureGetTreasureCash
         */

        /**
         * Constructs a new AdminTreasureGetTreasureCash.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureGetTreasureCash.
         * @implements IAdminTreasureGetTreasureCash
         * @constructor
         * @param {msgProto.IAdminTreasureGetTreasureCash=} [properties] Properties to set
         */
        function AdminTreasureGetTreasureCash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminTreasureGetTreasureCash instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureCash=} [properties] Properties to set
         * @returns {msgProto.AdminTreasureGetTreasureCash} AdminTreasureGetTreasureCash instance
         */
        AdminTreasureGetTreasureCash.create = function create(properties) {
            return new AdminTreasureGetTreasureCash(properties);
        };

        /**
         * Encodes the specified AdminTreasureGetTreasureCash message. Does not implicitly {@link msgProto.AdminTreasureGetTreasureCash.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureCash} message AdminTreasureGetTreasureCash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureCash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminTreasureGetTreasureCash message, length delimited. Does not implicitly {@link msgProto.AdminTreasureGetTreasureCash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureCash} message AdminTreasureGetTreasureCash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureCash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminTreasureGetTreasureCash message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureGetTreasureCash} AdminTreasureGetTreasureCash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureCash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureGetTreasureCash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminTreasureGetTreasureCash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminTreasureGetTreasureCash} AdminTreasureGetTreasureCash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureCash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminTreasureGetTreasureCash message.
         * @function verify
         * @memberof msgProto.AdminTreasureGetTreasureCash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminTreasureGetTreasureCash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminTreasureGetTreasureCash;
    })();

    msgProto.AdminTreasureGetTreasureByUserId = (function() {

        /**
         * Properties of an AdminTreasureGetTreasureByUserId.
         * @memberof msgProto
         * @interface IAdminTreasureGetTreasureByUserId
         */

        /**
         * Constructs a new AdminTreasureGetTreasureByUserId.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureGetTreasureByUserId.
         * @implements IAdminTreasureGetTreasureByUserId
         * @constructor
         * @param {msgProto.IAdminTreasureGetTreasureByUserId=} [properties] Properties to set
         */
        function AdminTreasureGetTreasureByUserId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AdminTreasureGetTreasureByUserId instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureByUserId=} [properties] Properties to set
         * @returns {msgProto.AdminTreasureGetTreasureByUserId} AdminTreasureGetTreasureByUserId instance
         */
        AdminTreasureGetTreasureByUserId.create = function create(properties) {
            return new AdminTreasureGetTreasureByUserId(properties);
        };

        /**
         * Encodes the specified AdminTreasureGetTreasureByUserId message. Does not implicitly {@link msgProto.AdminTreasureGetTreasureByUserId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureByUserId} message AdminTreasureGetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureByUserId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AdminTreasureGetTreasureByUserId message, length delimited. Does not implicitly {@link msgProto.AdminTreasureGetTreasureByUserId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureGetTreasureByUserId} message AdminTreasureGetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureGetTreasureByUserId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminTreasureGetTreasureByUserId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureGetTreasureByUserId} AdminTreasureGetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureByUserId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureGetTreasureByUserId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminTreasureGetTreasureByUserId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminTreasureGetTreasureByUserId} AdminTreasureGetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureGetTreasureByUserId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminTreasureGetTreasureByUserId message.
         * @function verify
         * @memberof msgProto.AdminTreasureGetTreasureByUserId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminTreasureGetTreasureByUserId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AdminTreasureGetTreasureByUserId;
    })();

    msgProto.AdminTreasureSetTreasureByUserId = (function() {

        /**
         * Properties of an AdminTreasureSetTreasureByUserId.
         * @memberof msgProto
         * @interface IAdminTreasureSetTreasureByUserId
         * @property {number|Long|null} [userId] AdminTreasureSetTreasureByUserId userId
         */

        /**
         * Constructs a new AdminTreasureSetTreasureByUserId.
         * @memberof msgProto
         * @classdesc Represents an AdminTreasureSetTreasureByUserId.
         * @implements IAdminTreasureSetTreasureByUserId
         * @constructor
         * @param {msgProto.IAdminTreasureSetTreasureByUserId=} [properties] Properties to set
         */
        function AdminTreasureSetTreasureByUserId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdminTreasureSetTreasureByUserId userId.
         * @member {number|Long} userId
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @instance
         */
        AdminTreasureSetTreasureByUserId.prototype.userId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AdminTreasureSetTreasureByUserId instance using the specified properties.
         * @function create
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureSetTreasureByUserId=} [properties] Properties to set
         * @returns {msgProto.AdminTreasureSetTreasureByUserId} AdminTreasureSetTreasureByUserId instance
         */
        AdminTreasureSetTreasureByUserId.create = function create(properties) {
            return new AdminTreasureSetTreasureByUserId(properties);
        };

        /**
         * Encodes the specified AdminTreasureSetTreasureByUserId message. Does not implicitly {@link msgProto.AdminTreasureSetTreasureByUserId.verify|verify} messages.
         * @function encode
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureSetTreasureByUserId} message AdminTreasureSetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureSetTreasureByUserId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userId);
            return writer;
        };

        /**
         * Encodes the specified AdminTreasureSetTreasureByUserId message, length delimited. Does not implicitly {@link msgProto.AdminTreasureSetTreasureByUserId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {msgProto.IAdminTreasureSetTreasureByUserId} message AdminTreasureSetTreasureByUserId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdminTreasureSetTreasureByUserId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdminTreasureSetTreasureByUserId message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.AdminTreasureSetTreasureByUserId} AdminTreasureSetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureSetTreasureByUserId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.AdminTreasureSetTreasureByUserId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdminTreasureSetTreasureByUserId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.AdminTreasureSetTreasureByUserId} AdminTreasureSetTreasureByUserId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdminTreasureSetTreasureByUserId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdminTreasureSetTreasureByUserId message.
         * @function verify
         * @memberof msgProto.AdminTreasureSetTreasureByUserId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdminTreasureSetTreasureByUserId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId) && !(message.userId && $util.isInteger(message.userId.low) && $util.isInteger(message.userId.high)))
                    return "userId: integer|Long expected";
            return null;
        };

        return AdminTreasureSetTreasureByUserId;
    })();

    msgProto.ServerInfo = (function() {

        /**
         * Properties of a ServerInfo.
         * @memberof msgProto
         * @interface IServerInfo
         * @property {string|null} [Ip] ServerInfo Ip
         * @property {number|null} [Port] ServerInfo Port
         */

        /**
         * Constructs a new ServerInfo.
         * @memberof msgProto
         * @classdesc Represents a ServerInfo.
         * @implements IServerInfo
         * @constructor
         * @param {msgProto.IServerInfo=} [properties] Properties to set
         */
        function ServerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerInfo Ip.
         * @member {string} Ip
         * @memberof msgProto.ServerInfo
         * @instance
         */
        ServerInfo.prototype.Ip = "";

        /**
         * ServerInfo Port.
         * @member {number} Port
         * @memberof msgProto.ServerInfo
         * @instance
         */
        ServerInfo.prototype.Port = 0;

        /**
         * Creates a new ServerInfo instance using the specified properties.
         * @function create
         * @memberof msgProto.ServerInfo
         * @static
         * @param {msgProto.IServerInfo=} [properties] Properties to set
         * @returns {msgProto.ServerInfo} ServerInfo instance
         */
        ServerInfo.create = function create(properties) {
            return new ServerInfo(properties);
        };

        /**
         * Encodes the specified ServerInfo message. Does not implicitly {@link msgProto.ServerInfo.verify|verify} messages.
         * @function encode
         * @memberof msgProto.ServerInfo
         * @static
         * @param {msgProto.IServerInfo} message ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Ip);
            if (message.Port != null && message.hasOwnProperty("Port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Port);
            return writer;
        };

        /**
         * Encodes the specified ServerInfo message, length delimited. Does not implicitly {@link msgProto.ServerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.ServerInfo
         * @static
         * @param {msgProto.IServerInfo} message ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.ServerInfo} ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.ServerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Ip = reader.string();
                    break;
                case 2:
                    message.Port = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.ServerInfo} ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerInfo message.
         * @function verify
         * @memberof msgProto.ServerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                if (!$util.isString(message.Ip))
                    return "Ip: string expected";
            if (message.Port != null && message.hasOwnProperty("Port"))
                if (!$util.isInteger(message.Port))
                    return "Port: integer expected";
            return null;
        };

        return ServerInfo;
    })();

    msgProto.PingAck = (function() {

        /**
         * Properties of a PingAck.
         * @memberof msgProto
         * @interface IPingAck
         */

        /**
         * Constructs a new PingAck.
         * @memberof msgProto
         * @classdesc Represents a PingAck.
         * @implements IPingAck
         * @constructor
         * @param {msgProto.IPingAck=} [properties] Properties to set
         */
        function PingAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PingAck instance using the specified properties.
         * @function create
         * @memberof msgProto.PingAck
         * @static
         * @param {msgProto.IPingAck=} [properties] Properties to set
         * @returns {msgProto.PingAck} PingAck instance
         */
        PingAck.create = function create(properties) {
            return new PingAck(properties);
        };

        /**
         * Encodes the specified PingAck message. Does not implicitly {@link msgProto.PingAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.PingAck
         * @static
         * @param {msgProto.IPingAck} message PingAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PingAck message, length delimited. Does not implicitly {@link msgProto.PingAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.PingAck
         * @static
         * @param {msgProto.IPingAck} message PingAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.PingAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.PingAck} PingAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.PingAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.PingAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.PingAck} PingAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingAck message.
         * @function verify
         * @memberof msgProto.PingAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PingAck;
    })();

    msgProto.LoginReq = (function() {

        /**
         * Properties of a LoginReq.
         * @memberof msgProto
         * @interface ILoginReq
         * @property {string|null} [Version] LoginReq Version
         * @property {string|null} [Platform] LoginReq Platform
         * @property {string|null} [Uid] LoginReq Uid
         */

        /**
         * Constructs a new LoginReq.
         * @memberof msgProto
         * @classdesc Represents a LoginReq.
         * @implements ILoginReq
         * @constructor
         * @param {msgProto.ILoginReq=} [properties] Properties to set
         */
        function LoginReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginReq Version.
         * @member {string} Version
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Version = "";

        /**
         * LoginReq Platform.
         * @member {string} Platform
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Platform = "";

        /**
         * LoginReq Uid.
         * @member {string} Uid
         * @memberof msgProto.LoginReq
         * @instance
         */
        LoginReq.prototype.Uid = "";

        /**
         * Creates a new LoginReq instance using the specified properties.
         * @function create
         * @memberof msgProto.LoginReq
         * @static
         * @param {msgProto.ILoginReq=} [properties] Properties to set
         * @returns {msgProto.LoginReq} LoginReq instance
         */
        LoginReq.create = function create(properties) {
            return new LoginReq(properties);
        };

        /**
         * Encodes the specified LoginReq message. Does not implicitly {@link msgProto.LoginReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginReq
         * @static
         * @param {msgProto.ILoginReq} message LoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Version != null && message.hasOwnProperty("Version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Version);
            if (message.Platform != null && message.hasOwnProperty("Platform"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Platform);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified LoginReq message, length delimited. Does not implicitly {@link msgProto.LoginReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LoginReq
         * @static
         * @param {msgProto.ILoginReq} message LoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginReq} LoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Version = reader.string();
                    break;
                case 2:
                    message.Platform = reader.string();
                    break;
                case 3:
                    message.Uid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LoginReq} LoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginReq message.
         * @function verify
         * @memberof msgProto.LoginReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Version != null && message.hasOwnProperty("Version"))
                if (!$util.isString(message.Version))
                    return "Version: string expected";
            if (message.Platform != null && message.hasOwnProperty("Platform"))
                if (!$util.isString(message.Platform))
                    return "Platform: string expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isString(message.Uid))
                    return "Uid: string expected";
            return null;
        };

        return LoginReq;
    })();

    msgProto.LoginAck = (function() {

        /**
         * Properties of a LoginAck.
         * @memberof msgProto
         * @interface ILoginAck
         * @property {msgProto.ResultCode|null} [Result] LoginAck Result
         * @property {msgProto.IServerInfo|null} [Server] LoginAck Server
         * @property {string|null} [GameToken] LoginAck GameToken
         * @property {string|null} [GameSvcId] LoginAck GameSvcId
         */

        /**
         * Constructs a new LoginAck.
         * @memberof msgProto
         * @classdesc Represents a LoginAck.
         * @implements ILoginAck
         * @constructor
         * @param {msgProto.ILoginAck=} [properties] Properties to set
         */
        function LoginAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginAck Result.
         * @member {msgProto.ResultCode} Result
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.Result = 0;

        /**
         * LoginAck Server.
         * @member {msgProto.IServerInfo|null|undefined} Server
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.Server = null;

        /**
         * LoginAck GameToken.
         * @member {string} GameToken
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.GameToken = "";

        /**
         * LoginAck GameSvcId.
         * @member {string} GameSvcId
         * @memberof msgProto.LoginAck
         * @instance
         */
        LoginAck.prototype.GameSvcId = "";

        /**
         * Creates a new LoginAck instance using the specified properties.
         * @function create
         * @memberof msgProto.LoginAck
         * @static
         * @param {msgProto.ILoginAck=} [properties] Properties to set
         * @returns {msgProto.LoginAck} LoginAck instance
         */
        LoginAck.create = function create(properties) {
            return new LoginAck(properties);
        };

        /**
         * Encodes the specified LoginAck message. Does not implicitly {@link msgProto.LoginAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.LoginAck
         * @static
         * @param {msgProto.ILoginAck} message LoginAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            if (message.Server != null && message.hasOwnProperty("Server"))
                $root.msgProto.ServerInfo.encode(message.Server, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.GameToken);
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.GameSvcId);
            return writer;
        };

        /**
         * Encodes the specified LoginAck message, length delimited. Does not implicitly {@link msgProto.LoginAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.LoginAck
         * @static
         * @param {msgProto.ILoginAck} message LoginAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.LoginAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.LoginAck} LoginAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.LoginAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                case 2:
                    message.Server = $root.msgProto.ServerInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.GameToken = reader.string();
                    break;
                case 4:
                    message.GameSvcId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.LoginAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.LoginAck} LoginAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginAck message.
         * @function verify
         * @memberof msgProto.LoginAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                switch (message.Result) {
                default:
                    return "Result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.Server != null && message.hasOwnProperty("Server")) {
                var error = $root.msgProto.ServerInfo.verify(message.Server);
                if (error)
                    return "Server." + error;
            }
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                if (!$util.isString(message.GameToken))
                    return "GameToken: string expected";
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                if (!$util.isString(message.GameSvcId))
                    return "GameSvcId: string expected";
            return null;
        };

        return LoginAck;
    })();

    msgProto.VerifyReq = (function() {

        /**
         * Properties of a VerifyReq.
         * @memberof msgProto
         * @interface IVerifyReq
         * @property {string|null} [GameToken] VerifyReq GameToken
         * @property {string|null} [GameSvcId] VerifyReq GameSvcId
         * @property {number|Long|null} [AccountId] VerifyReq AccountId
         */

        /**
         * Constructs a new VerifyReq.
         * @memberof msgProto
         * @classdesc Represents a VerifyReq.
         * @implements IVerifyReq
         * @constructor
         * @param {msgProto.IVerifyReq=} [properties] Properties to set
         */
        function VerifyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyReq GameToken.
         * @member {string} GameToken
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.GameToken = "";

        /**
         * VerifyReq GameSvcId.
         * @member {string} GameSvcId
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.GameSvcId = "";

        /**
         * VerifyReq AccountId.
         * @member {number|Long} AccountId
         * @memberof msgProto.VerifyReq
         * @instance
         */
        VerifyReq.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new VerifyReq instance using the specified properties.
         * @function create
         * @memberof msgProto.VerifyReq
         * @static
         * @param {msgProto.IVerifyReq=} [properties] Properties to set
         * @returns {msgProto.VerifyReq} VerifyReq instance
         */
        VerifyReq.create = function create(properties) {
            return new VerifyReq(properties);
        };

        /**
         * Encodes the specified VerifyReq message. Does not implicitly {@link msgProto.VerifyReq.verify|verify} messages.
         * @function encode
         * @memberof msgProto.VerifyReq
         * @static
         * @param {msgProto.IVerifyReq} message VerifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GameToken);
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.GameSvcId);
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.AccountId);
            return writer;
        };

        /**
         * Encodes the specified VerifyReq message, length delimited. Does not implicitly {@link msgProto.VerifyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.VerifyReq
         * @static
         * @param {msgProto.IVerifyReq} message VerifyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyReq message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.VerifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.VerifyReq} VerifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.VerifyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GameToken = reader.string();
                    break;
                case 2:
                    message.GameSvcId = reader.string();
                    break;
                case 3:
                    message.AccountId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.VerifyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.VerifyReq} VerifyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyReq message.
         * @function verify
         * @memberof msgProto.VerifyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GameToken != null && message.hasOwnProperty("GameToken"))
                if (!$util.isString(message.GameToken))
                    return "GameToken: string expected";
            if (message.GameSvcId != null && message.hasOwnProperty("GameSvcId"))
                if (!$util.isString(message.GameSvcId))
                    return "GameSvcId: string expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            return null;
        };

        return VerifyReq;
    })();

    msgProto.VerifyAck = (function() {

        /**
         * Properties of a VerifyAck.
         * @memberof msgProto
         * @interface IVerifyAck
         * @property {msgProto.ResultCode|null} [Result] VerifyAck Result
         */

        /**
         * Constructs a new VerifyAck.
         * @memberof msgProto
         * @classdesc Represents a VerifyAck.
         * @implements IVerifyAck
         * @constructor
         * @param {msgProto.IVerifyAck=} [properties] Properties to set
         */
        function VerifyAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyAck Result.
         * @member {msgProto.ResultCode} Result
         * @memberof msgProto.VerifyAck
         * @instance
         */
        VerifyAck.prototype.Result = 0;

        /**
         * Creates a new VerifyAck instance using the specified properties.
         * @function create
         * @memberof msgProto.VerifyAck
         * @static
         * @param {msgProto.IVerifyAck=} [properties] Properties to set
         * @returns {msgProto.VerifyAck} VerifyAck instance
         */
        VerifyAck.create = function create(properties) {
            return new VerifyAck(properties);
        };

        /**
         * Encodes the specified VerifyAck message. Does not implicitly {@link msgProto.VerifyAck.verify|verify} messages.
         * @function encode
         * @memberof msgProto.VerifyAck
         * @static
         * @param {msgProto.IVerifyAck} message VerifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            return writer;
        };

        /**
         * Encodes the specified VerifyAck message, length delimited. Does not implicitly {@link msgProto.VerifyAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgProto.VerifyAck
         * @static
         * @param {msgProto.IVerifyAck} message VerifyAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyAck message from the specified reader or buffer.
         * @function decode
         * @memberof msgProto.VerifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgProto.VerifyAck} VerifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgProto.VerifyAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgProto.VerifyAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgProto.VerifyAck} VerifyAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyAck message.
         * @function verify
         * @memberof msgProto.VerifyAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                switch (message.Result) {
                default:
                    return "Result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        return VerifyAck;
    })();

    /**
     * ResultCode enum.
     * @name msgProto.ResultCode
     * @enum {string}
     * @property {number} NoError=0 NoError value
     * @property {number} GateNotFound=1 GateNotFound value
     * @property {number} GateAddressError=2 GateAddressError value
     * @property {number} GameNotFound=3 GameNotFound value
     */
    msgProto.ResultCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoError"] = 0;
        values[valuesById[1] = "GateNotFound"] = 1;
        values[valuesById[2] = "GateAddressError"] = 2;
        values[valuesById[3] = "GameNotFound"] = 3;
        return values;
    })();

    return msgProto;
})();